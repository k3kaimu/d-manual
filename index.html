<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="pandoc.css">
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#d言語入門-hello-world">D言語入門-Hello, World!</a><ul>
<li><a href="#hello-worldその前に">Hello, world!—その前に</a></li>
<li><a href="#hello-world">Hello, world!</a><ul>
<li><a href="#注意">注意…</a></li>
</ul></li>
<li><a href="#hello-worldを詳しくみてみる">Hello, world!を詳しくみてみる</a><ul>
<li><a href="#注意-1">注意…</a></li>
<li><a href="#行目">1行目</a></li>
<li><a href="#行目-1">2行目</a></li>
<li><a href="#行目-2">3行目</a></li>
<li><a href="#行目-3">4行目</a></li>
<li><a href="#行目-4">5行目</a></li>
<li><a href="#行目-5">6行目</a></li>
</ul></li>
<li><a href="#write-writelnと型について">write, writelnと型について</a></li>
<li><a href="#関数について">関数について</a></li>
<li><a href="#writef-writefln">writef, writefln</a></li>
<li><a href="#コメント">コメント</a></li>
<li><a href="#問題---解答">問題 -&gt; <a href="answer.md#hello_world">解答</a></a></li>
<li><a href="#おわりに">おわりに</a></li>
<li><a href="#キーワード">キーワード</a></li>
</ul></li>
<li><a href="#変数と型">変数と型</a><ul>
<li><a href="#式expressionと文statementとは">式(Expression)と文(Statement)とは？</a></li>
<li><a href="#変数variable">変数(Variable)</a><ul>
<li><a href="#変数の宣言declaration">変数の宣言(Declaration)</a></li>
<li><a href="#変数の寿命とスコープ">変数の寿命とスコープ</a></li>
<li><a href="#左辺値lvalueと右辺値rvalue">左辺値(lvalue)と右辺値(rvalue)</a></li>
</ul></li>
<li><a href="#いろいろな型type">いろいろな型(Type)</a><ul>
<li><a href="#リテラルliteralとシンボルsymbol">リテラル(Literal)とシンボル(Symbol)</a></li>
<li><a href="#デフォルト初期化値default-initializer-type.init">デフォルト初期化値(Default Initializer; Type.init)</a></li>
<li><a href="#void">void</a></li>
<li><a href="#論理型boolean">論理型(Boolean)</a></li>
<li><a href="#整数型decimal-number">整数型(Decimal Number)</a></li>
<li><a href="#浮動小数点型floating-point-number">浮動小数点型(Floating-Point Number)</a></li>
<li><a href="#虚数浮動小数点型imaginary-floating-point-number">虚数浮動小数点型(Imaginary Floating-Point Number)</a></li>
<li><a href="#複素浮動小数点型complex-floating-point-number">複素浮動小数点型(Complex Floating-Point Number)</a></li>
<li><a href="#文字型charactor">文字型(Charactor)</a></li>
<li><a href="#文字列型string">文字列型(String)</a></li>
<li><a href="#派生型derived-data-type">派生型(Derived Data Type)</a></li>
<li><a href="#ユーザー定義型user-defined-type">ユーザー定義型(User Defined Type)</a></li>
</ul></li>
<li><a href="#型修飾子type-qualifiers">型修飾子(Type Qualifiers)</a><ul>
<li><a href="#const">const</a></li>
<li><a href="#immutable">immutable</a></li>
<li><a href="#shared">shared</a></li>
</ul></li>
<li><a href="#記憶域クラスstorage-class">記憶域クラス(Storage Class)</a><ul>
<li><a href="#const-1">const</a></li>
<li><a href="#immutable-1">immutable</a></li>
<li><a href="#shared-1">shared</a></li>
<li><a href="#scope">scope</a></li>
<li><a href="#関数でのみ有効となる記憶域クラス">関数でのみ有効となる記憶域クラス</a></li>
</ul></li>
<li><a href="#型推論type-inference">型推論(Type Inference)</a></li>
<li><a href="#問題---解答-1">問題 -&gt; <a href="answer.md#variable_type">解答</a></a></li>
<li><a href="#おわりに-1">おわりに</a></li>
<li><a href="#キーワード-1">キーワード</a></li>
</ul></li>
<li><a href="#式と演算子">式と演算子</a><ul>
<li><a href="#式と演算子-1">式と演算子</a></li>
<li><a href="#演算子と暗黙の数値型変換">演算子と暗黙の数値型変換</a></li>
<li><a href="#数値型に対する演算子">数値型に対する演算子</a><ul>
<li><a href="#括弧bracket">括弧(bracket)</a></li>
<li><a href="#単項プラスunary-plus-単項マイナスunary-minus">単項プラス(unary plus), 単項マイナス(unary minus)</a></li>
<li><a href="#インクリメントincrement-デクリメントdecrement">インクリメント(increment), デクリメント(decrement)</a></li>
<li><a href="#算術演算子">算術演算子</a></li>
<li><a href="#ビット演算子bitwise-operators">ビット演算子(Bitwise operators)</a></li>
<li><a href="#代入演算子assignment-operator-複合代入演算子compound-assignment-operators">代入演算子(Assignment operator), 複合代入演算子(Compound assignment operators)</a></li>
<li><a href="#同値テストequal-to-非同値テストnot-equal-to">同値テスト(Equal to), 非同値テスト(Not equal to)</a></li>
<li><a href="#比較compare">比較(Compare)</a></li>
<li><a href="#論理演算子logical-operators">論理演算子(Logical operators)</a></li>
<li><a href="#コンマ演算子">コンマ演算子</a></li>
</ul></li>
<li><a href="#付録-演算子の優先順位と結合規則">付録 演算子の優先順位と結合規則</a></li>
<li><a href="#問題---解答-2">問題 -&gt; <a href="answer.md#expr_operator">解答</a></a></li>
<li><a href="#おわりに-2">おわりに</a></li>
<li><a href="#キーワード-2">キーワード</a></li>
</ul></li>
<li><a href="#条件分岐">条件分岐</a><ul>
<li><a href="#文のいろいろ">文のいろいろ</a></li>
<li><a href="#条件分岐とは">条件分岐とは？</a></li>
<li><a href="#if文">if文</a></li>
<li><a href="#boolと評価される式">boolと評価される式</a></li>
<li><a href="#if宣言な文">if(宣言)な文</a></li>
<li><a href="#且つと又は">&amp;&amp;(且つ)と||(又は)</a></li>
<li><a href="#問題---解答-3">問題 -&gt; <a href="answer.md#if">解答</a></a></li>
<li><a href="#おわりに-3">おわりに</a></li>
<li><a href="#キーワード-3">キーワード</a></li>
<li><a href="#if文の仕様">if文の仕様</a></li>
</ul></li>
<li><a href="#反復処理">反復処理</a><ul>
<li><a href="#while文">while文</a><ul>
<li><a href="#無限ループ">無限ループ</a></li>
</ul></li>
<li><a href="#do文">do文</a></li>
<li><a href="#for文">for文</a></li>
<li><a href="#foreach-range文">foreach range文</a><ul>
<li><a href="#foreach_reverse">foreach_reverse</a></li>
</ul></li>
<li><a href="#ループを抜ける-次に進める">ループを抜ける, 次に進める</a><ul>
<li><a href="#ループから抜け出す">ループから抜け出す</a></li>
<li><a href="#ループを次に進める">ループを次に進める</a></li>
</ul></li>
<li><a href="#問題---解答-4">問題 -&gt; <a href="answer.md#loop">解答</a></a></li>
<li><a href="#おわりに-4">おわりに</a></li>
<li><a href="#キーワード-4">キーワード</a></li>
<li><a href="#仕様">仕様</a></li>
</ul></li>
<li><a href="#その他の制御文">その他の制御文</a><ul>
<li><a href="#goto文とラベル">goto文とラベル</a></li>
<li><a href="#switch文とcase文">switch文とcase文</a></li>
<li><a href="#問題---解答-5">問題 -&gt; <a href="answer.md#other_statements">解答</a></a></li>
<li><a href="#おわりに-5">おわりに</a></li>
<li><a href="#キーワード-5">キーワード</a></li>
<li><a href="#仕様-1">仕様</a></li>
</ul></li>
<li><a href="#配列">配列</a><ul>
<li><a href="#配列arrayとは">配列(Array)とは？</a></li>
<li><a href="#スタックとヒープ">スタックとヒープ</a></li>
<li><a href="#静的配列static-array">静的配列(Static Array)</a></li>
<li><a href="#配列とポインタのお話">配列とポインタのお話</a></li>
<li><a href="#スライス">スライス</a><ul>
<li><a href="#ヒープ上のメモリの確保">ヒープ上のメモリの確保</a></li>
<li><a href="#要素の追加とスライス同士の結合大きさの拡大縮小">要素の追加とスライス同士の結合、大きさの拡大縮小</a></li>
<li><a href="#ガベージコレクタ">ガベージコレクタ</a></li>
<li><a href="#スライス演算子">スライス演算子</a></li>
<li><a href="#スライスを使ったベクトル演算">スライスを使ったベクトル演算</a></li>
<li><a href="#スライスの独立性">スライスの独立性</a></li>
</ul></li>
<li><a href="#スライスや配列の等価テスト同値テスト">スライスや配列の等価テスト(同値テスト)</a></li>
<li><a href="#スライスや配列の大小比較">スライスや配列の大小比較</a></li>
<li><a href="#foreachと配列">foreachと配列</a></li>
<li><a href="#rangeとスライス">Rangeとスライス</a></li>
<li><a href="#静的配列やスライスのプロパティとメソッド">静的配列やスライスのプロパティとメソッド</a></li>
<li><a href="#多次元配列配列の配列">多次元配列(配列の配列)</a></li>
<li><a href="#配列操作のまとめ">配列操作のまとめ</a></li>
<li><a href="#問題---解答-6">問題 -&gt; <a href="answer.md#array">解答</a></a></li>
<li><a href="#終わりに">終わりに</a></li>
<li><a href="#キーワード-6">キーワード</a></li>
<li><a href="#仕様-2">仕様</a></li>
</ul></li>
<li><a href="#文字列">文字列</a><ul>
<li><a href="#文字コード">文字コード</a></li>
<li><a href="#文字リテラルと文字列リテラルと型">文字リテラルと文字列リテラルと型</a></li>
<li><a href="#改行文字と制御文字">改行文字と制御文字</a></li>
<li><a href="#基本的な文字列操作">基本的な文字列操作</a><ul>
<li><a href="#文字列と配列">文字列と配列</a></li>
<li><a href="#文字列の先頭の文字を得るには">文字列の先頭の文字を得るには？</a></li>
<li><a href="#文字目以降を得る">2文字目以降を得る</a></li>
<li><a href="#文字列からある部分を取り出す">文字列からある部分を取り出す</a></li>
<li><a href="#文字列を結合する">文字列を結合する</a></li>
<li><a href="#文字列の比較">文字列の比較</a></li>
<li><a href="#boolへの変換"><code>bool</code>への変換</a></li>
</ul></li>
<li><a href="#少しレベルアップした文字列操作">少しレベルアップした文字列操作</a></li>
<li><a href="#問題">問題</a></li>
<li><a href="#おわりに-6">おわりに</a></li>
<li><a href="#キーワード-7">キーワード</a></li>
<li><a href="#仕様-3">仕様</a></li>
</ul></li>
<li><a href="#連想配列">連想配列</a><ul>
<li><a href="#連想配列associative-arrayとは">連想配列(Associative Array)とは？</a></li>
<li><a href="#基本操作">基本操作</a><ul>
<li><a href="#in演算子">in演算子</a></li>
<li><a href="#同値テスト-is">同値テスト(<code>==</code>, <code>is</code>)</a></li>
</ul></li>
<li><a href="#プロパティ">プロパティ</a><ul>
<li><a href="#size_t-aa.length"><code>size_t aa.length</code></a></li>
<li><a href="#vk-aa.dup"><code>V[K] aa.dup</code></a></li>
<li><a href="#v-aa.getk-key-lazy-v-defvalue"><code>V aa.get(K key, lazy V defValue)</code></a></li>
<li><a href="#k-aa.keys"><code>K[] aa.keys</code></a></li>
<li><a href="#v-aa.values"><code>V[] aa.values</code></a></li>
<li><a href="#auto-aa.bykey"><code>auto aa.byKey</code></a></li>
<li><a href="#auto-aa.byvalue"><code>auto aa.byValue</code></a></li>
<li><a href="#vk-aa.rehash"><code>V[K] aa.rehash()</code></a></li>
</ul></li>
<li><a href="#foreach">foreach</a><ul>
<li><a href="#ベーシックな方法">ベーシックな方法</a></li>
<li><a href="#aa.keysを使った方法"><code>aa.keys</code>を使った方法</a></li>
<li><a href="#aa.bykeyを使った場合"><code>aa.byKey</code>を使った場合</a></li>
<li><a href="#aa.valuesを使った場合"><code>aa.values</code>を使った場合</a></li>
<li><a href="#aa.byvalueを使った場合"><code>aa.byValue()</code>を使った場合</a></li>
</ul></li>
<li><a href="#クラスをキーとして使うには高度">クラスをキーとして使うには(高度)</a></li>
<li><a href="#問題---解答-7">問題 -&gt; <a href="answer.md#associative_array">解答</a></a></li>
<li><a href="#おわりに-7">おわりに</a></li>
<li><a href="#キーワード-8">キーワード</a></li>
<li><a href="#仕様-4">仕様</a></li>
</ul></li>
<li><a href="#ポインタ">ポインタ</a><ul>
<li><a href="#ポインタとは復習">ポインタとは(復習)</a><ul>
<li><a href="#アドレスってなんやねん">アドレスってなんやねん！</a></li>
<li><a href="#アドレスとポインタってなにがどうやねん">アドレスとポインタってなにがどうやねん！</a></li>
<li><a href="#変数のアドレスってどこやねん">変数のアドレスってどこやねん！</a></li>
</ul></li>
<li><a href="#ポインタの使い方">ポインタの使い方</a><ul>
<li><a href="#ポインタと配列とインデックス演算子とポインタへの加算">ポインタと配列とインデックス演算子とポインタへの加算</a></li>
<li><a href="#ポインタと左辺値">ポインタと左辺値</a></li>
<li><a href="#ポインタの初期値とゼロ値">ポインタの初期値とゼロ値</a></li>
<li><a href="#特別なポインタvoidとスライスvoid">特別なポインタ<code>void*</code>とスライス<code>void[]</code></a></li>
</ul></li>
<li><a href="#おわりに-8">おわりに</a></li>
</ul></li>
<li><a href="#関数">関数</a><ul>
<li><a href="#関数とは">関数とは？</a><ul>
<li><a href="#関数による処理のまとめ">関数による処理のまとめ</a></li>
</ul></li>
<li><a href="#関数の基礎">関数の基礎</a><ul>
<li><a href="#宣言の書き方と関数本体">宣言の書き方と関数本体</a></li>
<li><a href="#関数の引数">関数の引数</a></li>
</ul></li>
<li><a href="#デフォルト引数">デフォルト引数</a></li>
<li><a href="#引数の記憶域クラス">引数の記憶域クラス</a></li>
<li><a href="#可変個引数関数">可変個引数関数</a></li>
<li><a href="#オブジェクトを形成する引数">オブジェクトを形成する引数</a></li>
<li><a href="#返値型推論">返値型推論</a></li>
<li><a href="#関数の属性">関数の属性</a><ul>
<li><a href="#プロパティ関数property">プロパティ関数<code>@property</code></a></li>
<li><a href="#関数のメモリ安全性">関数のメモリ安全性</a></li>
<li><a href="#純粋関数pure">純粋関数<code>pure</code></a></li>
<li><a href="#例外を投げない関数nothrow">例外を投げない関数<code>nothrow</code></a></li>
<li><a href="#udauser-defined-attribute">UDA(User Defined Attribute)</a></li>
<li><a href="#const-immutable-inout-abstract-final"><code>const</code>, <code>immutable</code>, <code>inout</code>, <code>abstract</code>, <code>final</code></a></li>
</ul></li>
<li><a href="#関数オーバーロード多重定義-overload">関数オーバーロード(多重定義, overload)</a></li>
<li><a href="#ローカルstatic変数">ローカル<code>static</code>変数</a></li>
<li><a href="#ネスト関数">ネスト関数</a></li>
<li><a href="#関数ポインタ">関数ポインタ</a></li>
<li><a href="#デリゲートdelegate">デリゲート<code>delegate</code></a></li>
<li><a href="#関数のリテラルとラムダ">関数のリテラルとラムダ</a></li>
<li><a href="#ufcsuniform-function-call-syntax">UFCS(Uniform Function Call Syntax)</a></li>
<li><a href="#ctfecompile-time-function-execution">CTFE(Compile Time Function Execution)</a></li>
<li><a href="#問題-1">問題</a></li>
<li><a href="#終わりに-1">終わりに</a></li>
<li><a href="#キーワード-9">キーワード</a></li>
<li><a href="#仕様-5">仕様</a></li>
</ul></li>
<li><a href="#main関数">main関数</a><ul>
<li><a href="#シグネチャ">シグネチャ</a></li>
<li><a href="#コマンドライン引数とstd.getopt">コマンドライン引数と<code>std.getopt</code></a></li>
<li><a href="#返り値">返り値</a></li>
<li><a href="#問題-2">問題</a></li>
<li><a href="#キーワード-10">キーワード</a></li>
</ul></li>
<li><a href="#ファイルと標準入出力">ファイルと標準入出力</a><ul>
<li><a href="#ファイル出力">ファイル出力</a><ul>
<li><a href="#std.stdio.fileを使う"><code>std.stdio.File</code>を使う</a></li>
<li><a href="#std.file.writeやstd.file.appendを使う"><code>std.file.write</code>や<code>std.file.append</code>を使う</a></li>
</ul></li>
<li><a href="#標準出力stdout">標準出力<code>stdout</code></a></li>
<li><a href="#ファイル入力">ファイル入力</a><ul>
<li><a href="#std.stdio.fileを使う-1"><code>std.stdio.File</code>を使う</a></li>
<li><a href="#std.file.readやstd.file.readtextを使う"><code>std.file.read</code>や<code>std.file.readText</code>を使う</a></li>
</ul></li>
<li><a href="#標準入力stdin">標準入力<code>stdin</code></a></li>
<li><a href="#問題-3">問題</a></li>
<li><a href="#おわりに-9">おわりに</a></li>
<li><a href="#キーワード-11">キーワード</a></li>
</ul></li>
<li><a href="#構造体">構造体</a><ul>
<li><a href="#ユーザー定義型">ユーザー定義型</a></li>
<li><a href="#複数の型をまとめるということ">複数の型をまとめるということ</a></li>
<li><a href="#構造体の基本">構造体の基本</a></li>
<li><a href="#構造化プログラミングとその発展">構造化プログラミングとその発展</a></li>
<li><a href="#メンバ関数">メンバ関数</a><ul>
<li><a href="#ufcsとメンバ関数の使い分けと型クラス余談">UFCSとメンバ関数の使い分けと型クラス(余談)</a></li>
</ul></li>
<li><a href="#アクセス保護属性とフィールドの隠蔽">アクセス保護属性とフィールドの隠蔽</a><ul>
<li><a href="#データ構造へのアクセスとプロパティ">データ構造へのアクセスとプロパティ</a></li>
</ul></li>
<li><a href="#コンストラクタ">コンストラクタ</a></li>
<li><a href="#ビットごとのコピーとpostblit">ビットごとのコピーとPostblit</a></li>
<li><a href="#デストラクタ">デストラクタ</a></li>
<li><a href="#構造体の名前空間と静的メンバ">構造体の名前空間と静的メンバ</a></li>
<li><a href="#alias-this">alias this</a></li>
<li><a href="#問題-4">問題</a></li>
<li><a href="#参考文献">参考文献</a></li>
<li><a href="#キーワード-12">キーワード</a></li>
</ul></li>
</ul>
</nav>
<h1 id="d言語入門-hello-world"><a href="#d言語入門-hello-world">D言語入門-Hello, World!</a></h1>
<h2 id="hello-worldその前に"><a href="#hello-worldその前に">Hello, world!—その前に</a></h2>
<p>プログラミングの入門といえば<code>Hello, world!</code>ですね。 早速書いてみたいのですが、皆さんは <strong>コンパイラ</strong> と <strong>テキストエディタ</strong> は手に入れていますか？</p>
<p>プログラム(==ソースコード)を書くには、テキストエディタがいります。 notepad.exeで編集したければそれでいいのですが、せっかくなのでカッコイイテキストエディタを入手しましょう。 各エディタの説明はしませんが、個人的にはSublime Text2がオススメです。</p>
<ul>
<li>Sublime Text2</li>
<li>notepad++</li>
<li>Vim</li>
<li>Emacs</li>
</ul>
<p>エディタをゲットしたら、次はコンパイラを持ってこないといけません。 D言語のコンパイラは有名なもので <strong>dmd</strong>, <strong>gdc</strong>, <strong>ldc</strong> などがありますが、普通は <strong>dmd</strong> を使うので<a href="http://dlang.org/download.html">ここ</a>からダウンロードしましょう。 Windowsの人は“dmd Windows installer”をダウンロードして実行すれば全部設定してくれます。</p>
<p>インストールが終われば、コンソール(ターミナル)画面をたちあげて<code>dmd</code>と打ちましょう。 ズラズラズラ～と文字が出てきたら成功です。</p>
<h2 id="hello-world"><a href="#hello-world">Hello, world!</a></h2>
<p>さて、テキストエディタを立ち上げて以下の文字列をそのまま打ち込んで<code>helloworld.d</code>で保存しましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;Hello, world!&quot;</span>);
}</code></pre>
<p>次にコンソールで以下をタイプします。 <code>$</code> から始まる1行はコンソールへの入力を表しますが、<code>$</code>はわざわざ打たなくて結構です。 なので、<code>$</code>以降の<code>rdmd ~</code>を打ち込みましょう。</p>
<p>(<code>rdmd</code>が見つからないとエラーが出たら<code>dmd -run</code>を使ってみてください。)</p>
<pre><code>$ rdmd helloworld.d</code></pre>
<p>コンソールで以下のように出力されれば成功です、おめでとう！</p>
<pre><code>Hello, world!</code></pre>
<h3 id="注意"><a href="#注意">注意…</a></h3>
<p>これからは<code>rdmd ...</code>などのコマンドと実行結果を一緒に、以下のように表記します。</p>
<pre><code>$ rdmd helloworld.d
Hello World!</code></pre>
<h2 id="hello-worldを詳しくみてみる"><a href="#hello-worldを詳しくみてみる">Hello, world!を詳しくみてみる</a></h2>
<p>先ほど書いたHello Worldプログラムを解析してみましょう。</p>
<h3 id="注意-1"><a href="#注意-1">注意…</a></h3>
<p>ここから先はいきなり意味がわからない単語が急増します。 しかし、後から詳しく説明しますので、難しければ素直に読み飛ばしましょう。 そのうち分かるようになるので、「もうだめぽ」とか「やっぱり自分には向いてない」とか思わないように。 執筆者も「これはまだ分からなくていい内容だわ」と割りきって書いています。</p>
<h3 id="行目"><a href="#行目">1行目</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;</code></pre>
<p>「モジュール<code>std.stdio</code>を読み込む」という意味です。 <code>std.stdio</code>の<code>std</code>はstandardの略で、<code>stdio</code>はstandard Input/Outputの略です。 なので<code>std.stdio</code>というのは、「<code>std</code>パッケージに属する<code>stdio</code>モジュール」という意味です。 これについては、モジュールの章で説明します。</p>
<p>なぜこのような記述をしなければいけないかというと、5行目で出てくる<code>writeln</code>をプログラム中で使いたいからです。 <code>writeln</code>は<code>std.stdio</code>で定義されているのですが、自分のプログラムに<code>import</code>(輸入)してやらなければ使えません。 つまり、「<code>bar</code>モジュールで定義されてる<code>foo</code>を使いたい！」という場合には、<code>import bar;</code>と書かなければいけません。</p>
<h3 id="行目-1"><a href="#行目-1">2行目</a></h3>
<p>2行目はただの空白です。 D言語のプログラムのソースコード中では、 <strong>任意の場所に空白や改行を入れても構いません</strong> 。 もちろん、<code>import</code>を<code>i   m p o r t</code>と書いてはいけません。</p>
<h3 id="行目-2"><a href="#行目-2">3行目</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()</code></pre>
<p>D言語で書かれたプログラムは、 <strong><code>main</code></strong> という関数(<code>function</code>)から始まります。 プログラムでの関数は数学の関数とほとんど同じで、入力(<code>input</code>)を受け取り、加工や外界に影響を及ぼしてから出力(<code>output</code>)を返すものです。 この<code>main</code>の場合は何も受け取らずなにも返しません(<code>void</code>)が、<code>void main(string[] args)</code>と書けば、<code>string[] args</code>を受け取ってなにも返さない<code>main</code>関数となります。 関数はソースコード上では以下のように記述されます。</p>
<pre class="sourceCode d"><code class="sourceCode d">OutputType fName(InputType1 arg1, InputType2 arg2, ...)
{
    <span class="kw">function</span> Body
}</code></pre>
<p><code>OutputType</code>は関数の出力の型(タイプ)、<code>InputType1</code>とか<code>InputType2</code>は入力の型(タイプ)で、<code>arg1, arg2</code>は仮引数(かりひきすう)と呼ばれます。 また、<code>InputType1, InputType2</code>は引数の型, <code>OutputType</code>は返り値や戻り値の型(<code>Returned Type</code>)と呼ばれます。 <code>function Body</code>は関数本体といい、入力から出力を生成する手順を記述します。</p>
<h3 id="行目-3"><a href="#行目-3">4行目</a></h3>
<pre class="sourceCode d"><code class="sourceCode d">{</code></pre>
<p>3行目の項で説明した関数の<code>{}</code>のうちの開始の括弧です。 ここから6行目の<code>}</code>までは関数本体となります。</p>
<h3 id="行目-4"><a href="#行目-4">5行目</a></h3>
<pre class="sourceCode d"><code class="sourceCode d">    writeln(<span class="st">&quot;Hello, world!&quot;</span>);</code></pre>
<p>この行は、「<code>writeln</code>という関数に<code>&quot;Hello, world!&quot;</code>を引数として渡して、呼び出す」という意味です。 <code>writeln</code>という関数は<code>std.stdio</code>にあるというのは説明しましたね。</p>
<p><code>writeln</code>は、<code>&quot;write&quot;</code>, <code>&quot;ln&quot;</code>に分解できます。 <code>&quot;write&quot;</code>は書きだす、<code>&quot;ln&quot;</code>は改行を意味します。 つまり、<code>writeln(&quot;Hello, world!&quot;)</code>は「<code>&quot;Hello, world!&quot;</code>と書きだして改行する」という意味です。</p>
<p><code>writeln</code>があるんだから、<code>write</code>もあります。 <code>write</code>は改行なしで出力すること以外は<code>writeln</code>と同じ動作です。 <code>write, writeln</code>について後ほど詳しく説明します。</p>
<h3 id="行目-5"><a href="#行目-5">6行目</a></h3>
<pre class="sourceCode d"><code class="sourceCode d">}</code></pre>
<p><code>main</code>関数の終了を表す括弧です。 D言語のソースコードでは、括弧は必ず対になっていなければなりません。</p>
<h2 id="write-writelnと型について"><a href="#write-writelnと型について">write, writelnと型について</a></h2>
<p><code>write, writeln</code>は<code>std.stdio</code>で宣言(==定義)されています。 <code>write</code>や<code>writeln</code>は複数の引数を受け取ることができます。 つまり、先ほどのHello, worldのプログラムを改変した以下のコードも有効です。 コンパイルして実行してみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;Hello, &quot;</span>, <span class="st">&quot;World! &quot;</span>, <span class="dv">123</span>);
}</code></pre>
<pre><code>$ rdmd helloworld.d
Hello, World! 123</code></pre>
<p>さて、<code>&quot;Hello, &quot;</code> や <code>&quot;World! &quot;</code> は <code>&quot;&quot;</code> でくくりましたが、<code>123</code>は<code>&quot;&quot;</code>でくくってません。 というのは、<code>&quot;&quot;</code>でくくったものは <b><code>string</code>(文字列)</b> という型になるのに対し、<code>123</code>とそのまま書くと <strong><code>int</code>(整数)</strong> という型になります。</p>
<p>ほとんどのプログラミング言語は、データに <strong>型</strong> を持ちます。 ここでいうデータというのは、<code>&quot;Hello, &quot;</code>とか<code>123</code>とかのことで、型というのは<code>string</code>, <code>int</code>のことです。 もしデータに型がなければどうなるでしょうか？ コンピュータは<code>0, 1</code>で全てを表しているといいますが、<code>123</code>も<code>&quot;Hello, &quot;</code>も<code>0</code>と<code>1</code>で表されてしまいますから、文字なのか数値なのかよくかわらなくなってしまいます。 そのようなことを避けるために、数値には<code>int</code>, 文字列には<code>string</code>と型を付けるのです。 そして、<code>writeln</code>はどんな型が入力に入っているかを確認できるので、それぞれの型に合わせて出力のフォーマットを変えてくれます。</p>
<h2 id="関数について"><a href="#関数について">関数について</a></h2>
<p>型についてちょっとはわかったと思うので、次は <strong>関数</strong> について少し理解しましょう。 プログラムは関数とデータの集合だと考えることができます。 「関数にデータを渡して、関数がデータを処理してなにか値を返す」というのがプログラムの流れです。 <strong>関数中では、原則上から順番に文が実行されていきます</strong> 。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    write(<span class="st">&quot;Hello, &quot;</span>);
    write(<span class="st">&quot;World! &quot;</span>);
    writeln(<span class="dv">123</span>);
}</code></pre>
<p>上のコードを実行しても、一つ前のものと同じ表示になります。 もし、関数内の実行手順が上から下でないなら、ぐちゃくちゃになっているはずです。</p>
<p><code>main</code>関数以外の関数を定義して呼び出すことも可能です。 以下のコードでは何もしない関数<code>foo</code>を定義して<code>main</code>関数から呼び出しています。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    foo();
}


<span class="dt">void</span> foo(){}</code></pre>
<p><code>foo</code>の位置は重要でなくて、たとえば<code>main</code>関数の上に書いても大丈夫です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> foo(){}

<span class="dt">void</span> main()
{
    foo();
}</code></pre>
<p><code>foo</code>を2回呼び出すことも可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> foo(){}

<span class="dt">void</span> main()
{
    foo();
    foo();
}</code></pre>
<h2 id="writef-writefln"><a href="#writef-writefln">writef, writefln</a></h2>
<p>C言語を勉強した人は、一度は<code>printf</code>を使ったことがありますね。 D言語にも<code>printf</code>のようにフォーマットを指定して数値などを出力できる<code>writef, writefln</code>があります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writefln(<span class="st">&quot;%d : %d&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>);
    writefln(<span class="st">&quot;%s : %s&quot;</span>, <span class="dv">2</span>, <span class="dv">4</span>);
}</code></pre>
<pre><code>$ rdmd helloworld.d
1 : 2
2 : 4</code></pre>
<p>一番最初の<code>%d</code>と書いた部分に<code>1</code>が入り、次の<code>%d</code>には<code>2</code>が入っていることが実行結果からわかりますね。 次の行では2つの<code>%s</code>にそれぞれ<code>2</code>, <code>4</code>が入っています。 <code>%d</code>や<code>%s</code>はフォーマット指定子といい、<code>%d</code>は10進数出力を表します。 <code>%s</code>はデフォルトの指定子で、この場合は<code>%d</code>に等しくなります。</p>
<p>もし数値を16進数で出力したい場合には<code>%x</code>, <code>%X</code>を使います。 <code>%x</code>は小文字、<code>%X</code>は大文字で出力します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writefln(<span class="st">&quot;%x : %X&quot;</span>, <span class="dv">200</span>, <span class="dv">200</span>);
}</code></pre>
<pre><code>$ rdmd helloworld.d
c8 : C8</code></pre>
<p>もし、文字列を出力したいなら<code>%s</code>を使います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writefln(<span class="st">&quot;%s&quot;</span>, <span class="st">&quot;これは文字列&quot;</span>);
}</code></pre>
<pre><code>$ rdmd helloworld.d
これは文字列</code></pre>
<p><code>%d</code>や<code>%x</code>で文字列を出力しようとした場合にはエラーが出ます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writefln(<span class="st">&quot;%d&quot;</span>, <span class="st">&quot;これは文字列&quot;</span>);
}</code></pre>
<pre><code>$ rdmd helloworld.d
object.Exception@C:\D\dmd2\src\phobos\std\format.d(2154): Incorrect format specifier for range: %d
----------------
0x00416574
0x004163FF
0x0040466A
0x00404206
0x0040416F
0x004029C1
0x004025F8
0x0040256A
0x00412078
0x0040E329
0x0040B3C0
0x75A833AA in BaseThreadInitThunk
0x77DD9EF2 in RtlInitializeExceptionChain
0x77DD9EC5 in RtlInitializeExceptionChain</code></pre>
<p>指定子がわからなかった場合には<code>%s</code>としておけば最適なフォーマットで出力されるので便利ですね。</p>
<h2 id="コメント"><a href="#コメント">コメント</a></h2>
<p>たとえば、あなたが高度な技術を使用した複雑なプログラムを書いたとしましょう。 そのプログラムにバグがあることが、1週間後に判明しました。 さて、あなたはプログラムのバグを取り払うことができるでしょうか？</p>
<p>このような状況にされされた場合、ソースコードを読み解く必要があるのですが、コメントを残しておくことでソースコードの可読性が向上します。 たとえば、「ここではhogehogeをfugafugaしている」などです。 よいコメントを書けるプログラマはよいプログラマになれます(たぶん)。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">//std.stdioを読み込む</span>
<span class="kw">import</span> stds.stdio;

<span class="co">/** main関数</span>
<span class="co"> * Hello, World!と出力</span>
<span class="co"> */</span>
<span class="dt">void</span> main()
{
    <span class="co">/+</span>
<span class="co">    writeln(&quot;fugafuga&quot;);</span>
<span class="co">        /+</span>
<span class="co">        writeln(&quot;なんだと…&quot;);</span>
<span class="co">        +/</span>
<span class="co">    writeln(&quot;hogehoge&quot;);</span>
<span class="co">    +/</span>

    writeln(<span class="st">&quot;Hello, World!&quot;</span>);
}


<span class="co">/* ネストできないコメント</span>
<span class="co">ここはコメント</span>
<span class="co">    /*</span>
<span class="co">    ここはコメント</span>
<span class="co">    */</span>
ここはコメントでない
*/

<span class="co">/+ ネストできるコメント</span>
<span class="co">ここはコメント</span>
<span class="co">    /+</span>
<span class="co">    ここはコメント</span>
<span class="co">    +/</span>
<span class="co">ここはコメント</span>
<span class="co">+/</span>

<span class="co">/** ドキュメント</span>
<span class="co">*/</span>

<span class="co">/++ ネスト可能なドキュメント</span>
<span class="co">+/</span>

<span class="co">// １行コメント</span></code></pre>
<h2 id="問題---解答"><a href="#問題---解答">問題 -&gt; <a href="answer.md#hello_world">解答</a></a></h2>
<ul>
<li>次のソースコードの<code>&lt;a&gt;</code>と<code>&lt;b&gt;</code>の部分に適切なものを入れて、<code>Hello, World!</code>と表示するプログラムを作ってください。</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;%s, %s&quot;</span>, &lt;a&gt;, &lt;b&gt;);
}</code></pre>
<ul>
<li>次のソースコードは複数箇所間違っています。コンパイルしてエラーを確認しながら、訂正してください。</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d">vood main{
    writeln(<span class="st">&quot;Hello, World&quot;</span>);
}</code></pre>
<ul>
<li>つぎのソースコードをコンパイルして、エラーメッセージを読んでみましょう。プログラミングではエラーメッセージに慣れることが上達するための近道です。</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main(){
    writeln(<span class="st">&quot;foo&quot;</span>);
}</code></pre>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main(){
    writeln(<span class="st">&quot;foo&quot;</span>);</code></pre>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main{}</code></pre>
<pre class="sourceCode d"><code class="sourceCode d">main()</code></pre>
<pre class="sourceCode d"><code class="sourceCode d">main</code></pre>
<h2 id="おわりに"><a href="#おわりに">おわりに</a></h2>
<p>さて、第一回目の「Hello, World!」の項が終わりました。お疲れ様でした。 実は今回はかなり内容が詰まっていて、書いてる途中から、「初心者にはつらいかなあ」と思っていました。 プログラムの概念を考えると、今のノイマン型コンピュータを考えるところまで行き着いてしまい、D言語の話になかなか戻ってこれないので、このようなちょっと難しい形式になってしまいました。 このような難しいお話については、C言語の入門書の頭のほうにわかりやすく書かれていることが多いので、図書館へ行って借りることをオススメします。 また、D言語について詳しく知りたいと思った方は、「プログラミング言語D」(The D Programming Language; 略称:TDPL)という本をおすすめします。D言語の文法やそれに至った経緯など、詳しく学ぶにはとっておきです。 ただ、プログラミング初心者向けではなく、ある程度プログラムの知識がないと難しい内容の本です。</p>
<h2 id="キーワード"><a href="#キーワード">キーワード</a></h2>
<ul>
<li><code>dmd</code></li>
<li><code>import</code></li>
<li><code>std.stdio</code></li>
<li><code>main</code></li>
<li>関数(<code>function</code>)</li>
<li><code>write</code>, <code>writeln</code>, <code>writef</code>, <code>writefln</code></li>
<li>型(<code>type</code>)</li>
<li>値(<code>value</code>)</li>
<li>数値(integer, <code>int</code>型)</li>
<li>文字列(<code>string</code>型)</li>
<li>フォーマット</li>
<li>コメント</li>
</ul>
<h1 id="変数と型"><a href="#変数と型">変数と型</a></h1>
<h2 id="式expressionと文statementとは"><a href="#式expressionと文statementとは">式(Expression)と文(Statement)とは？</a></h2>
<p>D言語のプログラムが関数とデータの集合であることは前の章で説明しましたね。 では、関数は何で構成されているのでしょうか。 その答えは文(statement)です。 <code>void main(){}</code>というのも実際には宣言文(Declaration Statement)ですし、<code>import std.stdio;</code>もインポート宣言(Import Declaration)という文です。 さらに、<code>writeln(&quot;Hello, World!&quot;);</code>も文です。 ということで、D言語のプログラムは文の集合だったりします また、文は文で構成されたり、式(expression)で構成されます。 たとえば、<code>writeln(&quot;Hello, World!&quot;)</code>は式ですが、<code>;</code>を付けることで<code>writeln(&quot;Hello, World!&quot;);</code>となり文となります。 <code>&quot;Hello, World!&quot;</code>も式ですし、<code>123</code>も式です。</p>
<h2 id="変数variable"><a href="#変数variable">変数(Variable)</a></h2>
<p>電卓にはメモリー機能というのがありますね。 使ったことがないなら、これからは使ってみることをオススメします、便利ですよ。 さて、プログラムでもメモリー機能が使えます。 それが変数です。 式の値は変数に格納しておくことができます。 また、変数は電卓のメモリ機能と違い、宣言しないと使えませんが、たくさん使用することが可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">///src.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> + <span class="dv">2</span>;
    writeln(a);

    a = <span class="dv">3</span> + <span class="dv">1</span>;
    writeln(a);

    a = a + <span class="dv">2</span>;
    writeln(a);
}</code></pre>
<pre><code>$ rdmd src.d
3
4
6</code></pre>
<p>変数は宣言した場所以降から有効になります。 例では、<code>int a = 1 + 2;</code>というのが変数の宣言の部分で、<code>int</code>型の変数<code>a</code>を宣言しています。 次の行の<code>writeln(a);</code>では<code>a</code>の値である<code>3</code>を表示します。 また、<code>a</code>は宣言したあとは自由に書き換えられます。 <code>=</code>は代入演算子で、右辺(rhs)の値を左辺(lhs)にセットします。 3つめの<code>a = a + 2;</code>は奇妙かもしれませんが、<code>a + 2</code>が6ですから<code>a = 6;</code>と同じです。</p>
<h3 id="変数の宣言declaration"><a href="#変数の宣言declaration">変数の宣言(Declaration)</a></h3>
<p>変数の宣言は<code>Type identifier;</code>、もしくは初期化する場合は<code>Type identifier = initializer;</code>となります。 また、一度に複数宣言することもできて、<code>T a, b, c;</code>と書いたり、初期化したい場合には、</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">12</span>,
    b = a + <span class="dv">1</span>,
    c = a + b,
    d;</code></pre>
<p>という風にも書けます。</p>
<p>初期化の話が出ましたが、D言語では変数は宣言されたら自動的に初期化されます。 この初期化される値をデフォルト初期化値(デフォルト値, デフォルト初期化子; Default Initializer)といいます(後述)。</p>
<h3 id="変数の寿命とスコープ"><a href="#変数の寿命とスコープ">変数の寿命とスコープ</a></h3>
<p>変数には寿命があり、そのスコープ内でのみ有効です。 ここでいうスコープとは、静的スコープ(Static Scope)や構文スコープ(Lexical Scope)と呼ばれるもののことです。 簡単にいうと、<code>{</code>から、それに対応する<code>}</code>までがスコープになります。 特に、最も外のスコープであるスコープはグローバルスコープ(Global Scope)と呼ばれます。</p>
<p>スコープは<code>{}</code>などによってネスト(nest; 入れ子状態のこと)されます。 宣言された変数などをシンボル(Symbol)と呼びますが、外側のスコープから内側のスコープのシンボルを覗くことはできません。 しかし、内側のスコープから外側のスコープのシンボルを覗くことは可能です。 ですので、外側のスコープで宣言されたシンボルと同じ名称のシンボルを内側のスコープで宣言できません。</p>
<p>例外は2つあり、1つ目は、グローバルなシンボルと同じ名称のシンボルを、より内側のスコープで宣言することは可能です。 この場合、<code>.&lt;symbol&gt;</code>というように書くことで、グローバルなシンボルを指すことができます。</p>
<p>2つ目はまだ説明していない内容も含まれるので今回は無視していただいても構いません。 未説明なことを承知で言うと、ユーザー定義型のスコープではグローバルでない外側のシンボルを上書きできます。 こちらのケースでは、上書きされた外側のシンボルにアクセスできなくなります。 (全てのパターンで完全に消えるわけではありません。あくまでも、<code>&lt;symbol&gt;</code>の形式でアクセスできなくなるということです。)</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="co">// ここはグローバルスコープ</span>

<span class="dt">int</span> a = <span class="dv">0</span>;

<span class="dt">void</span> main()
{
    <span class="co">// ここはmain関数のスコープ</span>

    <span class="dt">double</span> a = <span class="dv">1</span>;       <span class="co">// グローバルなシンボルを上書きすることは可能</span>

    writeln(a);         <span class="co">// 1; このスコープのa</span>
    writeln(.a);        <span class="co">// 0; グローバルなa</span>

    {
        <span class="co">//ここはmainより1つ内側のスコープ</span>

        <span class="co">//string a;     // グローバルでないシンボルを上書きすることはできない</span>
        <span class="dt">string</span> b = <span class="st">&quot;foo&quot;</span>;

        writeln(a);     <span class="co">// 1</span>
        writeln(.a);    <span class="co">// 0</span>
        writeln(b);     <span class="co">// foo</span>

        <span class="co">// string型のbの寿命はここまで</span>
    }

    {
        <span class="co">//writeln(b);   // このスコープから、上のスコープのbを見ることはできない</span>
    }

    <span class="co">//writeln(b);       // 外側のスコープから、内側のbは見れない</span>
    <span class="dt">uint</span> b;             <span class="co">// 内側のbは見えないから、bをシンボルとして定義してもよい</span>

    foo();              <span class="co">// グローバルスコープにあるシンボルは、ソースコードで下にあっても使える</span>
    writeln(bar);       <span class="co">// 同上</span>

    <span class="co">// double型のaやuint型のbの寿命はここまで</span>
}


<span class="dt">int</span> bar = <span class="dv">12</span>;


<span class="dt">void</span> foo()
{
    <span class="co">//writeln(b);       // 0; main関数のuint型のbも、string型のbも見えない</span>
}</code></pre>
<h3 id="左辺値lvalueと右辺値rvalue"><a href="#左辺値lvalueと右辺値rvalue">左辺値(lvalue)と右辺値(rvalue)</a></h3>
<p>次のプログラムがおかしいことはすぐにわかると思います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a;

a = <span class="dv">12</span>;         <span class="co">// OK</span>

(a + <span class="dv">3</span>) = <span class="dv">4</span>;    <span class="co">// NG</span></code></pre>
<p>変数である<code>a</code>には代入できるのに、<code>(a + 3)</code>には代入できません。 というのも、変数の評価結果は左辺値(lvalue; left value)となるからです。 左辺値というのは、「<code>=</code>の左側に置ける値」という意味で理解しても構いません。</p>
<p>逆に、<code>(a + 3)</code>は右辺値(rvalue)といい、<code>=</code>の左側には置くことができません。</p>
<p>(左辺値であったとしても代入できるとは限りません。<code>const</code>や<code>immutable</code>で型修飾されていれば代入は不可能です)</p>
<h2 id="いろいろな型type"><a href="#いろいろな型type">いろいろな型(Type)</a></h2>
<p>D言語のデータには型があることも前の記事で書きましたが、ここではどんな型があるかを紹介します。 また、リテラルやデフォルト初期化値についても言及します。 文字型や文字列型は難しい内容が含まれているので、わからなければ読み飛ばしてもらって構いません。</p>
<h3 id="リテラルliteralとシンボルsymbol"><a href="#リテラルliteralとシンボルsymbol">リテラル(Literal)とシンボル(Symbol)</a></h3>
<p>リテラルとは、ソースコードに直接、値を記したもののことです。 プログラムが動いている間、変数は書き換えられるのに対して、リテラルはソースコードを編集しないと変更できません。 たとえば<code>int a = 1;</code>での<code>1</code>はリテラルです。</p>
<p>逆に、<code>int a = 1;</code>での<code>a</code>はシンボルと呼ばれます。</p>
<h3 id="デフォルト初期化値default-initializer-type.init"><a href="#デフォルト初期化値default-initializer-type.init">デフォルト初期化値(Default Initializer; Type.init)</a></h3>
<p>D言語の変数は宣言した際に初期化されます。 その際の値をデフォルト初期化値といいます。 この初期化をしてほしくない場合には、<code>Type iden = void;</code>というように<code>= void</code>とします。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a;
writeln(a);         <span class="co">// 0; intのデフォルト初期化値は 0</span>

writeln(<span class="dt">int</span>.<span class="dt">init</span>);  <span class="co">// Type.init でデフォルト初期化値を取得できる</span>

<span class="dt">int</span> b = <span class="dt">void</span>;       <span class="co">// 初期化を阻止</span>
writeln(b);         <span class="co">// 何が表示されるかわからない</span></code></pre>
<h3 id="void"><a href="#void">void</a></h3>
<pre><code>* void      : 値(または型)なし。</code></pre>
<p>値がない、もしくは型がないときに<code>void</code>と書きます。 前の記事でのmain関数では、<code>void main()</code>と書いていましたが、そこではmain関数の返り値が無いことを意味しています。</p>
<p>(厳密には、<code>void main()</code>は、プログラムが成功し正常に終了すれば<code>0</code>を返しますが、これについてはmain関数の項で説明します。)</p>
<h3 id="論理型boolean"><a href="#論理型boolean">論理型(Boolean)</a></h3>
<pre><code>* bool      : 真偽値(`true`, `false`)</code></pre>
<p>真か偽かを判別するための型です。 デフォルト初期化値は<code>false</code>です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">bool</span> b;

writeln(b); <span class="co">// false</span>
b = !b;
writeln(b); <span class="co">// true</span>

b = <span class="kw">true</span>;
writeln(b); <span class="co">// true</span>

b = <span class="kw">false</span>;
writeln(b); <span class="co">// false</span></code></pre>
<h3 id="整数型decimal-number"><a href="#整数型decimal-number">整数型(Decimal Number)</a></h3>
<pre><code>* byte      :  8bitの符号あり(signed)な整数
* ubyte     :  8bitの符号なし(unsigned)な整数
* short     : 16bitの符号あり整数
* ushort    : 16bitの符号なし整数
* int       : 32bitの符号あり整数
* uint      : 32bitの符号なし整数
* long      : 64bitの符号あり整数
* ulong     : 64bitの符号なし整数
* cent      : 128bitの符号あり整数(将来のために名前だけ付けられてる)
* ucent     : 128bitの符号なし整数(将来のために名前だけ付けられてる)

* size_t    : ポインタ値が十分に入る大きさの符号なし整数型
              32bit環境だと32bit(uint), 64bit環境だと64bit(ulong)

* ptrdiff_t : size_tと同じ大きさの符号あり整数型</code></pre>
<p>整数型には、8bitから倍々に64bitまであります(128bit型は今は使えない)。 符号あり整数型の前に<code>'u'</code>をつけると符号なし整数型になります。</p>
<p>また、<code>size_t</code>や<code>ptrdiff_t</code>という変わり種の整数型もあります。 整数型は、どれも<code>0</code>で初期化され、算術演算やビット演算が可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a;

writeln(a);             <span class="co">// 0</span>

<span class="dt">ulong</span> b = -<span class="dv">1</span>;

writeln(b);             <span class="co">// 18446744073709551615</span>
                        <span class="co">// -1 は int型 だが、int -&gt; long -&gt; ulongと暗黙に変換される。</span>
                        <span class="co">// longからulongへの変換によってこのようになる。</span>

writeln(<span class="dv">1uL</span> - <span class="dv">2uL</span>);     <span class="co">// 18446744073709551615</span>
                        <span class="co">// 1uL は ulong型の1なので、</span>
                        <span class="co">// 上のbと同様に負の数を表せず、このようになる。</span>

writeln(<span class="dv">1u</span>);            <span class="co">// 数値の後ろに u とつけると uint型</span>
writeln(<span class="dv">1U</span>);            <span class="co">// 大文字で U とつけても同じ</span>

writeln(<span class="dv">1L</span>);            <span class="co">// 大文字の L をつければ long型</span>

writeln(<span class="dv">1uL</span>);           <span class="co">// uL や、UL は ulong型</span></code></pre>
<h3 id="浮動小数点型floating-point-number"><a href="#浮動小数点型floating-point-number">浮動小数点型(Floating-Point Number)</a></h3>
<pre><code>()の中の3つの数字は、(符号部bit数, 指数部bit数, 仮数部bit数)
* float     : 32bitの浮動小数点の実数(1, 8, 23)
* double    : 64bitの浮動小数点の実数(1, 11, 52)
* real      : 64bit以上(システムによって違う)の浮動小数点の実数</code></pre>
<p>浮動小数点とは、コンピュータで実数値を表す方式のことです。 演算によって小数点が動くのでこのような名前になっています。 D言語の浮動小数点数はIEEE 754という規格に沿っています。 この型は、<code>float</code>なら<code>float.nan</code>, <code>double</code>なら<code>double.nan</code>, <code>real</code>なら<code>real.nan</code>で初期化されます。</p>
<p>なお、real型については64bit以上という言語仕様ですが、これは最低限保証するビット数であり、例えばIntelのCPUでは79bitの精度となっています。 (x87の拡張浮動小数点数では80bit(1, 15, 64)であるものの、IEEE 754では表されない整数部の1bitを無駄に使用しているため、精度で言えば79bit(1, 15, 63)相当となります)</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">float</span>  f = <span class="fl">1.0f</span>;        <span class="co">// 数値の後に f をつければ float型</span>
<span class="dt">double</span> d = <span class="fl">1.0</span>;         <span class="co">// 少数点のある数値は double型</span>
<span class="dt">real</span>   r = <span class="fl">1.0L</span>;        <span class="co">// 少数点があり、最後に L が付いていると real型</span>

writeln(f / <span class="dv">0</span>);         <span class="co">// inf</span>
writeln(<span class="fl">0.0</span> / <span class="fl">0.0</span>);     <span class="co">// -nan</span></code></pre>
<h3 id="虚数浮動小数点型imaginary-floating-point-number"><a href="#虚数浮動小数点型imaginary-floating-point-number">虚数浮動小数点型(Imaginary Floating-Point Number)</a></h3>
<pre><code>* ifloat    : 32bitの浮動小数点の虚数
* idouble   : 64bitの浮動小数点の虚数
* ireal     : 64bit以上(システムによって違う)の浮動小数点の虚数</code></pre>
<p>プログラミング言語では珍しい、虚数を表す型です。 それぞれ、<code>ifloat</code>なら<code>float.nan * 1.0i</code>というように初期化されます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">ifloat</span> f = <span class="fl">1.0fi</span>;       <span class="co">//  i を末尾につければ虚数型</span></code></pre>
<h3 id="複素浮動小数点型complex-floating-point-number"><a href="#複素浮動小数点型complex-floating-point-number">複素浮動小数点型(Complex Floating-Point Number)</a></h3>
<pre><code>* cfloat    : 32bitの浮動小数点の複素数, 64bit
* cdouble   : 64bitの浮動小数点の複素数, 128bit
* creal     : 64bit以上(システムによって違う)の浮動小数点の複素数(64bit以上 * 2の大きさ)</code></pre>
<p>実部と虚部を持つ型です。これもプログラミング言語では珍しいです。 それぞれ、<code>cfloat</code>なら<code>float.nan + float.nan * 1.0i</code>という値で初期化されます。</p>
<h3 id="文字型charactor"><a href="#文字型charactor">文字型(Charactor)</a></h3>
<pre><code>* char      : UTF-8でエンコードされた文字(8bit)
* wchar     : UTF-16でエンコードされた文字(16bit)
* dchar     : UTF-32でエンコードされた文字(32bit)</code></pre>
<p>D言語で文字型を使用すると、その文字はUTF-8かUTF-16, UTF-32でエンコードされていると認識されます。 もし、Unicode以外でエンコーディングされた文字を格納する場合には、<code>ubyte</code>や<code>ushort</code>, <code>uint</code>を使用するべきです(邦訳TDPL 118ページ参照)。 また、デフォルト初期化値はそれぞれ、<code>0xFF</code>, <code>0xFFFF</code>, <code>0x0000FFFF</code>です。</p>
<h3 id="文字列型string"><a href="#文字列型string">文字列型(String)</a></h3>
<pre><code>* string    : 文字列型(immutable(char)[])
* wstring   : 文字列型(immutable(wchar)[])
* dstring   : 文字列型(immutable(dchar)[])</code></pre>
<p>こちらも文字型を同じようにUTF-8, UTF-16, UTF-32でエンコードされていると仮定されます。 ですから、Unicode以外でエンコーディングされた文字列を格納するなら、<code>ubyte[]</code>や<code>immutable(ubyte)[]</code>, <code>ushort[]</code>, <code>immutable(ushort)[]</code>, <code>uint[]</code>, <code>immutable(uint)[]</code>を使用するべきなのです。 (例えば <code>std.encoding</code> モジュールでは、ASCIIコードの文字列を表現するのに <code>immutable(ubyte)[]</code> が使用されています)</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">//import std.utf;       追加でこの2つをimportする</span>
<span class="co">//import std.range;</span>

<span class="dt">string</span>  utf8  = <span class="st">&quot;ほげほげ&quot;</span>;
<span class="dt">wstring</span> utf16 = <span class="st">&quot;ほげほげ&quot;w</span>;
<span class="dt">dstring</span> utf32 = <span class="st">&quot;ほげほげ&quot;d</span>;

writeln(utf8);                                  <span class="co">// ほげほげ</span>
writeln(utf16);                                 <span class="co">// ほげほげ</span>
writeln(utf32);                                 <span class="co">// ほげほげ</span>

writeln( utf8[std.utf.stride( utf8, <span class="dv">0</span>) .. $]);  <span class="co">// げほげ</span>
writeln(utf16[std.utf.stride(utf16, <span class="dv">0</span>) .. $]);  <span class="co">// げほげ</span>
writeln(utf32[<span class="dv">1</span> .. $]);                         <span class="co">// げほげ</span>

writeln(std.range.drop( utf8, <span class="dv">2</span>));              <span class="co">// ほげ</span>
writeln(std.range.drop(utf16, <span class="dv">2</span>));              <span class="co">// ほげ</span>
writeln(std.range.drop(utf32, <span class="dv">2</span>));              <span class="co">// ほげ</span></code></pre>
<h3 id="派生型derived-data-type"><a href="#派生型derived-data-type">派生型(Derived Data Type)</a></h3>
<pre><code>* T*        : T型に対するポインタ型(Pointer)
* T[]       : T型を要素とするスライス(Slice)(動的配列; Dynamic Array)
* T[N]      : T型を連続してN要素集めた型。静的配列(Static Array)
* V[K]      : K型の値に対してV型の値が1:1で対応する型。連想配列(Associative Array)
* R function(T...)
            : T...型を受け取ってR型の値を返す関数ポインタ型
* R delegate(T...)
            : T...型を受け取ってR型の値を返すデリゲート(委譲)型</code></pre>
<p>これらの型については後ほど個々に詳しく書きます。</p>
<h3 id="ユーザー定義型user-defined-type"><a href="#ユーザー定義型user-defined-type">ユーザー定義型(User Defined Type)</a></h3>
<pre><code>* enum      : 列挙型
* struct    : 構造体
* union     : 共用体
* class     : クラス
* interface : インターフェース</code></pre>
<p>ユーザー(プログラマ)が、いろいろな型を組み合わせて新しい型を作るための型です。 これらについては各々独立した記事を書きます。</p>
<h2 id="型修飾子type-qualifiers"><a href="#型修飾子type-qualifiers">型修飾子(Type Qualifiers)</a></h2>
<p>型に修飾子を付けることによって、様々な情報を型に付加させることができます。</p>
<h3 id="const"><a href="#const">const</a></h3>
<p><code>const</code>で修飾された型の値は、その参照経由では変更不可能です。 <code>const</code>は推移的であり、修飾された型を構成する型も<code>const</code>型になります。 あくまでも「<code>const</code>な参照経由では変更不可能」なだけなので、ある程度の型であれば<code>const</code>型以外へも暗黙変換可能です。</p>
<p>ここでいう「ある程度の型」とは、値型である<code>int</code>や<code>ulong</code>, 参照を持つがその参照経由で変更ができない<code>const(T)*</code>, <code>immutable(T)*</code>などです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a;
<span class="kw">const</span>(<span class="dt">int</span>*) p = &amp;a;     <span class="co">// すべての型はconstに暗黙変換可能</span>

<span class="co">//*p += 3;              // Error: cannot modify const expression *p</span>
                        <span class="co">// constは推移的なので、*pはconst(int)型</span>
                        <span class="co">// constなデータは書き換え不可なのでエラーがでる</span>

<span class="dt">int</span>* q = &amp;a;            <span class="co">// constでないポインタ</span>
*q = <span class="dv">13</span>;                <span class="co">// 書き換え可能</span>

p = q;                  <span class="co">// 非const型からconst型へは暗黙変換可能</span>
<span class="co">//q = p;                // 逆は不可能</span></code></pre>
<h3 id="immutable"><a href="#immutable">immutable</a></h3>
<p><code>immutable</code>型は、生まれたら死ぬまで絶対に書き換わらない型で、<code>const</code>同様に推移的です。 <code>const</code>へ暗黙変換可能ですが、非<code>immutable</code>かつ非<code>const</code>型以外へは暗黙変換不可能です。 また<code>const</code>型と同様に、値型である<code>int</code>や<code>ulong</code>, 参照を持つが<code>immutable</code>への参照である<code>immutable(T)*</code>などは<code>immutable</code>型へ暗黙変換可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a;
<span class="co">//immutable(int)* p = &amp;a;   //Error: cannot implicitly convert expression (&amp; a) of type int* to immutable(int)*</span>
                            <span class="co">// &amp;aはint*なのでimmutable型へは暗黙変換不可</span>

<span class="kw">immutable</span>(<span class="dt">int</span>) b;

<span class="kw">immutable</span>(<span class="dt">int</span>*) p = &amp;b;     <span class="co">// OK</span>
                            <span class="co">// immutable(int)*からimmutable(int*)への暗黙変換は可能</span>

<span class="kw">immutable</span>(<span class="dt">int</span>)* r = &amp;b;
<span class="co">//*r += 3;                  // Error: cannot modify immutable expression *r</span>
                            <span class="co">// immutable型は変更不可能</span></code></pre>
<p><code>immutable</code>も<code>const</code>も推移的なので、<code>immutable(const(int)*)</code>は<code>immutable(int*)</code>に等価です。例を示しておきましょう。</p>
<pre><code>immutable(immutable(T))     -&gt;      immutable(T)
immutable(const(T))         -&gt;      immutable(T)
const(immutable(T))         -&gt;      immutable(T)
const(const(T))             -&gt;      const(T)

immutable(immutable(T)*)    -&gt;      immutable(T*)
immutable(const(T)*)        -&gt;      immutable(T*)
const(immutable(T)*)        -&gt;      変化しない
const(const(T)*)            -&gt;      const(T*)</code></pre>
<h3 id="shared"><a href="#shared">shared</a></h3>
<p>shared型は、複数のスレッドからアクセスされるために、知らぬ間に書き換わっているかもしれない型であることを表します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a;

<span class="co">//shared(int)* p = &amp;a;      // Error: cannot implicitly convert expression (&amp; a) of type int* to shared(int)*</span>
shared(<span class="dt">int</span>)* q = <span class="kw">cast</span>(shared)&amp;a;</code></pre>
<h2 id="記憶域クラスstorage-class"><a href="#記憶域クラスstorage-class">記憶域クラス(Storage Class)</a></h2>
<p>記憶域クラスとは、変数の特性を指定する修飾子のことです。</p>
<h3 id="const-1"><a href="#const-1">const</a></h3>
<p><code>const(Type)</code>型と等しくなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">const</span> <span class="dt">int</span> a = <span class="dv">12</span>;       <span class="co">// const(int) a = 12;と書くのと等しい</span></code></pre>
<h3 id="immutable-1"><a href="#immutable-1">immutable</a></h3>
<p><code>immutable(Type)</code>型と等しくなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">immutable</span> <span class="dt">int</span> a = <span class="dv">12</span>;   <span class="co">// immutable(int) a = 12;と等しい</span></code></pre>
<h3 id="shared-1"><a href="#shared-1">shared</a></h3>
<p><code>shared(Type)</code>型と等しくなります。</p>
<pre class="sourceCode d"><code class="sourceCode d">shared <span class="dt">int</span> a = <span class="dv">12</span>;</code></pre>
<h3 id="scope"><a href="#scope">scope</a></h3>
<p><code>scope</code>の意味は、その参照がスコープの外に置かれることがないということです。 つまり、グローバル変数への代入や<code>return</code>を使って関数外へ送ることは不正です。</p>
<p>またその仕様から、<code>scope</code>変数を<code>new</code>を用いてクラスのインスタンスで初期化していれば、そのインスタンスはスコープを抜ける際に破棄されるという仕様もありますが、この機能は後ほど非推奨な機能となりますので、クラスの場合には<code>std.typecons.scoped</code>を使いましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">class</span> Foo{ <span class="kw">this</span>(){}; }

<span class="kw">scope</span> foo = <span class="kw">new</span> Foo();  <span class="co">// スタックへ割り当てられる</span>
                        <span class="co">// スコープを抜けると同時に破棄される</span>

<span class="co">// クラスに対するscopeは、そのうち「非推奨な機能」となるためstd.typecons.Scopedを使うとよい</span>
<span class="kw">import</span> std.typecons;
<span class="kw">auto</span> bar = scoped!Foo();</code></pre>
<h3 id="関数でのみ有効となる記憶域クラス"><a href="#関数でのみ有効となる記憶域クラス">関数でのみ有効となる記憶域クラス</a></h3>
<p>その他にも記憶域クラスはありますが、関数引数や関数そのものに対してのみ有効であるので、随時説明していきます。 以下に、そのような記憶域クラスのリストを挙げておきます。</p>
<ul>
<li><code>in</code></li>
<li><code>out</code></li>
<li><code>ref</code></li>
<li><code>lazy</code></li>
<li><code>inout</code></li>
</ul>
<h2 id="型推論type-inference"><a href="#型推論type-inference">型推論(Type Inference)</a></h2>
<p>たとえば、<code>int a = 12;</code>という記述は冗長的だと思いませんか？ <code>12</code>は<code>int</code>型のリテラルなのに、<code>int a</code>とちゃんと型を宣言する必要があるでしょうか？</p>
<p>そのようなことから、D言語ではいろいろな部分で型推論なされます。 型推論とは、明示的に型宣言しなくても、その値が生成される式の型から自動的に型を決定する機能です。</p>
<p>もし、初期化子があるのであれば、<code>int</code>の代わりに<code>auto</code>を使うことで、変数の型が(コンパイル時に)自動的に決定されます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> a = <span class="dv">12</span>;
<span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(a)); <span class="co">// int</span>

<span class="kw">auto</span> b = <span class="st">&quot;ほげほげ&quot;</span>;
<span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(b)); <span class="co">// string</span>

<span class="kw">auto</span> c = a + <span class="fl">13.5</span>;
<span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(c)); <span class="co">// double</span>

<span class="kw">const</span> d = <span class="dv">3</span>;
<span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(d)); <span class="co">// const(int)</span>

<span class="kw">immutable</span> e = <span class="dv">4</span>;        <span class="co">// 記憶域クラスのみでも型推論される</span>
<span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(e)); <span class="co">// immutable(int)</span></code></pre>
<h2 id="問題---解答-1"><a href="#問題---解答-1">問題 -&gt; <a href="answer.md#variable_type">解答</a></a></h2>
<ul>
<li><p>ビッグエンディアンとリトルエンディアンについて調べてみましょう。</p></li>
<li><p>次のソースコードをコンパイルして、エラーメッセージを読んでみましょう。</p></li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    intt a;         <span class="co">// intでないのに注意</span>
}</code></pre>
<ul>
<li>問題募集中</li>
</ul>
<h2 id="おわりに-1"><a href="#おわりに-1">おわりに</a></h2>
<p>お疲れ様です。 東進の先生の「基礎の基礎が怖いってことを、今日何度も言っておきます」という言葉がありますが、プログラミングは本当にその言葉に当てはまります。 今回と次回は「基礎の基礎」なので、退屈かもしれませんが確実に習得してもらいたい内容です。 しかし、たぶん無理なので、今回と次回の内容はいつでも見れるようにしておきましょう。 ちなみに、次回は「式と演算子」について書くと思います。</p>
<h2 id="キーワード-1"><a href="#キーワード-1">キーワード</a></h2>
<ul>
<li>式(Expression)</li>
<li>文(Statement)</li>
<li>宣言(Declaration)</li>
<li>変数(Variable)</li>
<li>スコープ(Scope)</li>
<li>シンボル(Symbol)</li>
<li>グローバルスコープ(Global Scope)</li>
<li>値(Value)</li>
<li>型(Type)</li>
<li>リテラル(Literal)</li>
<li>シンボル(Symbol)</li>
<li>デフォルト初期化値(デフォルト値, デフォルト初期化子; Default Initializer)</li>
<li>void</li>
<li>論理型(Boolean); <code>bool, true, false</code></li>
<li>整数型(Decimal Number); <code>byte, ubyte, short, ushort, int, uint, long, ulong, cent, ucent, size_t, ptrdiff_t</code></li>
<li>浮動小数点型(Floating-Point Number); <code>float, double, real</code></li>
<li>虚数浮動小数点型(Imaginary Floating Point); <code>ifloat, idouble, ireal</code></li>
<li>複素数浮動小数点型(Complex Floating-Point Number); <code>cfloat, cdouble, creal</code></li>
<li>文字型(Charactor); <code>char, wchar, dchar</code></li>
<li>文字列型(String); <code>string, wstring, dstring</code></li>
<li>派生型(Derived Data Type);</li>
<li>ユーザー定義型(User Defined Type); <code>enum, struct, union, class, interface</code></li>
<li>型修飾子(Type Qualifiers)</li>
<li>記憶域クラス(Storage Class)</li>
<li>型推論(Type Inference)</li>
</ul>
<h1 id="式と演算子"><a href="#式と演算子">式と演算子</a></h1>
<h2 id="式と演算子-1"><a href="#式と演算子-1">式と演算子</a></h2>
<p>ここからは式のお話をします。 式は、D言語での計算の一番小さな単位です。 たとえば、<code>1 + 2 + 3</code>は式ですが、この式に含まれる<code>1 + 2</code>, <code>1</code>, <code>2</code>, <code>3</code>も同様に式です。 <code>1</code>や<code>2</code>, <code>3</code>などはリテラル(Literal)と呼ばれると前回説明しましたね。 式は演算子などによって、より大きな式を作ります。</p>
<p>式は評価(Evaluation)されると値を持ちます。 たとえば<code>1</code>なら<code>int</code>型の<code>1</code>、<code>int a = 12;</code>として<code>a + 2</code>の式を評価すると<code>int</code>型の<code>14</code>という値になります。 <code>a + b</code>の<code>a</code>と<code>b</code>の評価は同時に行われるわけではなく、<code>a</code>が先に評価され、次に<code>b</code>が評価されます。 この評価順序は演算子によって異なりますが、2項演算子であれば左が優先されます。 ちなみに、この評価順序はそれほど重要ではありませんし、クリティカルな問題にもなりません。 2項演算子は左優先ということ以外、覚えている人や知っている人は私を含めてほぼ皆無であると思います。 (<code>a[b]</code>という演算子は、<code>b</code>を評価した後に<code>a</code>を評価します。関数呼び出しの<code>a(b)</code>は逆に<code>a</code>を評価して<code>b</code>を評価します。) (要出典, コンパイラの実装によっては異なっても良い？)</p>
<p>また、演算子にはそれぞれ結合規則が定められています。 たとえば、<code>1.0 / 2 / 5</code>は<code>(1.0 / 2) / 5</code>となって<code>double</code>型の<code>2.5</code>と評価されます。 もし、<code>1.0 / (2 / 5)</code>と解釈されるなら、<code>2 / 5</code>は整数である<code>int</code>型なので、<code>0</code>と評価され、結果的に<code>1.0 / 0</code>となります。 これが、評価されると<code>double.inf</code>という値になります。 つまり、演算子の結合の方向が右なのか左なのかによって式の値は異なるので、演算子ごとに結合の向きを定義しておく必要があります。</p>
<p>最後に、演算子には優先度という順位があります。 先に紹介した割り算の例では、式中に現れる演算子の優先順位がすべて同じであったため、結合規則に則って評価されました。 では、<code>1 + 4 / 2</code>という式があった場合にはどうすべきでしょうか？ 掛け算や割り算は、足し算や引き算よりも先に計算することを小学校の算数で勉強したと思います。 D言語でも(大体のプログラミング言語でも)同じ規則が成り立ちます。 この場合には、<code>1 + 4</code>よりも先に<code>4 / 2</code>が評価されて、<code>1 + 2</code>となり、最終的に<code>3</code>と評価されます。</p>
<p>プログラマはこれらの評価の順序を覚えているかというと、正確に把握できている人は少ないと思います。 ですから、<code>1 + 4 / 2</code>や<code>1.0 / 2 / 5</code>などという明らかな場合はいいのですが、複雑な場合には、カッコ<code>()</code>で式をくくりましょう。 数学と同じように、<code>()</code>でくくればその中の優先順位は最も高くなります。 <code>(1 + 4) / 2</code>なら曖昧性が一切ありません。 しかし、残念ながらソースコードでは、中括弧<code>{}</code>や大括弧<code>[]</code>は、このような目的で使えません。</p>
<h2 id="演算子と暗黙の数値型変換"><a href="#演算子と暗黙の数値型変換">演算子と暗黙の数値型変換</a></h2>
<p>数値型はたくさんありますが、それ故に異なる型との演算がよくあります。 この項では、たとえば<code>float + int</code>のような異なる数値型同士の演算の型について説明します。</p>
<p>数値型の演算子の規則は、簡単に言えば「大きい型や浮動小数点型に変換される可能性がある」です。 たとえば、<code>float + int</code>はどちらも<code>float + float</code>になって<code>float</code>になります。 以下に様々な例を示します。</p>
<p>writeTypeはよくわからないと思いますが、2つの型で2項演算してみた結果の型を出力する関数です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> writeType(T, <span class="dt">string</span> op, U)()
{
    writeln(<span class="dt">typeof</span>(<span class="kw">mixin</span>(<span class="st">&quot;T.init &quot;</span> ~ op ~ <span class="st">&quot; U.init&quot;</span>)).<span class="dt">stringof</span>);
}

<span class="dt">void</span> main()
{
    writeType!(   <span class="dt">byte</span>, <span class="st">&quot;+&quot;</span>,    <span class="dt">byte</span>)();    <span class="co">// int</span>
    writeType!(   <span class="dt">byte</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">ubyte</span>)();    <span class="co">// int</span>
    writeType!(  <span class="dt">ubyte</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">ubyte</span>)();    <span class="co">// int</span>

    writeln();

    writeType!(  <span class="dt">short</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">short</span>)();    <span class="co">// int</span>
    writeType!(  <span class="dt">short</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">ushort</span>)();    <span class="co">// int</span>
    writeType!( <span class="dt">ushort</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">ushort</span>)();    <span class="co">// int</span>

    writeln();

    writeType!(    <span class="dt">int</span>, <span class="st">&quot;+&quot;</span>,     <span class="dt">int</span>)();    <span class="co">//  int</span>
    writeType!(    <span class="dt">int</span>, <span class="st">&quot;+&quot;</span>,    <span class="dt">uint</span>)();    <span class="co">// uint</span>
    writeType!(   <span class="dt">uint</span>, <span class="st">&quot;+&quot;</span>,    <span class="dt">uint</span>)();    <span class="co">// uint</span>

    writeln();

    writeType!(   <span class="dt">long</span>, <span class="st">&quot;+&quot;</span>,    <span class="dt">long</span>)();    <span class="co">//  long</span>
    writeType!(   <span class="dt">long</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">ulong</span>)();    <span class="co">// ulong</span>
    writeType!(  <span class="dt">ulong</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">ulong</span>)();    <span class="co">// ulong</span>

    writeln();

    writeType!(    <span class="dt">int</span>, <span class="st">&quot;+&quot;</span>,    <span class="dt">long</span>)();    <span class="co">//  long</span>
    writeType!(    <span class="dt">int</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">ulong</span>)();    <span class="co">// ulong</span>
    writeType!(   <span class="dt">uint</span>, <span class="st">&quot;+&quot;</span>,    <span class="dt">long</span>)();    <span class="co">//  long</span>
    writeType!(   <span class="dt">uint</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">ulong</span>)();    <span class="co">// ulong</span>

    writeln();

    writeType!(  <span class="dt">float</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">float</span>)();    <span class="co">//  float</span>
    writeType!(  <span class="dt">float</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">ifloat</span>)();    <span class="co">// cfloat</span>
    writeType!( <span class="dt">ifloat</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">ifloat</span>)();    <span class="co">// ifloat</span>

    writeln();

    writeType!(   <span class="dt">real</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">float</span>)();    <span class="co">//  real</span>
    writeType!(   <span class="dt">real</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">ifloat</span>)();    <span class="co">// creal</span>
    writeType!(  <span class="dt">ireal</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">ifloat</span>)();    <span class="co">// ireal</span>

    writeln();

    writeType!(  <span class="dt">float</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">cfloat</span>)();    <span class="co">// cfloat</span>
    writeType!( <span class="dt">ifloat</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">cfloat</span>)();    <span class="co">// cfloat</span>
    writeType!( <span class="dt">cfloat</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">cfloat</span>)();    <span class="co">// cfloat</span>

    writeln();

    writeType!( <span class="dt">ifloat</span>, <span class="st">&quot;*&quot;</span>,  <span class="dt">ifloat</span>)();    <span class="co">// float</span>

    writeln();

    writeType!(   <span class="dt">long</span>, <span class="st">&quot;+&quot;</span>,   <span class="dt">float</span>)();    <span class="co">//  float</span>
    writeType!(   <span class="dt">long</span>, <span class="st">&quot;+&quot;</span>,  <span class="dt">ifloat</span>)();    <span class="co">// cfloat</span>
}</code></pre>
<p>例をよく見ると、<code>int</code>より小さな整数型では、全て<code>int</code>型になっています。 <code>int</code>型以上の大きさの整数型では、より大きな型になります。 もう少し<code>int</code>や<code>long</code>を詳しく見ると、頭に<code>&quot;u&quot;</code>がついた符号なし整数の方が強いことがわかります。</p>
<p>浮動小数点型では、実数型と実数型の和はもちろん実数型、実数型と虚数型の和は複素数型、虚数型同士の和は虚数型というように理に適っています。 また、複素数型に実数型や虚数型, 複素数型を足しても結果は複素数型です。 しかし、虚数型同士の積は実数型となり、数学で習ったことと一致すると思います。</p>
<p>整数型と浮動小数点型では、浮動小数点型のほうが強く、浮動小数点型になります。</p>
<p>以上のことを踏まえると、以下の様な規則に従っていることがわかります。</p>
<ul>
<li>規則1: 数値型の暗黙変換のルール</li>
</ul>
<ol type="1">
<li>整数型から、より大きいサイズの整数型へは暗黙変換可能</li>
<li>実数浮動小数点型から、任意の大きさの実数浮動小数点型に暗黙変換可能</li>
<li>虚数浮動小数点型から、任意の大きさの虚数浮動小数点型に暗黙変換可能</li>
<li>複素数浮動小数点型から、任意の大きさの複素数浮動小数点型に暗黙変換可能</li>
<li>任意の整数型は、任意の実数浮動小数点型に暗黙変換可能</li>
</ol>
<ul>
<li>規則2: 演算子について、以下の規則は番号の小さいものから適応される。</li>
</ul>
<ol type="1">
<li><p>どちらか片方が複素数型(浮動小数点型)である。<br /> そのうち最大の型にどちらの項も暗黙変換され、結果はその型となる。</p></li>
<li><p>どちらも虚数型(浮動小数点型)であり、積, 商の演算子である。<br /> そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの実数型となる。</p></li>
<li><p>どちらも虚数型(浮動小数点型)であり、和, 差の演算子である。<br /> そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの虚数型となる。</p></li>
<li><p>どちらか片方が虚数型(浮動小数点型)である。<br /> そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの複素型となる。</p></li>
<li><p>どちらか片方が浮動小数点型である。<br /> そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの浮動小数点型となる。</p></li>
<li><p>どちらか片方が<code>ulong</code>型である。<br /> もう片方も<code>ulong</code>型に暗黙変換され、結果も<code>ulong</code>型。</p></li>
<li><p>どちらか片方が<code>long</code>型である。<br /> もう片方も<code>long</code>型に暗黙変換され、結果も<code>long</code>型。</p></li>
<li><p>どちらか片方が<code>uint</code>型である。<br /> もう片方も<code>uint</code>型に暗黙変換され、結果も<code>uint</code>型。</p></li>
<li><p>その他の整数同士の演算<br /> 両方とも<code>int</code>型に暗黙変換され、結果も<code>int</code>型。</p></li>
</ol>
<p>規則2はややこしいかもしれませんが、複素数や虚数が式に現れなければ、5～9のみを意識すればよく、それらの基礎は規則1に従っているので理解しやすいと思います。</p>
<h2 id="数値型に対する演算子"><a href="#数値型に対する演算子">数値型に対する演算子</a></h2>
<p>D言語の数値型には、大きく分けると整数型と浮動小数点型があることを説明しました。 ここでは、その数値型で使える演算子について説明して行きたいと思います。 説明で特に記述がない限り、全ての数値型で使用可能です。 ただし、虚数型や複素型については、対応していないものが多くあります。</p>
<h3 id="括弧bracket"><a href="#括弧bracket">括弧(bracket)</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = (<span class="dv">1</span> + <span class="dv">2</span>) / <span class="dv">1</span>;
<span class="dt">double</span> d = (<span class="fl">1.0</span> * <span class="dv">3</span>) / <span class="fl">4.5</span>;</code></pre>
<p>カッコは最も優先される演算子で、優先順位は1となっています。</p>
<h3 id="単項プラスunary-plus-単項マイナスunary-minus"><a href="#単項プラスunary-plus-単項マイナスunary-minus">単項プラス(unary plus), 単項マイナス(unary minus)</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">12</span>;

writeln(+a);    <span class="co">//  12</span>
writeln(-a);    <span class="co">// -12</span>

<span class="dt">double</span> d = <span class="dv">12</span>;
writeln(+d);    <span class="co">//  12</span>
writeln(-d);    <span class="co">// -12</span>

<span class="dt">cdouble</span> c = <span class="dv">2</span> + <span class="fl">2i</span>;
writeln(+c);    <span class="co">//  2+2i</span>
writeln(-c);    <span class="co">// -2+-2i</span></code></pre>
<p>単項マイナス演算子は、符号を反転させるときに使用します。 単項プラス演算子は、ソースコードを見やすくするためだけにあります。 この2つの演算子は、優先順位3となっています。</p>
<h3 id="インクリメントincrement-デクリメントdecrement"><a href="#インクリメントincrement-デクリメントdecrement">インクリメント(increment), デクリメント(decrement)</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">12</span>;

writeln(++a);   <span class="co">// 13 前置インクリメント</span>
writeln(a);     <span class="co">// 13</span>

writeln(a++);   <span class="co">// 13 後置インクリメント</span>
writeln(a);     <span class="co">// 14</span>

writeln(--a);   <span class="co">// 13 前置デクリメント</span>
writeln(a);     <span class="co">// 13</span>

writeln(a--);   <span class="co">// 13 後置デクリメント</span>
writeln(a);     <span class="co">// 12</span></code></pre>
<p>インクリメントとは、値を一つ増やすことです。 デクリメントは逆に値を一つ減らします。 インクリメントもデクリメントも、左辺値(lvalue)でないと使えません。 理由は簡単で、そのように書いても加算された結果を格納できないからです。</p>
<p>インクリメントとデクリメントには、前置と後置があります。 前置の方を先に説明すると、「値を<code>1</code>だけ{増やして/減らして}から、評価する」となります。 つまり、<code>++a</code>は「<code>a</code>の値を<code>1</code>増やしてから、<code>a</code>を評価する」ということです。</p>
<p>後置インクリメントや後置デクリメントは、「<code>a</code>を評価した値を記憶しつつ、<code>a</code>の値を<code>1</code>だけ増やし、先ほど記憶した値を結果とする」という演算子です。</p>
<p>前置形式と後置形式で決定的に違うのがもう一つあります。 それは、「前置形式は左辺値を返すのに対して、後置形式は右辺値を返す」ことです。 インクリメントとデクリメントは左辺値に対して作用するので、後置形式の結果をインクリメントやデクリメントすることはできません。 逆に前置形式の結果はインクリメント,デクリメント可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">float</span> a = <span class="dv">1</span>;

writeln(++(++a));   <span class="co">// OK</span>
writeln((++a)++);   <span class="co">// OK</span>
++a = <span class="dv">12</span>;           <span class="co">// OK</span>

writeln((a++)++);   <span class="co">// NG; Error: a++ is not an lvalue</span>
writeln(++(a++));   <span class="co">// NG; Error: a++ is not an lvalue</span>
a++ = <span class="dv">20</span>;           <span class="co">// NG; Error: a++ is not an lvalue</span></code></pre>
<p>ちなみに、前置形式と後置形式では後置形式の方が優先順位が高くなっています。 前置形式は優先順位3であるのに対して、後置形式は2です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">cfloat</span> c = <span class="dv">1</span> + <span class="fl">1i</span>;

writeln(++c);       <span class="co">// 2+1i</span>

writeln(++c++);     <span class="co">// NG; Error: c++ is not an lvalue</span>
                    <span class="co">// ++(c++)と解釈されるため</span>

writeln((++c)++);   <span class="co">// OK</span></code></pre>
<h3 id="算術演算子"><a href="#算術演算子">算術演算子</a></h3>
<ul>
<li>加算(Addition), 減算(Subtraction)</li>
</ul>
<p>加算と減算は特に言うことは無いと思います。 加算の演算子<code>+</code>と、減算の演算子<code>-</code>の優先順位と結合規則は同じで、優先順位6の左→右への結合規則です。 2項演算子なので、左辺を先に評価します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">1</span>,
    b = <span class="dv">2</span>;

writeln(a + b);     <span class="co">// 3</span>
writeln(a - b);     <span class="co">// -1</span>

<span class="dt">int</span> c = <span class="dv">3</span>;

writeln(a + b + c); <span class="co">// (a + b) + c と解釈</span>
writeln(a - b + c); <span class="co">// (a - b) + c と解釈</span></code></pre>
<ul>
<li>乗算(Multiplication), 除算(Division)</li>
</ul>
<p>乗算や除算は優先順位が5と、加算や減算よりも優先されるようになっています。 結合規則は、左→右です。 また、この2つも2項演算子なので、左辺を先に評価します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">1</span>,
    b = <span class="dv">2</span>;

writeln(a * b);     <span class="co">// 2</span>
writeln(a / b);     <span class="co">// 0</span>

<span class="dt">int</span> c = <span class="dv">3</span>;

writeln(a * b * c); <span class="co">// (a * b) * c と解釈</span>
writeln(a / b * c); <span class="co">// (a / b) * c と解釈</span></code></pre>
<ul>
<li>剰余(Modulo)</li>
</ul>
<p>剰余演算子は、割り算での余りに相当します。 最後の例のように、浮動小数点数の演算では丸め誤差が存在するため、思った答えと違うものが出る可能性があります。 ほとんど整数でしか使用しないので気にはなりませんが、浮動小数点に対して使用する場合には注意が必要です。</p>
<p>優先順位は積や商と同じ5で、結合規則も同じ右→左です。</p>
<pre class="sourceCode d"><code class="sourceCode d">writeln(<span class="dv">10</span> % <span class="dv">3</span>);    <span class="co">// 1; 10 / 3 = 3 .. 1</span>
writeln(<span class="dv">12</span> % <span class="dv">3</span>);    <span class="co">// 0; 12 / 3 = 3 .. 0</span>

writeln(-<span class="dv">10</span> %  <span class="dv">3</span>);  <span class="co">// -1; -10 /  3 = -3 .. -1</span>
writeln(-<span class="dv">10</span> % -<span class="dv">3</span>);  <span class="co">// -1; -10 / -3 =  3 .. -1</span>
writeln( <span class="dv">10</span> % -<span class="dv">3</span>);  <span class="co">//  1;  10 / -3 = -3 ..  1</span>

writeln(<span class="fl">11.6</span> % <span class="dv">3</span>);  <span class="co">// 2.6; 11.6 / 3   = 3 .. 2.6</span>
writeln(<span class="fl">11.6</span> % <span class="fl">3.5</span>);<span class="co">// 1.1; 11.6 / 3.5 = 3 .. 1.1</span>

writeln(<span class="dv">3</span> % <span class="fl">0.6</span>);   <span class="co">// 0.6(誤差があるため)</span></code></pre>
<ul>
<li>累乗(Power)</li>
</ul>
<p>プログラミングでは時々累乗を使うので、言語機能として累乗演算子が定義されています。 機能としては、<code>std.math.pow</code>と同じです(<code>std.math.pow</code>を呼んでるだけなので)。</p>
<p>優先順位は、もちろん積や商や剰余よりも一つ早い4となっています。</p>
<pre class="sourceCode d"><code class="sourceCode d">writeln(<span class="dv">3</span> ^^ <span class="dv">3</span>);        <span class="co">// 27</span>
writeln(<span class="dv">0</span> ^^ <span class="dv">0</span>);        <span class="co">// 1</span>
writeln(<span class="fl">2.3</span> ^^ <span class="fl">4.4</span>);    <span class="co">// 39.0483</span></code></pre>
<h3 id="ビット演算子bitwise-operators"><a href="#ビット演算子bitwise-operators">ビット演算子(Bitwise operators)</a></h3>
<ul>
<li>補数(Bitwise NOT)</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="bn">0xFF00FF00</span>;

writefln(<span class="st">&quot;%08X&quot;</span>, a);     <span class="co">// FF00FF00</span>
writefln(<span class="st">&quot;%08X&quot;</span>, ~a);    <span class="co">// 00FF00FF</span></code></pre>
<p>補数というのは、2進数では各ビットを反転させた結果に等しくなります。 補数は、組込みなどでしか使う機会は無いでしょうが、頭の片隅に置いておくと便利です。</p>
<p>もちろん、浮動小数点型には適用できません。</p>
<ul>
<li>AND, OR, XOR(Bitwize AND/OR/XOR)</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d">writefln(<span class="st">&quot;%02X&quot;</span>, <span class="bn">0xFF</span> &amp; <span class="bn">0xF0</span>);    <span class="co">// F0 AND</span>
writefln(<span class="st">&quot;%02X&quot;</span>, <span class="bn">0xFF</span> | <span class="bn">0xF0</span>);    <span class="co">// FF OR</span>
writefln(<span class="st">&quot;%02X&quot;</span>, <span class="bn">0xFF</span> ^ <span class="bn">0xF0</span>);    <span class="co">// 0F XOR</span></code></pre>
<p>整数型のビット毎のAND, OR, XORを計算します。 プログラミングでは、よくマスクに利用されます。 たとえば、<code>int</code>型の下位3bitの値が欲しければ、次のシフト演算子を使って<code>(a &amp; ((1 &lt;&lt; 3) -1))</code>とします。</p>
<ul>
<li>右シフト, 左シフト(Bitwise right/left shift operators)</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">4</span>;
<span class="dt">int</span> b33 = <span class="dv">33</span>;

writeln(a &lt;&lt; <span class="dv">0</span>);   <span class="co">// 4</span>
writeln(a &lt;&lt; <span class="dv">1</span>);   <span class="co">// 8</span>
writeln(a &lt;&lt; <span class="dv">8</span>);   <span class="co">// 1024</span>
writeln(a &lt;&lt; b33); <span class="co">// 8</span>

writeln(a &gt;&gt; <span class="dv">0</span>);   <span class="co">// 4</span>
writeln(a &gt;&gt; <span class="dv">1</span>);   <span class="co">// 2</span>
writeln(a &gt;&gt; <span class="dv">8</span>);   <span class="co">// 0</span>
writeln(a &gt;&gt; b33); <span class="co">// 2</span>


a = -<span class="dv">15</span>;
writeln(a);        <span class="co">// -15</span>

writeln(a &gt;&gt; <span class="dv">1</span>);   <span class="co">// -8</span>
writeln(a &gt;&gt; <span class="dv">8</span>);   <span class="co">// -1</span>

writeln(a &gt;&gt;&gt; <span class="dv">1</span>);  <span class="co">// 2147483640</span>
writeln(a &gt;&gt;&gt; <span class="dv">8</span>);  <span class="co">// 16777215</span></code></pre>
<p><code>a &lt;&lt; b</code>は、<code>a</code>のビット達を<code>b</code>ビットだけ左にずらし、先頭を0で埋めます。 つまり、数値を2倍にできます。</p>
<p><code>a &gt;&gt; b</code>は、<code>a</code>のビット達を<code>b</code>ビットだけ右にずらし、aが自然数なら0, aが負の数なら1で先頭を埋めるため、数値を半分にできます。</p>
<p><code>a &gt;&gt;&gt; b</code>は、<code>a</code>のビット達を<code>b</code>ビットだけ右にずらし、先頭を0で埋めます。 <code>&gt;&gt;</code>とは違い、符号を考慮しません。</p>
<p>例では、<code>a &lt;&lt; 1</code>は2倍, <code>a &lt;&lt; 8</code>は<code>2 ^^ 8 =&gt; 256</code>倍となっています。</p>
<p>ちなみに、<code>int</code>や<code>uint</code>型に対して32bit以上のシフトや、<code>long</code>や<code>ulong</code>型に対して64bit以上のシフトをすると、次のような演算になります。</p>
<p><code>a &gt;&gt; b</code> =&gt; <code>a &gt;&gt; (b % (a.sizeof * 8))</code></p>
<p><code>a.sizeof * 8</code>の部分は、<code>int</code>や<code>uint</code>なら32, <code>long</code>や<code>ulong</code>なら64となります。</p>
<p>この演算子も、浮動小数点型には適用できません。</p>
<h3 id="代入演算子assignment-operator-複合代入演算子compound-assignment-operators"><a href="#代入演算子assignment-operator-複合代入演算子compound-assignment-operators">代入演算子(Assignment operator), 複合代入演算子(Compound assignment operators)</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a;
writeln(a); <span class="co">// 0; 初期値</span>

a = <span class="dv">12</span>;
writeln(a); <span class="co">// 12</span>

a += <span class="dv">12</span>;
writeln(a); <span class="co">// 24</span>

a -= <span class="dv">12</span>;
writeln(a); <span class="co">// 12</span>

a *= a;
writeln(a); <span class="co">// 144</span>

a /= a / <span class="dv">4</span>;
writeln(a); <span class="co">// 4</span>

a %= <span class="dv">3</span>;
writeln(a); <span class="co">// 1</span>

++a ^^= <span class="dv">3</span>;
writeln(a); <span class="co">// 8; (++a)が評価され2となり、a = 2 ^^ 3;と等価</span></code></pre>
<p>代入演算子は、ビットのコピー、つまり数値をそのままコピーします。</p>
<p>複合代入演算子では、<code>op=</code>の形を取り、<code>op</code>は数値演算などの2項演算子が取れます。 <code>a op= b</code>は<code>a = a op b</code>と等価です(ただし、aの評価回数が1回減る)。</p>
<p>例にはありませんが、シフト演算子やビット演算子、配列の項で説明する結合演算子<code>~</code>も可能です。 逆に、論理演算子は不可能です。</p>
<p>代入演算子と複合代入演算子は、左辺の値が左辺値でなければいけません。</p>
<h3 id="同値テストequal-to-非同値テストnot-equal-to"><a href="#同値テストequal-to-非同値テストnot-equal-to">同値テスト(Equal to), 非同値テスト(Not equal to)</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">1</span>, b = <span class="dv">2</span>;

writeln(a == a);    <span class="co">// true</span>
writeln(a == b);    <span class="co">// false</span>

writeln(a != a);    <span class="co">// false</span>
writeln(a != b);    <span class="co">// true</span></code></pre>
<p>数値型に対する同値テストは、両辺のビット表現が等しければtrue, そうでなければfalseとなります。 異なる型での比較は、型が格上げされてから比較されます。 非同値テスト<code>a != b</code>は、<code>!(a == b)</code>に等しくなります。</p>
<p>浮動小数点型の場合には誤差があるため、同値テストは使いづらいでしょう。 <code>std.math.approxEqual</code>を使えば誤差を含めて浮動小数点数が等しいかどうか比較できます。 詳しくは、<code>std.math.approxEqual</code>を参照してください。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.math;

<span class="dt">float</span> a = <span class="dv">1</span>;
<span class="dt">float</span> b = a * <span class="fl">1.0000001</span>;

writeln(a == b);                <span class="co">// false</span>
writeln(approxEqual(a, b));     <span class="co">// true</span></code></pre>
<h3 id="比較compare"><a href="#比較compare">比較(Compare)</a></h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">1</span>, b = <span class="dv">2</span>;

writeln(a &lt; a);     <span class="co">// false</span>
writeln(a &lt;= a);    <span class="co">// true</span>
writeln(a &gt; a);     <span class="co">// false</span>
writeln(a &gt;= a);    <span class="co">// true</span>

writeln(a &lt; b);     <span class="co">// true</span>
writeln(a &lt;= b);    <span class="co">// true</span>
writeln(a &gt; b);     <span class="co">// false</span>
writeln(a &gt;= b);    <span class="co">// false</span></code></pre>
<p>数値型では、数学のように比較します。 <code>&lt;=</code>や<code>&gt;=</code>は、「≦」や「≧」に対応します。</p>
<p>複素数型については、比較は定義されていないので適用できません。</p>
<h3 id="論理演算子logical-operators"><a href="#論理演算子logical-operators">論理演算子(Logical operators)</a></h3>
<ul>
<li>AND, OR, NOT</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d">writeln(<span class="kw">true</span> &amp;&amp; <span class="kw">true</span>);      <span class="co">// true</span>
writeln(<span class="kw">true</span> &amp;&amp; <span class="kw">false</span>);     <span class="co">// false</span>
writeln(<span class="kw">false</span> &amp;&amp; <span class="kw">false</span>);    <span class="co">// false</span>

writeln(<span class="kw">true</span> || <span class="kw">true</span>);      <span class="co">// true</span>
writeln(<span class="kw">true</span> || <span class="kw">false</span>);     <span class="co">// true</span>
writeln(<span class="kw">false</span> || <span class="kw">false</span>);    <span class="co">// false</span>

writeln(!<span class="kw">true</span>);             <span class="co">// false</span>
writeln(!!<span class="kw">true</span>);            <span class="co">// true</span>

writeln(<span class="dv">0</span> || <span class="dv">1</span>);            <span class="co">// true</span>
writeln(<span class="dv">0</span> &amp;&amp; <span class="dv">0</span>);            <span class="co">// false</span>

writeln(!<span class="dv">12</span>);               <span class="co">// false</span>
writeln(!!<span class="dv">12</span>);              <span class="co">// true</span>
writeln(!<span class="dv">0</span>);                <span class="co">// true</span>
writeln(!!<span class="dv">0</span>);               <span class="co">// false</span></code></pre>
<p>論理演算子は、bool型の値のAND, OR, NOTを演算します。 もし、bool型以外の型の値を持つ式であれば、その式はbool型に評価されます(cast(bool)される)。</p>
<p>if文の項でも説明しますが、ここでも簡単に説明しておくと、数値型が<code>bool</code>型に評価される場合には、<code>0</code>が<code>false</code>で、それ以外の場合は<code>true</code>として評価されます。</p>
<p>さらに、<code>&amp;&amp;</code>と<code>||</code>の特殊性として、遅延評価が挙げられます。</p>
<ul>
<li><code>a || b</code>は、<code>a == true</code>ならば、<code>b</code>を評価せずとも<code>true</code>であることがわかります。</li>
<li><code>a &amp;&amp; b</code>は、<code>a == false</code>ならば、<code>b</code>を評価せずとも<code>false</code>であることがわかります。</li>
</ul>
<p>よって、<code>a</code>が<code>true</code>か<code>false</code>によって<code>b</code>が評価されるかどうかが異なります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">12</span>;

a == <span class="dv">12</span> || writeln(<span class="st">&quot;foo&quot;</span>);      <span class="co">// writeln(&quot;foo&quot;)は評価されない</span>
a != <span class="dv">12</span> || writeln(<span class="st">&quot;bar&quot;</span>);      <span class="co">// writeln(&quot;bar&quot;)は評価される</span>

a == <span class="dv">12</span> &amp;&amp; writeln(<span class="st">&quot;foo&quot;</span>);      <span class="co">// writeln(&quot;foo&quot;)は評価される</span>
a != <span class="dv">12</span> &amp;&amp; writeln(<span class="st">&quot;bar&quot;</span>);      <span class="co">// writeln(&quot;bar&quot;)は評価されない</span></code></pre>
<ul>
<li>条件演算子(Ternary conditional operator)</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">12</span>;
<span class="dt">ulong</span> b = <span class="dv">13</span>;

<span class="dt">bool</span> select = <span class="kw">true</span>;

writeln(select ? a : b);                    <span class="co">// 12</span>
writeln(!select ? a : b);                   <span class="co">// 13</span>

select ? writeln(<span class="st">&quot;foo&quot;</span>) : writeln(<span class="st">&quot;bar&quot;</span>);   <span class="co">// foo</span>

(!select ? a : ++a) += <span class="dv">3</span>;
writeln(a);                                 <span class="co">// 16</span></code></pre>
<h3 id="コンマ演算子"><a href="#コンマ演算子">コンマ演算子</a></h3>
<p>面白い演算子としてコンマ演算子があります。 この演算子は複数の式を評価するものの、実際の式の値は最後の式の値になります。</p>
<pre class="sourceCode d"><code class="sourceCode d">writeln((<span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>));                              <span class="co">// 14</span>
writeln((writeln(<span class="st">&quot;foo&quot;</span>), writeln(<span class="st">&quot;bar&quot;</span>), <span class="st">&quot;hoge&quot;</span>));
<span class="co">// foo</span>
<span class="co">// bar</span>
<span class="co">// hoge</span></code></pre>
<h2 id="付録-演算子の優先順位と結合規則"><a href="#付録-演算子の優先順位と結合規則">付録 演算子の優先順位と結合規則</a></h2>
<p>今回出てきた演算子の優先順位と結合規則の一覧を以下に示しておきます。</p>
<p>ちなみに、全ての演算子の優先順位については次のページに定義されています。<br /><a href="http://wiki.dlang.org/Operator_precedence">Operator precedence - D Wiki</a></p>
<pre><code>Operator    Order of Evaluation     Associativity: Example
(a)         1                       →

a++         2                       ←
a--         2                       ←

a ^^ b      4                       ←: 2 ^^ 3 ^^ 2 =&gt; 2 ^^ (3 ^^ 2)

++a         3                       ←
--a         3                       ←
+a          3                       ←
-a          3                       ←
!a          3                       ←
~a          3                       ←

a * b       5                       →: 2 * 3 * 2 =&gt; (2 * 3) * 2
a / b       5                       →: 2 * 3 / 2 =&gt; (2 * 3) / 2
a % b       5                       →: 2 / 3 % 2 =&gt; (2 / 3) % 2

a + b       6                       →
a - b       6                       →

a &lt;&lt; b      7                       →
a &gt;&gt; b      7                       →
a &gt;&gt;&gt; b     7                       →

a == b      8                       →
a != b      8                       →
a &lt; b       8                       →
a &lt;= b      8                       →
a &gt; b       8                       →
a &gt;= b      8                       →

a &amp; b       9.0                     →
a ^ b       9.1                     →
a | b       9.2                     →

a &amp;&amp; b      10                      →

a || b      11                      →

a ? b : c   12                      ←

a = b       13                      ←: a = b = c  =&gt;  a = (b = c)
a += b      13                      ←
a -= b      13                      ←
a *= b      13                      ←
a /= b      13                      ←
a %= b      13                      ←
a &amp;= b      13                      ←
a |= b      13                      ←
a ^= b      13                      ←
a &lt;&lt;= b     13                      ←
a &gt;&gt;= b     13                      ←
a &gt;&gt;&gt;= b    13                      ←

a, b        14                      →</code></pre>
<h2 id="問題---解答-2"><a href="#問題---解答-2">問題 -&gt; <a href="answer.md#expr_operator">解答</a></a></h2>
<ul>
<li><p>シフト演算子の<code>&gt;&gt;</code>が、符号を維持できる理由は？<br /> ヒント: 2の補数でGoogleで検索</p></li>
<li><p>シフト演算子で<code>&gt;&gt;&gt;</code>はあるのに<code>&lt;&lt;&lt;</code>がない理由は？<br /> ヒント: 2の補数でGoogleで検索</p></li>
<li><p>問題募集中</p></li>
</ul>
<h2 id="おわりに-2"><a href="#おわりに-2">おわりに</a></h2>
<p>お疲れ様です。 第三回「式と演算子」、長かったと思います。 前回も言いましたが、「基礎の基礎」が重要ですので、「早く何か書きたい！」と思ってても堪えてください。 基礎を固めることによって、相当プログラムの書ける範囲が広がりますし、他の言語へ移ってもすぐに適応できます。</p>
<p>さて、今回の問題は「調べ課題」みたいな感じですが、どうでしょうか？ 計算機上で数値がどのように扱われているか知っておくと、思わぬバグに悩まされたときにより早く解決できるでしょう。</p>
<p>次回は、「標準入力」について説明したいと思います。</p>
<h2 id="キーワード-2"><a href="#キーワード-2">キーワード</a></h2>
<ul>
<li>評価(Evaluation)</li>
<li>暗黙の型変換(Implicit)</li>
<li>演算子(Operator)</li>
<li>演算子の優先順位(Priority of Operators, Order of Operators)</li>
<li>演算子の結合規則(Operator Associativity)</li>
</ul>
<h1 id="条件分岐"><a href="#条件分岐">条件分岐</a></h1>
<h2 id="文のいろいろ"><a href="#文のいろいろ">文のいろいろ</a></h2>
<p>復習しますと、文というのはD言語の小さな単位です。 <code>&lt;expr&gt;;</code>のように、式の後に<code>;</code>をつけると、それは「式<code>&lt;expr&gt;</code>を評価する」という文になりますし、 <code>{</code>と<code>}</code>の間に複数の文を記述すれば、「複数の文を順番に実行する」という文になります。 その他、<code>void main()</code>というのも宣言文だったり、<code>import</code>も文でした。</p>
<p>この記事で説明する<code>if</code>も文です。 これは制御文と呼ばれたり、構造化文と呼ばれたりします。 この2つ以外で、D言語で使える制御文は、<code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>, <code>goto</code>, <code>break</code>, <code>continue</code>, <code>return</code>などです。 それらのうち構造化文は、<code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>です。</p>
<h2 id="条件分岐とは"><a href="#条件分岐とは">条件分岐とは？</a></h2>
<p>条件分岐というのは、「Aという状態ならBをしたいけど、そうじゃないならCを実行して！」ということです。 つまり条件によって次に何を実行するかを選択できます。</p>
<h2 id="if文"><a href="#if文">if文</a></h2>
<p>「もし～だったら、～して！」を表すのが<code>if</code>文です。 例を示しましょう。以下の動作を行うプログラムを書いてみます。</p>
<p>あなたは喉がひどく渇いている。 目の前に自販機があるかもしれない。 自販機があれば、財布と相談して自販機で何かを買う。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio, std.string;

<span class="dt">void</span> main()
{
    write(<span class="st">&quot;あなたは喉が渇いている？(Y/N)---&quot;</span>);
    <span class="dt">bool</span> isThirsty = readln().chomp() == <span class="st">&quot;Y&quot;</span>;

    <span class="kw">if</span>(isThirsty){
        write(<span class="st">&quot;自販機がある？(Y/N)---&quot;</span>);
        <span class="dt">bool</span> isPlaced = readln().chomp() == <span class="st">&quot;Y&quot;</span>;

        <span class="kw">if</span>(isPlaced){
            write(<span class="st">&quot;あなたの所持金は？[円]---&quot;</span>);
            <span class="dt">int</span> pocketMoney;
            readf(<span class="st">&quot;%s\n&quot;</span>, &amp;pocketMoney);

            write(<span class="st">&quot;あなたが欲しい飲み物の値段は？[円]---&quot;</span>);
            <span class="dt">int</span> price = <span class="dt">void</span>;
            readf(<span class="st">&quot;%s\n&quot;</span>, &amp;price);

            <span class="kw">if</span>(price &lt;= pocketMoney){
                writeln(<span class="st">&quot;あなたは自販機で買ってしまった。&quot;</span>);
                writefln(<span class="st">&quot;もう%s[円]しかない。&quot;</span>, pocketMoney - price);
            }<span class="kw">else</span>{
                writeln(<span class="st">&quot;あなたは購入できなかった。&quot;</span>);
                writeln(<span class="st">&quot;次第に渇きが我慢できないほどになってきた。&quot;</span>);
                writeln(<span class="st">&quot;数時間後、そこには意識のないあなたの姿が…&quot;</span>);
            }
        }<span class="kw">else</span>{
            writeln(<span class="st">&quot;次第に渇きが我慢できないほどになってきた。&quot;</span>);
            writeln(<span class="st">&quot;数時間後、そこには意識のないあなたの姿が…&quot;</span>);
        }
    }<span class="kw">else</span>
        writeln(<span class="st">&quot;のどが渇いている気がしたが、ちゃんと考えればそうでもなかった。&quot;</span>);
}</code></pre>
<p>世の中カネなのです。</p>
<p>それはそうと、解説です。 まず、<code>isThirsty</code>の宣言はいいですね。1行読み込んで、それが<code>&quot;Y&quot;</code>なら<code>true</code>となります。 <code>readln().chomp()</code>となっているのは改行文字を消すためで、なぜこのように書けるかというと、<a href="function.md#ufcsuniform-function-call-syntax">UFCS(Uniform Function Call Syntax)</a>という機能のおかげです。</p>
<p>さて、次の<code>if(isThirty){</code>が今回のメインなわけです。 「もし～だったら、～して！」を表すのがif文だと冒頭で述べましたが、この場合には<code>isThirsty == true</code>であれば次の文を実行しろということです。 「次の文」というのは、<code>{</code>から対応する<code>}</code>までのブロック文のことです。 対応する<code>}</code>は最後の方にある<code>}else</code>の先頭の<code>}</code>です。</p>
<p><code>else</code>は<code>else</code>節といい、<code>if</code>文とくっつけて使用します。 <code>else</code>節を<code>if</code>文で表すと以下のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">bool</span> condition = isThirsty;
<span class="kw">if</span>(condition)
    文<span class="dv">1</span>

<span class="kw">if</span>(!condition)
    文<span class="dv">2</span></code></pre>
<p>このように、<code>else</code>節中の文は、<code>if</code>で文が実行されなかった場合に実行されます。 <code>else</code>節がいらないならば、<code>else</code>節は書かなくても大丈夫です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">if</span>(isThirsty)
    writeln(<span class="st">&quot;自販機など存在しない世界線だった！！！&quot;</span>);</code></pre>
<p>また、上記例のように、実行したい文が1つだけであれば、わざわざブロック文<code>{}</code>で囲まずに書けます。 <code>if</code>文が欲しているのは文なので、<code>{}</code>で囲ってなくても文であればいいのです。 そういうこともあって、<code>if-else</code>は多段にできます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">if</span>(isA)
    &lt;ThenStatementA&gt;
<span class="kw">else</span> <span class="kw">if</span>(isB)
    &lt;ThenStatementB&gt;
<span class="kw">else</span> <span class="kw">if</span>(isC)
    &lt;ThenStatementC&gt;
<span class="kw">else</span>
    &lt;ElseStatementOther&gt;</code></pre>
<p>これは以下に等価です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">if</span>(isA)
    &lt;ThenStatementA&gt;
<span class="kw">else</span>
    <span class="kw">if</span>(isB)
        &lt;ThenStatementB&gt;
    <span class="kw">else</span>
        <span class="kw">if</span>(isC)
            &lt;ThenStatementC&gt;
        <span class="kw">else</span>
            &lt;ElseStatementOther&gt;</code></pre>
<p>考えてみれば簡単なことですよね。</p>
<h2 id="boolと評価される式"><a href="#boolと評価される式">boolと評価される式</a></h2>
<p>実は、<code>if(&lt;condition&gt;)</code>の<code>&lt;condition&gt;</code>式のように、特別な場所では<code>bool</code>型以外の型も<code>bool</code>型に暗黙に変換されます。 たとえば数値型であれば非ゼロな値は<code>true</code>となります。 まだ説明していない型ですが、ポインタやクラスであれば、非ヌル<code>a !is null</code>の場合に<code>true</code>と評価されます。 また<code>opCast!bool</code>を持っている構造体と共用体においては、<code>opCast!bool</code>の評価結果となります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;


<span class="dt">void</span> main()
{
    <span class="co">// 数値型</span>
    <span class="dt">int</span> a = -<span class="dv">12</span>;            <span class="co">//マイナスも非ゼロなのでtrue</span>
    <span class="kw">if</span>(a)
        writeln(<span class="st">&quot;a != 0 == true&quot;</span>);

    <span class="co">// ポインタ型</span>
    <span class="dt">int</span>* p = &amp;a;
    <span class="kw">if</span>(p)
        writeln(<span class="st">&quot;p !is null == true&quot;</span>);

    <span class="co">// opCast!boolを持つ構造体</span>
    S s;
    <span class="kw">if</span>(s)
        writeln(<span class="st">&quot;s.opCast!bool == true&quot;</span>);

    <span class="co">// opCast!boolを持つ共用体</span>
    U u;
    <span class="kw">if</span>(u)
        writeln(<span class="st">&quot;u.opCast!bool == true&quot;</span>);

    <span class="co">// クラス</span>
    C c = <span class="kw">new</span> C;
    <span class="kw">if</span>(c)
        writeln(<span class="st">&quot;c !is null == true&quot;</span>);
}


<span class="co">/// opCast!boolを持っている構造体</span>
<span class="kw">struct</span> S
{
    <span class="dt">bool</span> opCast(T : <span class="dt">bool</span>)()
    {
        <span class="kw">return</span> <span class="kw">true</span>;
    }
}


<span class="co">/// opCast!boolを持っている共用体</span>
<span class="kw">union</span> U
{
    <span class="dt">bool</span> opCast(T : <span class="dt">bool</span>)()
    {
        <span class="kw">return</span> <span class="kw">true</span>;
    }
}


<span class="co">/// クラス</span>
<span class="kw">class</span> C{}</code></pre>
<h2 id="if宣言な文"><a href="#if宣言な文">if(宣言)な文</a></h2>
<p>if文のカッコの中では変数を宣言できます。 この構文は、<code>opCall!bool</code>を定義している構造体や共用体、ポインタやクラスを返す関数の返り値を検査したい場合に大変有効です。</p>
<p>例として、正規表現モジュール<code>std.regex</code>を使用する場合の活用の仕方を見てみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.regex;
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">foreach</span>(line; stdin.byLine){
        <span class="co">// 入力の最初の行に与えられた、最初の数値にマッチ</span>
        <span class="kw">if</span>(<span class="kw">auto</span> m = line.match(regex(<span class="st">`\d+`</span>)))
            writeln(m.hit);     <span class="co">// 数値を表示</span>
        <span class="kw">else</span>
            writeln();          <span class="co">// マッチしなければ改行だけ</span>
    }
}</code></pre>
<p>入力:</p>
<pre><code>foobar123
foo222
foo
111222</code></pre>
<p>出力:</p>
<pre><code>123
222

111222</code></pre>
<p>なにが嬉しいかというと、<code>m</code>の使用出来る範囲(スコープ)が<code>if</code>文中だけになることです。 このうれしさはプログラムをバリバリ書けるようになってくると実感します。</p>
<p>ちなみに、<code>else</code>節では<code>m</code>は使えません。</p>
<h2 id="且つと又は"><a href="#且つと又は">&amp;&amp;(且つ)と||(又は)</a></h2>
<p>「<code>isA</code>かつ<code>isB</code>、もしくは<code>isC</code>であれば実行したい」とします。 次のように書けば実現可能ですけど、プログラムがかなり複雑になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">if</span>(isA){
    <span class="kw">if</span>(isB)
        writeln(<span class="st">&quot;OK&quot;</span>);
    <span class="kw">else</span> <span class="kw">if</span>(isC)
        writeln(<span class="st">&quot;OK&quot;</span>);
}<span class="kw">else</span> <span class="kw">if</span>(isC)
    writeln(<span class="st">&quot;OK&quot;</span>);</code></pre>
<p>さて、復習です。 <code>&amp;&amp;</code>や<code>||</code>という演算子がありました。 <code>&amp;&amp;</code>は論理積, <code>||</code>は論理和を計算する演算子でした。 これを使うと、先ほどの例は簡単になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">if</span>((isA &amp;&amp; isB) || isC)
    writeln(<span class="st">&quot;OK&quot;</span>);</code></pre>
<h2 id="問題---解答-3"><a href="#問題---解答-3">問題 -&gt; <a href="answer.md#if">解答</a></a></h2>
<ul>
<li>まずは次のコードの実行結果を予想してみてください。その後実行してみて、予想と違うなら理由を考えてください。</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main(){
    <span class="dt">int</span> a = <span class="dv">12</span>;

    <span class="kw">if</span>(a == <span class="dv">12</span>)
        writeln(<span class="st">&quot;aは12&quot;</span>);
    <span class="kw">else</span>
        writeln(<span class="st">&quot;aは12じゃない&quot;</span>);
        a = <span class="dv">5</span>;

    <span class="kw">if</span>(a != <span class="dv">12</span>)
        writeln(<span class="st">&quot;aは12じゃない&quot;</span>);
    <span class="kw">else</span>
        writeln(<span class="st">&quot;aは12&quot;</span>);
}</code></pre>
<ul>
<li><p>ブール代数という数学の分野があります。次の2式は完全に同じことを記述しているのですが、ブール代数によってそれが本当か判定してみましょう。</p>
<ul>
<li><p>(a &amp;&amp; c) || (b &amp;&amp; c)<br /> (a || b) &amp;&amp; c</p></li>
<li><p>(a &amp;&amp; b) || a<br /> a</p></li>
<li><p>(a || b) &amp;&amp; a<br /> a</p></li>
<li><p>!(a &amp;&amp; b)<br /> (!a || !b)</p></li>
<li><p>!(a || b)<br /> (!a &amp;&amp; !b)</p></li>
</ul></li>
</ul>
<h2 id="おわりに-3"><a href="#おわりに-3">おわりに</a></h2>
<p>おつかれさまです。 今回は今までより短い感じでしたが、よりプログラムっぽくなってきたかと思います。 <code>if</code>文とか、プログラム読んだり書いてたら、だいたい出現するので練習しまくって使えるようにしましょう。 <code>if</code>文とかはC言語やC++, Javaなどと同じなので、そのような言語の入門サイトに載ってる練習問題を解くといいと思います。 ただ、他言語では<code>if(宣言)</code>はできないので注意してください。</p>
<p>では、次は「反復処理」です。</p>
<h2 id="キーワード-3"><a href="#キーワード-3">キーワード</a></h2>
<ul>
<li>条件分岐</li>
<li><code>if</code>文</li>
<li><code>else</code>節</li>
</ul>
<h2 id="if文の仕様"><a href="#if文の仕様">if文の仕様</a></h2>
<p><a href="http://dlang.org/statement.html#IfStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#IfStatement">日本語</a></p>
<h1 id="反復処理"><a href="#反復処理">反復処理</a></h1>
<p>反復処理(ループ)というのは、作業の繰り返しのことです。 プログラムでのループは、「決まった状態になるまで続ける」という処理を記述します。</p>
<h2 id="while文"><a href="#while文">while文</a></h2>
<p>while文は典型的なループ処理を記述できる文です。 たとえば、自然数を足していき、和が100を超えた時点での値を出力したいとします。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00601.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span> n = <span class="dv">1</span>, sum;

    <span class="kw">while</span>(sum &lt; <span class="dv">100</span>){      <span class="co">// (sum &lt; 100) がtrueの間は繰り返す</span>
        sum += n;
        ++n;
    }

    writeln(n-<span class="dv">1</span>);
    writeln(sum);
}</code></pre>
<pre><code>$ rdmd test00601.d
14
105</code></pre>
<p>例の<code>while</code>は、数学をしらない人間が愚直に100になるまで足していく、という作業をそのまま表しています。 実際に<code>14</code>までの和は、<code>14 * (14 + 1) / 2 =&gt; 105</code>ですし、<code>13</code>までの和は<code>105 - 14 =&gt; 91</code>となりますから、正常に計算できているようです。</p>
<p>最後のほうで<code>writeln(n-1);</code>となっていますが、なぜ<code>n</code>じゃなくて<code>n-1</code>なのでしょうね？ 少し考えればわかると思いますので、処理の流れを理解するいい練習になると思います。</p>
<p>さて、<code>while</code>の詳細ですが、<code>while</code>は<code>if</code>同様に<code>while(&lt;expression&gt;) &lt;statement&gt;</code>という形式を取ります。 <code>while</code>の意味は、「<code>&lt;expression&gt;</code>が<code>true</code>の間、<code>&lt;statement&gt;</code>を実行する」ということです。 もし、最初から<code>&lt;expression&gt;</code>が<code>false</code>であればどうなるでしょうか？ <code>&lt;statement&gt;</code>は一度も実行されなくなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00602.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">while</span>(<span class="kw">false</span>)
        writeln(<span class="st">&quot;foooooooo&quot;</span>);

    writeln(<span class="st">&quot;bar&quot;</span>);
}</code></pre>
<pre><code>$ rdmd test00602.d
bar</code></pre>
<h3 id="無限ループ"><a href="#無限ループ">無限ループ</a></h3>
<p>無限ループとは、入ったら永続的に実行され続けるループです。 <code>while</code>は無限ループを簡単に表現できます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">while</span>(<span class="dv">1</span>)            <span class="co">//while(true)でもOK</span>
    &lt;statement&gt;</code></pre>
<p>無限ループは後述する<code>for</code>で<code>for(;;)</code>とも書かれたりします。</p>
<h2 id="do文"><a href="#do文">do文</a></h2>
<p><code>while</code>文の場合、条件<code>&lt;expression&gt;</code>が最初から<code>false</code>であれば一度も実行されないと書きました。 でも、一度は必ず実行して欲しい時があります。 その要望に答えるために、<code>do</code>文といい<code>do &lt;statement&gt; while(&lt;expression&gt;);</code>という文があります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00603.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span> i;

    <span class="kw">do</span>
        writeln(i);
    <span class="kw">while</span>((++i) &lt; <span class="dv">5</span>);
}</code></pre>
<pre><code>$ rdmd test00603.d
0
1
2
3
4</code></pre>
<p><code>do</code>文の処理の流れは、一度<code>&lt;stamenet&gt;</code>を実行してから、<code>&lt;expression&gt;</code>を評価し、<code>true</code>であればまた<code>&lt;statement&gt;</code>を実行し、<code>&lt;expression&gt;</code>を評価し、…というようになります。</p>
<p><code>while</code>文とは、<code>&lt;statement&gt;</code>の実行と<code>&lt;expression&gt;</code>の評価の順序が入れ替わっただけですが、これによって絶対に1回は<code>&lt;statement&gt;</code>が実行されます。</p>
<h2 id="for文"><a href="#for文">for文</a></h2>
<p>一番最初に示した例<code>test00601.d</code>のループでは、条件式<code>sum &lt; 100</code>と更新式<code>++n</code>を持つことがわかります。また、よく考えると<code>int n = 1, sum;</code>というのは<code>n = 1; sum = 0;</code>を表しているとも考えられます。これを初期化式といいます。</p>
<p>以上をまとめると、<code>test00601.d</code>のループには条件式と更新式、初期化式があることがわかりました。 実は、この3つを綺麗に書ける文があります。 <code>for</code>文といいます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00604.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span> n, sum;

    <span class="kw">for</span>(n = <span class="dv">1</span>, sum = <span class="dv">0</span>; sum &lt; <span class="dv">100</span>; ++n)
        sum += n;

    writeln(n-<span class="dv">1</span>);
    writeln(sum);
}</code></pre>
<pre><code>$ rdmd test00604.d
14
105</code></pre>
<p><code>for</code>文は、<code>for(初期化子; 条件式; 更新式) &lt;statement&gt;</code>という形式をとります。 処理の流れは、まず初期化子が実行され、条件式により判定されます。条件式が<code>true</code>であれば、文<code>&lt;statement&gt;</code>が実行されます。 <code>&lt;statement&gt;</code>が終われば、更新式が評価され、また条件式が通れば<code>&lt;statement&gt;</code>が実行され、更新式が評価され、….を繰り返します。</p>
<p><code>for</code>文を<code>while</code>文で書き換えてみると、次のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d">{                   <span class="co">//新しいスコープを作る</span>
    初期化子;
    <span class="kw">while</span>(条件式){
        &lt;statement&gt;
        更新式;
    }
}</code></pre>
<p>初期化式と書かずに初期化子と書いたのには理由があって、初期化子では変数の宣言ができます。 次の<code>for</code>文を使ったループの記述は、C言語の至る所で見る典型的な<code>for</code>の使い方です。<br />(D言語では、後述する<code>foreach</code>を普通は使います)</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00605.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; ++i)
        writeln(i);
}</code></pre>
<pre><code>$ rdmd test00605.d
0
1
2
3
4</code></pre>
<p>変数<code>i</code>のスコープは、<code>for</code>文内のみなので、<code>for</code>文の外側では<code>i</code>にアクセスできません。</p>
<h2 id="foreach-range文"><a href="#foreach-range文">foreach range文</a></h2>
<p><code>foreach range</code>文は、<code>for</code>文の特殊形式だと言えます。 <code>foreach(&lt;identifier&gt;; &lt;exprLower&gt; .. &lt;exprUpper&gt;) &lt;statement&gt;</code>という形式をとります。</p>
<p><code>for</code>文で<code>foreach range</code>文を表すと、次のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">foreach</span>(&lt;identifier&gt;; &lt;exprLower&gt; .. &lt;exprUpper&gt;)
    &lt;statement&gt;

と、以下は同等

{                                       <span class="co">// 新しいスコープを作る</span>
    <span class="kw">auto</span> index = &lt;exprLower&gt;;           <span class="co">// autoは型を自動でつけてくれる</span>
    <span class="kw">auto</span> exprUpper = &lt;exprUpper&gt;;
    <span class="kw">for</span>(; index &lt; exprUpper; ++index){
        <span class="kw">auto</span> &lt;identifier&gt; = index;      <span class="co">// &lt;identifier&gt;はindexのコピー</span>
        &lt;statement&gt;
    }
}

さらにwhileで書き直すと

{                                       <span class="co">// 新しいスコープを作る</span>
    <span class="kw">auto</span> index = &lt;exprLower&gt;;           <span class="co">// autoは型を自動でつけてくれる</span>
    <span class="kw">auto</span> exprUpper = &lt;exprUpper&gt;;
    <span class="kw">while</span>(index &lt; exprUpper){
        <span class="kw">auto</span> &lt;identifier&gt; = index;      <span class="co">// &lt;identifier&gt;はindexのコピー</span>
        &lt;statement&gt;
        ++index;
    }
}</code></pre>
<p>たとえば、「1から10までの総和を取りたい」のなら、次のように記述します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00606.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span> sum;

    <span class="kw">foreach</span>(i; <span class="dv">1</span> .. <span class="dv">11</span>) <span class="co">//[1, 11)</span>
        sum += i;

    writeln(sum);
}</code></pre>
<pre class="sourceCode d"><code class="sourceCode d">$ rdmd test00606.d
<span class="dv">55</span></code></pre>
<p><code>foreach range</code>文は、<code>for</code>文より用法が限られますが、単純な範囲を回すループを記述するのに役立ちます。</p>
<ul>
<li>明示的に<code>&lt;identifier&gt;</code>の型を記述することも可能です。</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">foreach</span>(<span class="dt">ulong</span> i; <span class="dv">0</span> .. <span class="dv">100</span>)
    foo();</code></pre>
<ul>
<li><code>foreach(ref &lt;identifier&gt;; &lt;exprLower&gt; .. &lt;experUpper&gt;)</code>とすることで、ループのインデックスを操作可能です。</li>
</ul>
<p>~~~~d foreach(ref <identifier>; <exprLower> .. <exprUpper>) <statement></p>
<p>と、以下は同等</p>
<p>{ // 新しいスコープを作る auto <identifier> = <exprLower>; // autoは型を自動でつけてくれる auto exprUpper = <exprUpper>; for(; <identifer> &lt; exprUpper; ++<identifier>) <statement> }</p>
<p>さらにwhileで書き直すと</p>
<p>{ // 新しいスコープを作る auto <identifier> = <exprLower>; // autoは型を自動でつけてくれる auto exprUpper = <exprUpper>; while(<identifer> &lt; exprUpper){ <statement> ++<identifier>; } }</p>
<p>例を示すと、以下のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00607.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">foreach</span>(i; <span class="dv">0</span> .. <span class="dv">10</span>){
        writef(<span class="st">&quot;%s, &quot;</span>, i);
        ++i;                <span class="co">// refナシなので意味なし</span>
    }

    writeln();

    <span class="kw">foreach</span>(<span class="kw">ref</span> i; <span class="dv">0</span> .. <span class="dv">10</span>){
        writef(<span class="st">&quot;%s, &quot;</span>, i);
        ++i;                <span class="co">// refアリなので見かけ上2ずつ進む</span>
    }

}</code></pre>
<pre><code>$ rdmd test00607.d
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
0, 2, 4, 6, 8,</code></pre>
<ul>
<li>イテレート可能な型<br /><code>foreach range</code>文で、辿る範囲の型はインクリメント<code>++</code>と等価テスト<code>==</code>が定義されていればどのような型でも可能です。 たとえば、<code>double</code>などの浮動小数点型や、以下の例中に定義されている<code>struct Incrementable</code>は<code>++</code>と<code>==</code>が可能なので<code>foreach range</code>で使えます。</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00608.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">foreach</span>(i; <span class="fl">0.5</span> .. <span class="fl">5.5</span>)
        writeln(i);


    <span class="kw">foreach</span>(e; Incrementable(<span class="dv">0</span>) ..  Incrementable(<span class="dv">10</span>))
        writeln(e);
}


<span class="kw">struct</span> Incrementable
{
    <span class="kw">ref</span> <span class="dt">typeof</span>(<span class="kw">this</span>) opUnary(<span class="dt">string</span> s : <span class="st">&quot;++&quot;</span>)()
    {
        ++_value;
        <span class="kw">return</span> <span class="kw">this</span>;
    }

  <span class="kw">private</span>:
    <span class="dt">int</span> _value;
}</code></pre>
<pre><code>$ rdmd test00608.d
0.5
1.5
2.5
3.5
4.5
Incrementable(0)
Incrementable(1)
Incrementable(2)
Incrementable(3)
Incrementable(4)
Incrementable(5)
Incrementable(6)
Incrementable(7)
Incrementable(8)
Incrementable(9)</code></pre>
<h3 id="foreach_reverse"><a href="#foreach_reverse">foreach_reverse</a></h3>
<p><code>foreach range</code>文には、逆順に辿る<code>foreach_reverse</code>というものがあります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00609.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">foreach</span>(i; <span class="dv">0</span> .. <span class="dv">5</span>)
        writeln(i);

    <span class="kw">foreach_reverse</span>(i; <span class="dv">0</span> .. <span class="dv">5</span>)
        writeln(i);
}</code></pre>
<pre class="sourceCode d"><code class="sourceCode d">$ rdmd test00609.d
<span class="dv">0</span>
<span class="dv">1</span>
<span class="dv">2</span>
<span class="dv">3</span>
<span class="dv">4</span>
<span class="dv">4</span>
<span class="dv">3</span>
<span class="dv">2</span>
<span class="dv">1</span>
<span class="dv">0</span></code></pre>
<h2 id="ループを抜ける-次に進める"><a href="#ループを抜ける-次に進める">ループを抜ける, 次に進める</a></h2>
<p>現実から抜け出したいことはよくありますよね。 少なくとも私は、毎日のように「現実を壊したい、人生をコンティニューしたい」と思ってます。 プログラムでも、ループから抜けだしたいことはありますし、コンティニューしたいことがあるんです。</p>
<h3 id="ループから抜け出す"><a href="#ループから抜け出す">ループから抜け出す</a></h3>
<p><code>break</code>文は、ループという檻を破壊します。 つまり、ループから抜け出します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00610.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">foreach</span>(i; <span class="dv">0</span> .. <span class="dv">100</span>){
        <span class="kw">if</span>(i &gt; <span class="dv">10</span>)
            <span class="kw">break</span>;

        writeln(i);
    }
}</code></pre>
<pre><code>$ rdmd test00610.d
0
1
2
3
4
5
6
7
8
9
10</code></pre>
<p><code>break</code>文は実行されれば、最も内側のループを抜け出します。 ネストされた複数のループを抜けたい場合には、ループ文にラベルをつけて解決します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
  LbreakLabel0:
    <span class="kw">while</span>(<span class="dv">1</span>)
      LbreakLabel1:
        <span class="kw">while</span>(<span class="dv">1</span>)
            <span class="kw">while</span>(<span class="dv">1</span>)
                <span class="kw">break</span> LbreakLabel0;
}</code></pre>
<p><code>break LbreakLabel0;</code>が無ければ、無限ループになって何時までたっても終わらなくなります。</p>
<h3 id="ループを次に進める"><a href="#ループを次に進める">ループを次に進める</a></h3>
<p>たとえば、1~50までの偶数のみの総和は<code>continue</code>を使うと次のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    <span class="dt">int</span> sum;

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= <span class="dv">50</span>; ++i){
        <span class="kw">if</span>(i % <span class="dv">2</span> != <span class="dv">0</span>)
            <span class="kw">continue</span>;

        sum += i;
    }

    writeln(sum);
}</code></pre>
<p>どういうことかというと、<code>continue</code>は文の実行を中止して、更新式<code>++i</code>と条件式<code>i &lt;= 50</code>を評価します。 そして、その後また最初から文を実行します。</p>
<p>別の表現を使用すると、「ループされる文の最後までジャンプ」します。 例では、<code>sum += i;</code>の後までジャンプすると捉えることもできます。</p>
<p>また、<code>continue</code>もラベルを指定することができます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
  LcontinueLabel:
    <span class="kw">do</span>{
        <span class="kw">while</span>(<span class="dv">1</span>)
          LcontinueLabel1:
            <span class="kw">while</span>(<span class="dv">1</span>)
                <span class="kw">continue</span> LcontinueLabel;
    }<span class="kw">while</span>(<span class="dv">0</span>);
}</code></pre>
<h2 id="問題---解答-4"><a href="#問題---解答-4">問題 -&gt; <a href="answer.md#loop">解答</a></a></h2>
<ul>
<li><p><code>test00601.d</code>で、<code>writeln(n);</code>でなくて<code>writeln(n-1);</code>となっている理由は？</p></li>
<li><p><code>foreach_reverse</code>を<code>for</code>文で書き直すとどうなるでしょうか？</p></li>
<li><p>1000未満の自然数で、3の倍数もしくは5の倍数の総和を計算するプログラムをループを使って作ってください。(Project Euler Problem 1より)</p></li>
<li><p>フィボナッチ数列<code>1, 2, 3, 5, 8, ...</code>を考える。数列の項の値が400万以下の偶数である項の合計を求めるプログラムを作ってください。(Project Euler Problem 2より)</p></li>
<li><p>最初の100個の自然数の2乗の総和と、総和の2乗の差を出力するプログラムを<code>for</code>を使って作ってください。その後、<code>foreach</code>を使用するように書き換えてみましょう。(Project Euler Problem 6より)</p></li>
<li><p><code>while(1)</code>, <code>break</code>, <code>continue</code>を使って、「標準入力から得点を受け取り、平均を計算する。ただし、負の数を受け取った場合には平均と合計点を出力して終了する。また、10未満の得点は無視して平均や合計には含めないとする」ようなプログラムを作ってください。</p></li>
</ul>
<h2 id="おわりに-4"><a href="#おわりに-4">おわりに</a></h2>
<p>おつかれさまです。 ループが書けるようになると、相当プログラムの幅が広くなります。 そのため、今回の問題の量はいつもより多いと思います。</p>
<p>次はその他の制御文として、<code>goto</code>, <code>switch</code>の紹介をしたいと思います。</p>
<h2 id="キーワード-4"><a href="#キーワード-4">キーワード</a></h2>
<ul>
<li><code>while</code></li>
<li><code>do-while</code></li>
<li><code>for</code></li>
<li><code>foreach range</code></li>
<li><code>break</code></li>
<li><code>continue</code></li>
</ul>
<h2 id="仕様"><a href="#仕様">仕様</a></h2>
<ul>
<li><code>while</code>: <a href="http://dlang.org/statement.html#WhileStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#WhileStatement">日本語</a></li>
<li><code>do-while</code>: <a href="http://dlang.org/statement.html#DoStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#DoStatement">日本語</a></li>
<li><code>for</code>: <a href="http://dlang.org/statement.html#ForStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#ForStatement">日本語</a></li>
<li><code>foreach range</code>: <a href="http://dlang.org/statement.html#ForeachRangeStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#ForeachRangeStatement">日本語</a></li>
<li><code>break</code>: <a href="http://dlang.org/statement.html#BreakStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#BreakStatement">日本語</a></li>
<li><code>continue</code>: <a href="http://dlang.org/statement.html#ContinueStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#ContinueStatement">日本語</a></li>
</ul>
<h1 id="その他の制御文"><a href="#その他の制御文">その他の制御文</a></h1>
<h2 id="goto文とラベル"><a href="#goto文とラベル">goto文とラベル</a></h2>
<p>アセンブリ言語や機械語を書いたことのある人なら「ジャンプ命令」は知っていると思います。 「ジャンプ命令」とは、プログラムの実行位置(制御位置)を指定アドレスに移動する命令です。 アセンブリ言語では、<code>for</code>文とか<code>foreach</code>, <code>while</code>, <code>if</code>などの構造化文ありませんから、それらはジャンプ命令を使って実現します。</p>
<p>たとえば、次のD言語のコードを、Z80アセンブラで記述し、さらにD言語のコードに変換してみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">size_t</span> sum;
<span class="kw">for</span>(<span class="dt">size_t</span> i = <span class="dv">10</span>; i != <span class="dv">0</span>; --i)
    sum += i;</code></pre>
<pre class="asm"><code>        LD A,0
        LD B,10
LOOP:   ADD A,B
        DJNZ LOOP</code></pre>
<pre class="sourceCode d"><code class="sourceCode d">    <span class="dt">size_t</span> sum = <span class="dv">0</span>;         <span class="co">// Z80アセンブラでのAレジスタ</span>
    <span class="dt">size_t</span> cnt = <span class="dv">10</span>;        <span class="co">// Z80アセンブラでのBレジスタ</span>

  Lloop:                    <span class="co">// ラベル</span>
    sum += cnt;             <span class="co">// ADD A,B</span>
    <span class="kw">if</span>(--cnt)               <span class="co">// この2行は</span>
        <span class="kw">goto</span> Lloop;         <span class="co">// DJNZ LOOPに相当</span></code></pre>
<p>最後のD言語のコードで出現した<code>Lloop:</code>や<code>goto Lloop;</code>というのがラベルや<code>goto</code>文というものです。 アセンブリ言語ではジャンプ命令でループを組みますが、つまり、<code>if</code>と<code>goto</code>があれば、ループ文はなくてもプログラムは書けるということです。</p>
<p>しかし、どう考えても<code>while</code>文や<code>for</code>、<code>foreach</code>の方が見やすく、使い勝手が良いのは明らかです。 ですので、普通は<code>goto</code>文は使いませんし、むしろ嫌われています。</p>
<p>嫌われている理由というのは、<code>goto</code>文は、同一関数内では、ほとんどどこにでも、たとえネストされたブロック内へもジャンプできるからです。 たとえば、次のコードの実行結果を予想してみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">size_t</span> cnt = <span class="dv">4</span>;
    <span class="dt">size_t</span> index;

  LloopA:
    <span class="kw">if</span>(--cnt)
        writeln(<span class="st">&quot;A: &quot;</span>, cnt);
    <span class="kw">else</span>
        <span class="kw">goto</span> Lend;  <span class="co">// ラベルがネストされたブロックにあったとしてもジャンプできる</span>

    index = <span class="dv">0</span>;

  LloopB:
    <span class="kw">if</span>(index == cnt)
        <span class="kw">goto</span> LloopA;
    <span class="kw">else</span>{
        writeln(<span class="st">&quot;\tB: &quot;</span>, index++);
        <span class="kw">goto</span> LloopB;
    }

    {
      <span class="co">// ネストされたブロック内にあるラベル</span>
      Lend: {}
    }
}</code></pre>
<p>このコードは次の等価なコードに変換できます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main(){
    <span class="kw">foreach_reverse</span>(cnt; <span class="dv">1</span> .. <span class="dv">4</span>){
        writeln(<span class="st">&quot;A: &quot;</span>, cnt);

        <span class="kw">foreach</span>(i; <span class="dv">0</span> .. cnt)
            writeln(<span class="st">&quot;\tB: &quot;</span>, i);
    }
}</code></pre>
<p>どうでしょうか？<code>foreach</code>を使ったほうがソースコードが見やすいですし、予想もしやすいかと思います。 このように、<code>goto</code>はたしかに強力なのですが、プログラムの流れが破綻しやすく、期待した動作が得られなかったり、 後からソースコードを読むときに理解が困難になったりします。</p>
<ul>
<li>goto文の制約</li>
</ul>
<p>そんな嫌われ者の<code>goto</code>文ですが、正しく扱ってあげることによって上手いソースコードを作ることが出来ます。 正しく扱うために、D言語の<code>goto</code>文は、変数宣言を飛び越えることや<code>try</code>, <code>catch</code>, <code>finally</code>へのジャンプはできません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    <span class="co">//goto Label; // Error: goto skips declaration of variable test.main.x</span>
    <span class="dt">int</span> x;
  Label: {}
}</code></pre>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main(){
    <span class="co">//goto LtoTry;        // Error</span>
    <span class="co">//goto LtoCatch;      // Error</span>
    <span class="co">//goto LtoFinally;    // Error</span>

    <span class="kw">try</span>{
      LtoTry: {}
        <span class="kw">goto</span> Lend;
    }
    <span class="kw">catch</span>(<span class="dt">Exception</span>){
      LtoCatch: {}
        <span class="kw">goto</span> Lend;
    }
    <span class="kw">finally</span>{
      LtoFinally: {}
        <span class="co">//goto Lend;      // Error</span>
    }

  Lend: {}
}</code></pre>
<h2 id="switch文とcase文"><a href="#switch文とcase文">switch文とcase文</a></h2>
<p>たとえば、16進数の数値を表す文字列を受け取って、int型変数に数値として格納する処理を非現実的に書いてみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio, std.string, std.array;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> str = readln().chomp();
    <span class="dt">byte</span> sign = <span class="dv">1</span>;
    <span class="dt">int</span> value;

    <span class="kw">if</span>(!str.empty &amp;&amp; str.front == <span class="ch">&#39;-&#39;</span>){
        sign = -<span class="dv">1</span>;
        str.popFront();
    }

    <span class="kw">foreach</span>(c; str){
        <span class="kw">if</span>(c == <span class="ch">&#39;0&#39;</span>)
            value = value * <span class="dv">16</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;1&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">1</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;2&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">2</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;3&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">3</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;4&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">4</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;5&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">5</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;6&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">6</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;7&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">7</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;8&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">8</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;9&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">9</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;a&#39;</span> || c == <span class="ch">&#39;A&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">10</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;b&#39;</span> || c == <span class="ch">&#39;B&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">11</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;c&#39;</span> || c == <span class="ch">&#39;C&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">12</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;d&#39;</span> || c == <span class="ch">&#39;D&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">13</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;e&#39;</span> || c == <span class="ch">&#39;E&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">14</span>;
        <span class="kw">else</span> <span class="kw">if</span>(c == <span class="ch">&#39;f&#39;</span> || c == <span class="ch">&#39;F&#39;</span>)
            value = value * <span class="dv">16</span> + <span class="dv">15</span>;
        <span class="kw">else</span>{
            writeln(<span class="st">&quot;Error !!!&quot;</span>);
            <span class="kw">break</span>;
        }
    }

    value *= sign;

    writeln(value);
}</code></pre>
<p>どう考えても、非効率的ですが、こういう時に<code>switch</code>文は役に立ちます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio, std.string, std.array;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> str = readln().chomp();
    <span class="dt">byte</span> sign = <span class="dv">1</span>;
    <span class="dt">int</span> value;

    <span class="kw">if</span>(!str.empty &amp;&amp; str.front == <span class="ch">&#39;-&#39;</span>){
        sign = -<span class="dv">1</span>;
        str.popFront();
    }

    <span class="kw">foreach</span>(c; str){
        <span class="kw">switch</span>(c){
          <span class="kw">case</span> <span class="ch">&#39;0&#39;</span>, <span class="ch">&#39;1&#39;</span>, <span class="ch">&#39;2&#39;</span>, <span class="ch">&#39;3&#39;</span>, <span class="ch">&#39;4&#39;</span>, <span class="ch">&#39;5&#39;</span>, <span class="ch">&#39;6&#39;</span>, <span class="ch">&#39;7&#39;</span>, <span class="ch">&#39;8&#39;</span>, <span class="ch">&#39;9&#39;</span>:
            value = value * <span class="dv">16</span> + (c - <span class="ch">&#39;0&#39;</span>);
            <span class="kw">break</span>;

          <span class="kw">case</span> <span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>, <span class="ch">&#39;d&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;f&#39;</span>:
            value = value * <span class="dv">16</span> + (c - <span class="ch">&#39;a&#39;</span> + <span class="dv">10</span>);
            <span class="kw">break</span>;

          <span class="kw">case</span> <span class="ch">&#39;A&#39;</span>, <span class="ch">&#39;B&#39;</span>, <span class="ch">&#39;C&#39;</span>, <span class="ch">&#39;D&#39;</span>, <span class="ch">&#39;E&#39;</span>, <span class="ch">&#39;F&#39;</span>:
            value = value * <span class="dv">16</span> + (c - <span class="ch">&#39;A&#39;</span> + <span class="dv">10</span>);
            <span class="kw">break</span>;

          <span class="kw">default</span>:
            writeln(<span class="st">&quot;Error !!!&quot;</span>);
        }
    }

    value *= sign;

    writeln(value);
}</code></pre>
<p>このように、<code>switch</code>文は、内部に<code>case</code>文もしくは<code>default</code>文を持ちます。 <code>switch</code>文は、評価した式(整数型かenum型か文字列型)が<code>case &lt;List&gt;</code>の<code>&lt;List&gt;</code>に含まれていれば、その<code>case</code>までジャンプします。 もし、一致する<code>case</code>が無ければ<code>default</code>までジャンプします。 <code>switch</code>文は<code>break</code>文で脱出可能です。</p>
<p>また、以下の様な書き方も可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio, std.string, std.array;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> str = readln().chomp();
    <span class="dt">byte</span> sign = <span class="dv">1</span>;
    <span class="dt">int</span> value;

    <span class="kw">if</span>(!str.empty &amp;&amp; str.front == <span class="ch">&#39;-&#39;</span>){
        sign = -<span class="dv">1</span>;
        str.popFront();
    }

    <span class="kw">foreach</span>(c; str){
        <span class="kw">switch</span>(c){
          <span class="kw">case</span> <span class="ch">&#39;0&#39;</span>: .. <span class="kw">case</span> <span class="ch">&#39;9&#39;</span>:
            value = value * <span class="dv">16</span> + (c - <span class="ch">&#39;0&#39;</span>);
            <span class="kw">break</span>;

          <span class="kw">case</span> <span class="ch">&#39;a&#39;</span>: .. <span class="kw">case</span> <span class="ch">&#39;f&#39;</span>:
            value = value * <span class="dv">16</span> + (c - <span class="ch">&#39;a&#39;</span> + <span class="dv">10</span>);
            <span class="kw">break</span>;

          <span class="kw">case</span> <span class="ch">&#39;A&#39;</span>: .. <span class="kw">case</span> <span class="ch">&#39;F&#39;</span>:
            value = value * <span class="dv">16</span> + (c - <span class="ch">&#39;A&#39;</span> + <span class="dv">10</span>);
            <span class="kw">break</span>;

          <span class="kw">default</span>:
            writeln(<span class="st">&quot;Error !!!&quot;</span>);
        }
    }

    value *= sign;

    writeln(value);
}</code></pre>
<ul>
<li><code>switch</code>文中の<code>case</code>への<code>goto</code></li>
</ul>
<p><code>switch</code>文中では、その<code>switch</code>文の中にある<code>case</code>へ<code>goto</code>でジャンプすることができます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> x;
<span class="kw">switch</span>(x){
  <span class="kw">case</span> <span class="dv">0</span>:
    <span class="kw">goto</span> <span class="kw">case</span>;

  <span class="kw">case</span> <span class="dv">1</span>:
    <span class="kw">goto</span> <span class="kw">case</span>;

  <span class="kw">case</span> <span class="dv">2</span>:
    <span class="kw">goto</span> <span class="kw">case</span> <span class="dv">4</span>;

  <span class="kw">case</span> <span class="dv">3</span>:
    <span class="kw">goto</span> <span class="kw">case</span> <span class="dv">8</span>;

  <span class="kw">case</span> <span class="dv">4</span>:
    <span class="kw">goto</span> <span class="kw">case</span> <span class="dv">3</span>;

  <span class="kw">case</span> <span class="dv">5</span>: .. <span class="kw">case</span> <span class="dv">10</span>:
    <span class="kw">goto</span> <span class="kw">default</span>;

  <span class="kw">default</span>:
    writeln(<span class="st">&quot;Sw End&quot;</span>);
}</code></pre>
<p><code>goto case;</code>は、その次の<code>case</code>文までジャンプします。 <code>goto case 4;</code>は<code>case 4:</code>までジャンプします。 <code>goto default;</code>とすると、<code>default:</code>ラベルまでジャンプします。</p>
<h2 id="問題---解答-5"><a href="#問題---解答-5">問題 -&gt; <a href="answer.md#other_statements">解答</a></a></h2>
<ul>
<li><p>問1<br />入力として<code>&lt;整数&gt; &lt;四則演算子&gt; &lt;整数&gt;</code>のような文字列を受け取り、出力としてその式の結果を返すプログラムを作ってください。たとえば、<code>123 + 456</code>という文字列が入力されれば、<code>579</code>を出力するようにしてください。<br />ヒント: <code>readf(&quot;%s %s %s&quot;, &amp;v1, &amp;op, &amp;v2);</code></p></li>
<li><p>問題募集中</p></li>
</ul>
<h2 id="おわりに-5"><a href="#おわりに-5">おわりに</a></h2>
<p>お疲れ様です。 <code>goto</code>文は使うことも、見ることもあまりないと思いますが、D言語の産みの親であるWalter Brightは好きだそうで、またD言語の標準ライブラリPhobosの中でも結構使われてます。 <code>switch</code>文は、条件分岐によく使いますが、今回説明していない<code>final switch</code>という文もあるので、結構便利になっていると思います。 では、次は配列です。</p>
<h2 id="キーワード-5"><a href="#キーワード-5">キーワード</a></h2>
<ul>
<li><code>goto</code>文</li>
<li>ラベル(Label)</li>
<li><code>switch</code>文</li>
<li><code>case</code>文</li>
<li><code>default</code>文</li>
<li><code>goto case;</code></li>
<li><code>goto default;</code></li>
</ul>
<h2 id="仕様-1"><a href="#仕様-1">仕様</a></h2>
<ul>
<li><p>goto <a href="http://dlang.org/statement.html#GotoStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#GotoStatement">日本語</a></p></li>
<li><p>switch <a href="http://dlang.org/statement.html#SwitchStatement">英語</a> <a href="http://www.kmonos.net/alang/d/statement.html#SwitchStatement">日本語</a></p></li>
</ul>
<h1 id="配列"><a href="#配列">配列</a></h1>
<h2 id="配列arrayとは"><a href="#配列arrayとは">配列(Array)とは？</a></h2>
<p>配列というのは「メモリ上に連続した値のリスト(list)」です。 たとえば<code>int</code>型の配列は、<code>int</code>型の値がメモリ上に連続しているリストのことを言います。 配列を構成する個々の値のことを要素(element)とよび、各要素にアクセスするにはメモリ上での順番と同じインデックス(添字, Index)という整数値を使い、<code>arr[idx]</code>とします。 <code>arr</code>は配列型の値で、<code>idx</code>はインデックスを表す整数型の値です。 インデックスはメモリ上での順番に沿って<code>0, 1, 2, 3, ...</code>と割り振れるため、インデックスが0の要素<code>arr[0]</code>を「先頭要素」、インデックスが<code>idx</code>な要素<code>arr[idx]</code>を「<code>idx</code>番目の要素」などと言ったりします。 注意しなければいけないのは、「先頭要素」と「0番目の要素」は同じ意味です。</p>
<p>また、配列は有限の長さ(大きさ)分だけ要素を持ちます。 配列<code>arr</code>の長さは、<code>arr.length</code>で取得可能です。 <code>arr.length</code>が<code>2</code>であれば、配列<code>arr</code>が持つ要素の数は2個で、インデックスは<code>0, 1</code>の2つが有効です。 一般に、有効なインデックスは<code>0</code>から<code>arr.length - 1</code>であり、それ以外のインデックス、たとえば<code>-1</code>とか<code>arr.length</code>でアクセスしようとするとエラーが出ます。</p>
<p><code>arr[idx]</code>は左辺値なので、<code>arr[idx] = value;</code>のように代入も可能です。 最終要素の左辺値を取得するには<code>arr[arr.length - 1]</code>とします。 <code>[]</code>の中では<code>arr.length =&gt; $</code>と書き換えれるので、<code>arr[$-1]</code>も最終要素の左辺値となります。</p>
<p>今までよく出てきた<code>string</code>も実際には「『書き換え不可能な文字』の配列」でした。 先頭文字は<code>str[0]</code>で取得できますし、<code>str[$-1]</code>とすれば最後の文字が得られます。</p>
<p>配列を使う理由は、“大量”の変数を“まとめて”扱いたいからです。 たとえば、文字列<code>&quot;abcd&quot;</code>の各文字にそれぞれ<code>char</code>型の変数を<code>char str0 = 'a', str1 = 'b', str2 = 'c', str3 = 'd';</code>のように割り当てていては使い勝手が悪すぎます。</p>
<h2 id="スタックとヒープ"><a href="#スタックとヒープ">スタックとヒープ</a></h2>
<p>スタック(Stack)領域は、静的にその大きさが決められ、関数の開始時に有効となり、関数の終了とともに消滅するメモリ領域のことです。 関数内で宣言した変数はすべてスタックに置かれます。 (もちろん、ポインタやスライス、クラスといった参照型は、参照先がスタック上にないかもしれないだけで、変数自体はスタック上にあります。)</p>
<p>これに対となるのがヒープ(Heap)領域で、動的に確保可能、つまり実行時に欲しいだけの領域を確保可能です。 また、関数が終了しても存在し続けるメモリ領域で、<code>new</code>演算子や<code>core.memory.GC.malloc</code>などを用いて確保します。 動的に確保するため、実行時に多少の時間的コストもかかります。</p>
<p>通常、スタック領域は1MB程度と小さいので、大量のメモリが必要であればヒープ領域を確保します。</p>
<h2 id="静的配列static-array"><a href="#静的配列static-array">静的配列(Static Array)</a></h2>
<p>静的配列は、スタック上に確保される配列で、C言語の配列(mallocで確保する領域ではない)に似ています。 <code>T</code>型の要素を<code>N</code>個もつ静的配列は<code>T[N]</code>という型になります。 静的配列は、それ全体が値的な性質を持っています。 たとえば次のコードでは、静的配列全体をコピーする操作になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dv">16</span>] a, b;

<span class="co">// a, bに対するいくつかの操作</span>

a = b;              <span class="co">// 要素すべてのコピー</span></code></pre>
<p>静的配列の長さはコンパイル時に固定され、実行時に変更することはできません。 また、長さの違う静的配列のコピーはコンパイル時にエラーになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dv">16</span>] a;
<span class="dt">int</span>[<span class="dv">17</span>] b;

a.<span class="dt">length</span> = <span class="dv">1024</span>;    <span class="co">// Error: constant a.length is not an lvalue</span>
a = b;              <span class="co">// Error: mismatched array lengths, 16 and 17</span>

a = b[<span class="dv">0</span> .. <span class="dv">16</span>];     <span class="co">// 後ほど説明するスライスに変換してしまえばコピー可能</span></code></pre>
<p>スタック領域は容量に制限がある(例. 1MB)ので、大きな静的配列を確保するのはオススメしません。 また、静的配列への代入は全要素のコピーなので、大きな配列であればコピーに時間がかかってしまいます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dv">1024</span> * <span class="dv">1024</span> * <span class="dv">4</span>] a;     <span class="co">// Error: index 4194304 overflow for static array</span></code></pre>
<p>このような場合には、静的配列は諦めて後述する<code>new int[1024 * 1024 * 4]</code>によってヒープ上に領域を確保するしかありません。</p>
<h2 id="配列とポインタのお話"><a href="#配列とポインタのお話">配列とポインタのお話</a></h2>
<p>配列というのは、メモリ上に連続する値のリストのことでした。 配列を最もシンプルに表すためには、「メモリ上での位置」と「配列の大きさ」が必要です。 つまり、「配列の先頭要素<code>arr[0]</code>を指すメモリアドレス値」と「配列の大きさ」があれば十分にその配列を表現可能です。 メモリアドレス値はポインタ値(Pointer)と呼ばれ、今までに数回出て来ましたね。</p>
<pre class="sourceCode d"><code class="sourceCode d">T* ptr;         <span class="co">// 先頭要素を指すポインタ</span>
<span class="dt">size_t</span> length;  <span class="co">// 配列の長さ</span></code></pre>
<p>D言語の親であるC言語では、スタック上に確保される静的配列や可変長配列(VLA, Variable Length Array)は、ポインタ的な振る舞いもしますし、<code>sizeof</code>演算子で配列の要素数も取得可能です。 また、大きな配列を確保したければ、<code>malloc</code>や<code>calloc</code>を使ってヒープ上に確保し、以降はポインタ値と長さを表す変数をペアで運用するのが普通です。</p>
<p>D言語は、C言語のこのような流れを継承しているので、ポインタでも配列のようなことができますが、より良く配列を表現するためスライス(Slice)というものを導入しました。 D言語のスライスは、ポインタ値と大きさのペアでしかなく、よく勘違いされるのですが、他の言語の動的配列(たとえばC++の<code>vector</code>やJavaの<code>ArrayList</code>)とは全く異なったコンセプトです。</p>
<h2 id="スライス"><a href="#スライス">スライス</a></h2>
<p>普通、D言語で「動的配列」と呼ばれたらスライスのことを指します。 実際に、仕様上はスライスは「動的配列型(Dynamic Array)」となっていますが、スライスと呼ばれることが多いので本稿ではスライスとします。</p>
<p>スライスは、スライスの先頭要素へのポインタ値とスライスの長さしか持ちません。 ですから、スライスはポインタからも生成可能ですし、静的配列からも作れます。 スライスの型は<code>T[]</code>となります。 スライスの大きさは、<code>slice.length</code>で取得可能で、<code>slice[idx]</code>でスライスの要素の左辺値を取得可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>* p;
<span class="dt">size_t</span> size;

<span class="co">// 適当なpとsizeに関する操作, pは配列の先頭要素へのポインタ, sizeは配列の長さ</span>

<span class="dt">int</span>[] slice1 = p[<span class="dv">0</span> .. size];    <span class="co">// ポインタとサイズからスライスの生成</span>

<span class="dt">int</span>[<span class="dv">25</span>] arr;
<span class="dt">int</span>[] slice2 = arr[];           <span class="co">// 静的配列からスライスの生成</span>

<span class="dt">int</span>[] slice3;                   <span class="co">// デフォルト初期化</span>
slice3 ~= slice1;               <span class="co">// デフォルト初期化値でも追加や連結、拡大可能</span></code></pre>
<h3 id="ヒープ上のメモリの確保"><a href="#ヒープ上のメモリの確保">ヒープ上のメモリの確保</a></h3>
<p>では、ヒープ上に新しい領域を確保するにはどのようにするのでしょうか？ C言語のように<code>malloc</code>や<code>calloc</code>を使うのは安全ではありません。 D言語にはD言語なりの確保方法があります。 <code>new T[n]</code>とすれば、ヒープ上に新しく最低<code>n</code>個の<code>T</code>型の領域が割り当てられ、その領域を示すスライス<code>T[]</code>がその値となります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10000</span>];   <span class="co">// ヒープ上に1万要素を確保し、スライスとして取得</span></code></pre>
<h3 id="要素の追加とスライス同士の結合大きさの拡大縮小"><a href="#要素の追加とスライス同士の結合大きさの拡大縮小">要素の追加とスライス同士の結合、大きさの拡大縮小</a></h3>
<p>スライスは動的配列ではありませんが、動的配列のように要素の追加、結合、大きさの拡大縮小も可能です。 D言語のランタイムが賢く動くので、プログラマは少しだけ注意すればほとんど考える必要はありません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = foo();  <span class="co">// なにか適当なスライス</span>

arr ~= <span class="dv">1</span>;           <span class="co">// 要素の追加</span>
arr ~= foo();       <span class="co">// スライスの結合</span>

arr = arr ~ arr;    <span class="co">// 2項演算子としての結合</span>

arr.<span class="dt">length</span> = <span class="dv">100</span>;   <span class="co">// 大きさの変更</span></code></pre>
<p>スライスの大きさが大きくなった場合、その前後でスライスの持つポインタ値が一致しない場合があります。 このとき、「スライスを大きくする」操作は実際には「新しいヒープ領域を確保し、メモリの内容をコピーし、その領域を示すスライスにする」という操作になります。 スライスの領域に連続して未使用の予約された領域が存在するならば、ポインタの値は変えずにスライスの大きさを大きくして、その予約された領域へ追加の値をコピーします。 逆を言えば、静的配列やポインタなどから作成されたスライスへの追加や拡大は、絶対に予約領域がありませんから、必ず新しい領域の確保とその領域への全体のコピーが行われます。 スライスで一番難しいのはこの仕様で、新しい領域の確保のタイミングは把握しにくくなります。</p>
<h3 id="ガベージコレクタ"><a href="#ガベージコレクタ">ガベージコレクタ</a></h3>
<p>スライスはスタックやヒープにかかわらず、動的配列のようなインターフェースを提供することがわかりました。 では、<code>new</code>でヒープ領域を確保したり、追加や連結、拡大によって確保されたヒープ領域のメモリはどのように開放されるのでしょうか？ D言語はガベージコレクタを言語仕様として持つので、これらの開放はガベージコレクタによってなされます。 ですから、プログラマはほとんど何も考えずに、様々なメモリ領域をスライスにでき、さも動的配列のように動作させることができるのです。</p>
<h3 id="スライス演算子"><a href="#スライス演算子">スライス演算子</a></h3>
<p>ポインタ, 静的配列, スライスから、その領域のスライスを得る方法としてスライス演算子があります。 スライス演算子は<code>p[idxBegin .. idxEnd]</code>と書きます。 <code>idxBegin</code>は新しいスライスの開始インデックス、<code>idxEnd</code>は、最終要素のインデックス+1です。 もし、<code>p</code>がスライスもしくは静的配列であれば、<code>idxBegin</code>, <code>idxEnd</code>の両方は<code>p</code>の長さを表す<code>$</code>を含んだ式にできます。 もし、スライスや静的配列に対して、その領域への新たなスライスが欲しいなら<code>p[0 .. $]</code>と書く代わりに<code>p[]</code>とも書けます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>* p = foo();

<span class="dt">int</span>[] slice1 = p[<span class="dv">0</span> .. <span class="dv">100</span>];             <span class="co">// ポインタから100個の領域のスライス</span>

<span class="dt">int</span>[] slice2 = slice1[<span class="dv">10</span> .. $];         <span class="co">// slice1の10番目から最終要素までのスライス</span>

<span class="dt">int</span>[<span class="dv">40</span>] staticArray;

<span class="dt">int</span>[] slice3 = staticArray[<span class="dv">0</span> .. $-<span class="dv">10</span>];  <span class="co">// 静的配列staticArrayの前から30個のスライス</span>

<span class="dt">int</span>[] emptySlice1 = slice3[$ .. $],     <span class="co">// 長さ0のスライス</span>
      emptySlice2 = slice3[<span class="dv">0</span> .. <span class="dv">0</span>];     <span class="co">// 長さ0のスライス</span>

slice3 = staticArray[];                 <span class="co">// staticArray[0 .. $]と同じ</span></code></pre>
<h3 id="スライスを使ったベクトル演算"><a href="#スライスを使ったベクトル演算">スライスを使ったベクトル演算</a></h3>
<p>スライスの各要素をコピーしたり、各要素間でベクトル加算などをするときに便利です。 また、SIMD化も狙えるかもしれませんし、foreachやforでループを回すよりも高速になるでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr1 = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">1024</span>],
      arr2 = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">1024</span>];

arr1[] = <span class="dv">10</span>;                    <span class="co">// 全要素に10を代入</span>
arr2[] -= <span class="dv">100</span>;                  <span class="co">// 全要素から100を引く</span>
arr1[] *= arr2[];               <span class="co">// 2つのスライスの全要素それぞれを掛け合わせ、arr1に格納。</span>

arr2[<span class="dv">0</span> .. <span class="dv">8</span>] *= arr1[<span class="dv">8</span> .. <span class="dv">16</span>];  <span class="co">// 8要素だけの掛け算</span>

arr2[<span class="dv">8</span> .. $] = arr1[<span class="dv">8</span> .. $];    <span class="co">// メモリのコピー</span></code></pre>
<h3 id="スライスの独立性"><a href="#スライスの独立性">スライスの独立性</a></h3>
<p>たとえば次のコードを考えてみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
<span class="dt">int</span>[] slice1 = arr;

<span class="kw">assert</span>(arr == slice1);

arr[<span class="dv">0</span>] = -<span class="dv">1</span>;                            <span class="co">// arrの先頭を-1に書き換え</span>
<span class="kw">assert</span>(slice1[<span class="dv">0</span>] == -<span class="dv">1</span>);                <span class="co">// slice1はarrの領域を参照しているだけにすぎない</span>

arr = arr[<span class="dv">0</span> .. <span class="dv">2</span>];
<span class="kw">assert</span>(arr.lengt == <span class="dv">2</span>);                 <span class="co">// arrの大きさは2となる</span>
<span class="kw">assert</span>(slice1.<span class="dt">length</span> == <span class="dv">6</span>);             <span class="co">// たとえarrの大きさが変わってもslice1の大きさに変わりはない</span>

arr[<span class="dv">0</span>] = -<span class="dv">2</span>;                            <span class="co">// arrの先頭要素を書き換えれば</span>
<span class="kw">assert</span>(slice1[<span class="dv">0</span>] == -<span class="dv">2</span>);                <span class="co">// slice1も同一領域を参照しているので書き換わる</span>

arr.<span class="dt">length</span> = <span class="dv">10</span>;                        <span class="co">// arrの大きさを大きくしてみる</span>
<span class="kw">assert</span>(slice1.<span class="dt">length</span> == <span class="dv">6</span>);             <span class="co">// もちろん、slice1の大きさは変わらない</span>

arr[<span class="dv">0</span>] = -<span class="dv">3</span>;                            <span class="co">// しかし、arrの先頭要素を書き換えても</span>
<span class="kw">assert</span>(slice1[<span class="dv">0</span>] == -<span class="dv">2</span>);                <span class="co">// slice1の先頭要素に影響はない。</span>
                                        <span class="co">// arr.length = 10;で新しい領域にarrの内容がコピーされ、arrはそれを指している。</span></code></pre>
<p>スライス<code>T[]</code>は、ポインタ<code>T*</code>とサイズ<code>size_t</code>のペアであると考えられます。 また、スライスの縮小だけでは新しい領域が確保されることはありません。 結合や拡大を行なってしまえば、新たに確保される可能性があり、新しい領域が確保された場合には、もちろん他のスライスへの影響は無くなります。</p>
<h2 id="スライスや配列の等価テスト同値テスト"><a href="#スライスや配列の等価テスト同値テスト">スライスや配列の等価テスト(同値テスト)</a></h2>
<p>静的配列やスライスを<code>==</code>演算子や<code>!=</code>演算子で比較すると、全要素が等しいかそうでないかを判定します。 つまり、スライスであれば参照先のポインタには関係ありません。 もし、スライスが同じ領域を指しているかどうかを確認したい場合には<code>is</code>演算子を使います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dv">3</span>] stArr1 = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>],
       stArr2 = [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],
       stArr3 = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>];

writeln(stArr1 != stArr2);      <span class="co">// true     要素が違う</span>
writeln(stArr1 == stArr3);      <span class="co">// true     要素は全部同じ</span>

<span class="dt">int</span>[] slice1 = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>],
      slice2 = [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],
      slice3 = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>];

writeln(slice1 != slice2);      <span class="co">// true     要素が違う</span>
writeln(slice1 == slice3);      <span class="co">// true     要素は全部同じ</span>

writeln(slice1 !<span class="kw">is</span> slice3);     <span class="co">// true     参照している領域が違う</span>

<span class="dt">int</span>[] slice4 = slice1;
writeln(slice4 <span class="kw">is</span> slice1);      <span class="co">// true     slice4はslice1と同じ領域を指している</span>

slice4 = slice4[<span class="dv">1</span> .. $];
writeln(slice4 !<span class="kw">is</span> slice1);     <span class="co">// true     指している先(ptr)は同じだが、長さが違う</span>

writeln(stArr1 == slice1);      <span class="co">// true     もちろん、静的配列とスライスの比較も可能</span></code></pre>
<h2 id="スライスや配列の大小比較"><a href="#スライスや配列の大小比較">スライスや配列の大小比較</a></h2>
<p>Dでは、配列の大小関係も比較できます。 配列の大小は、「辞書」に並ぶように決められています。</p>
<p>たとえば、「あああ」と「ああい」では、「あああ」のほうが(もし辞書に並ぶなら)前にあるでしょう。 よって、「あああ」のほうが「ああい」より小さいとされます。 「ああい」と「ああ」では、両方の先頭2文字は「ああ」ですが「ああ」の方が文字数が少ないので、「ああ」のほうが辞書の前にきます。 ですから、「ああ」のほうが「ああい」より小さいとされるのです。</p>
<p>このようにD言語の配列は、辞書で前に載るものほど小さく、後ろに載るものほど大きくなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dv">3</span>] stArr1 = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>],
       stArr2 = [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>];
<span class="dt">int</span>[<span class="dv">2</span>] stArr3 = [<span class="dv">0</span>, <span class="dv">1</span>];

writeln(stArr1 &lt; stArr2);       <span class="co">// true</span>
writeln(stArr1 &gt; stArr3);       <span class="co">// true</span>

<span class="dt">int</span>[] slice1 = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>],
      slice2 = [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>],
      slice3 = [<span class="dv">0</span>, <span class="dv">1</span>];

writeln(slice1 &lt; slice2);       <span class="co">// true</span>
writeln(slice1 &gt; slice3);       <span class="co">// true</span>

writeln(stArr1 &lt; slice2);       <span class="co">// もちろん、静的配列とスライスの比較も可能</span></code></pre>
<p>文字列の比較を行う際にも<code>int[]</code>と同じように、辞書的に大小を比較します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">string</span> str1 = <span class="st">&quot;Google&quot;</span>,
       str2 = <span class="st">&quot;Goggles&quot;</span>;

writeln(str1 &gt; str2);           <span class="co">// true</span></code></pre>
<h2 id="foreachと配列"><a href="#foreachと配列">foreachと配列</a></h2>
<p><code>foreach range</code>文というのは、すでに説明したとおり、ある範囲をループするのに使います。 今回説明するのは<code>foreach</code>文で、D言語の仕様的には<code>foreach range</code>文とは異なった文です。</p>
<p><code>foreach</code>文では、<code>foreach(&lt;elemement&gt;; &lt;array&gt;)</code>や<code>foreach(&lt;index&gt;, &lt;element&gt;; &lt;array&gt;)</code>と書くことができます。 <code>foreach</code>文は、インデックスが<code>0</code>の要素(先頭要素)から順番に処理されますが、<code>foreach_reverse</code>とした場合にはインデックスが最大の要素(最終要素)から順番に処理されていきます。 例を示しますと、以下のように使えます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test00801.d</span>
<span class="kw">import</span> std.stdio, std.string, std.array, std.typecons;

<span class="dt">void</span> main()
{
    <span class="co">// `e`はスライスの要素の値で、`foreach_reverse`なので最終要素からイテレートする</span>
    <span class="kw">foreach_reverse</span>(e; [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])
        writeln(e);


    <span class="dt">int</span>[<span class="dv">5</span>] arr = <span class="dv">10</span>;

    <span class="co">// `i`はインデックス、`e`は要素の値。もちろん、`i`は`0`から`arr.length-1`まで。</span>
    <span class="co">// `ref e`となっているので、`e`を通して`arr`の内容を書き換え可能。</span>
    <span class="co">// 逆を言えば、`ref`がついていなければ、foreach文内で`e`を通して`arr`の書き換えは不可能。</span>
    <span class="co">// また、`arr`自体をforeach文の中で書き換えるのは不正</span>
    <span class="kw">foreach</span>(i, <span class="kw">ref</span> e; arr){
        writefln(<span class="st">&quot;arr[%s] : %s&quot;</span>, i, e);
        e = i;
    }

    writeln(arr);       <span class="co">// [0, 1, 2, 3, 4]</span>


    <span class="dt">int</span>[] arr2 = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">32</span>];
    arr2[] = <span class="dv">10</span>;

    <span class="co">// `i`にも`ref`が付いているので、イテレートするインデックスを操作可能。</span>
    <span class="co">// この例の場合は、`i`は`0, 4, 8, 12, 16, 20, 24, 28`となる。</span>
    <span class="kw">foreach</span>(<span class="kw">ref</span> i, <span class="kw">ref</span> e; arr2){
        writeln(i);

        e = i;
        i += <span class="dv">3</span>;
    }

    writeln(arr2);      <span class="co">// [0, 10, 10, 10, 4, 10, 10, 10,</span>
                        <span class="co">//  8, 10, 10, 10, 12, 10, 10, 10,</span>
                        <span class="co">// 16, 10, 10, 10, 20, 10, 10, 10,</span>
                        <span class="co">// 24, 10, 10, 10, 28, 10, 10, 10]</span>
}</code></pre>
<pre><code>$ rdmd test00801.d
3
2
1
0
arr[0] : 10
arr[1] : 10
arr[2] : 10
arr[3] : 10
arr[4] : 10
[0, 1, 2, 3, 4]
0
4
8
12
16
20
24
28
[0, 10, 10, 10, 4, 10, 10, 10, 8, 10, 10, 10, 12, 10, 10, 10, 16, 10, 10, 10, 20, 10, 10, 10, 24, 10, 10, 10, 28, 10, 10, 10]</code></pre>
<p>注意しなければならないのは、<code>foreach</code>文中で、イテレート対象のスライスなどに対して要素の追加や削除を行なってはいけません。 つまり、次のコードはコンパイルは通りますが、書いてはいけないコードです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];

<span class="kw">foreach</span>(e; arr)
    arr ~= <span class="dv">1</span>;</code></pre>
<p>また、D言語の本家サイト<code>dlang.org</code>や邦訳版TDPLを読む限りでは、indexに<code>ref</code>をつけることは出来ないとなっています。 すなわち、これらに従うのであれば以下のコードはコンパイルできませんが、dmd 2.063から入った変更によって、<code>ref</code>指定できるようになっています。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];

<span class="kw">foreach</span>(<span class="kw">ref</span> i, e; arr)
    writef(<span class="st">&quot;%d &quot;</span>, ++i);       <span class="co">// 1 3 5 7 9</span>

writeln();</code></pre>
<h2 id="rangeとスライス"><a href="#rangeとスライス">Rangeとスライス</a></h2>
<p>D言語には、レンジ(Range)という概念があります。 これは、<code>std.range</code>で定義されています。 Rangeは、リストや配列などのようなデータの構造を一般化したものと言えます。</p>
<p>たとえば、スライスは<code>std.array</code>を<code>import</code>すれば、<code>arr.front</code>, <code>arr.back</code>, <code>arr.popFront()</code>, <code>arr.popBack()</code>, <code>arr.empty</code>, <code>arr.save</code>が使用でき、 インデックスで各要素へアクセス可能で、長さ(<code>.length</code>)を持っているので、<code>Random access range</code>という分類になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.array, std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span>[] arr = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];

    writeln(arr.empty);     <span class="co">// false    arrは空でない</span>
    writeln(arr.front);     <span class="co">// 0        arrの先頭要素は0</span>
    writeln(arr.back);      <span class="co">// 3        arrの最終要素は3</span>

    <span class="dt">int</span>[] arr2 = arr.save;  <span class="co">// arrをpopFront(), popBack()しても、arr2に影響はない</span>
                            <span class="co">// スライスでは、ただ単なる代入(arr2 = arr)と等価</span>

    arr.popFront();         <span class="co">// arrを一つ進める -&gt; arr = arr[1 .. $];と等価</span>
    writeln(arr);           <span class="co">// [1, 2, 3]</span>
    writeln(arr.empty);     <span class="co">// false</span>
    writeln(arr.front);     <span class="co">// 1</span>
    writeln(arr.back);      <span class="co">// 3</span>

    arr.popBack();          <span class="co">// arrの後ろを一つ縮める -&gt; arr = arr[0 .. $-1]に等価</span>
    writeln(arr);           <span class="co">// [1, 2]</span>
    writeln(arr.empty);     <span class="co">// false</span>
    writeln(arr.front);     <span class="co">// 1</span>
    writeln(arr.back);      <span class="co">// 2</span>

    arr.popFront();
    arr.popFront();
    writeln(arr);           <span class="co">// []</span>
    writeln(arr.empty);     <span class="co">// true     arrは空</span>
}</code></pre>
<p>今回はレンジについては詳しく説明しませんが、スライスはRangeという概念に沿っているので、<code>std.range</code>や<code>std.algorithm</code>などの便利な関数が使えます。 以下は<code>std.algorithm.filter</code>を使ってスライス中の偶数要素のみを抽出し、それらを<code>n</code>倍したレンジを返す関数です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm, std.range;


<span class="kw">auto</span> evenPassFilter(T, U)(T[] array, U n)
{
    <span class="kw">return</span> array.filter!<span class="st">&quot;a%2 == 0&quot;</span>()
          .zip(repeat(n))
          .map!<span class="st">&quot;a[0] * a[1]&quot;</span>();
}


<span class="dt">void</span> main()
{
    writeln([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>].evenPassFilter(<span class="fl">2.5</span>));     <span class="co">// [0, 5]</span>
}</code></pre>
<h2 id="静的配列やスライスのプロパティとメソッド"><a href="#静的配列やスライスのプロパティとメソッド">静的配列やスライスのプロパティとメソッド</a></h2>
<p>プロパティとは何か、メソッドとは何かというお話はここでは気にせず、Dの配列を高効率とするための機能を紹介します。 ちなみに、<code>array.</code>と付いているものは静的配列とスライスの両方で使え、<code>slice.</code>で始まっているものはスライスでしか使えません。</p>
<ul>
<li><code>T* array.ptr</code></li>
</ul>
<p>配列の先頭要素へのポインタ値を返します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> core.memory;

<span class="dt">int</span>* p = <span class="kw">cast</span>(<span class="dt">int</span>*)GC.malloc(<span class="dt">int</span>.<span class="dt">sizeof</span> * <span class="dv">10</span>);  <span class="co">// ヒープからint型10要素分のメモリを確保</span>
<span class="dt">int</span>[] slice = p[<span class="dv">0</span> .. <span class="dv">10</span>];                       <span class="co">// ポインタpからスライスを作成</span>

writeln(slice.<span class="dt">ptr</span> == p);                        <span class="co">// true</span>
                                                <span class="co">// スライスのポインタは、pと同じなので</span>

slice = slice[<span class="dv">1</span> .. $];
writeln(slice.<span class="dt">ptr</span> == p + <span class="dv">1</span>);                    <span class="co">// true</span>

<span class="dt">int</span>[<span class="dv">10</span>] stArray;
slice = stArray[];                              <span class="co">// 静的配列 -&gt; スライスへの変換</span>
writeln(stArray.<span class="dt">ptr</span> == slice.<span class="dt">ptr</span>);              <span class="co">// true</span>
                                                <span class="co">// 静的配列をスライスへ変換することは、</span>
                                                <span class="co">// そのスタック領域へのスライスであるということの証明</span></code></pre>
<ul>
<li><code>size_t array.length</code></li>
</ul>
<p>配列が格納している要素数を返します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] slice = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];
writeln(slice.<span class="dt">length</span>);                  <span class="co">// 10</span>

slice = slice[<span class="dv">0</span> .. <span class="dv">0</span>];
writeln(slice.<span class="dt">length</span>);                  <span class="co">// 0</span>

<span class="dt">int</span>[<span class="dv">10</span>] stArray;
writeln(stArray.<span class="dt">length</span>);                <span class="co">// 10</span>

<span class="kw">pragma</span>(msg, stArray.<span class="dt">length</span>);            <span class="co">// 10u (コンパイル時間に出力)</span>
                                        <span class="co">// 静的配列であればコンパイル時定数</span></code></pre>
<ul>
<li><code>T[] array.dup</code></li>
</ul>
<p>新しいヒープ領域を確保し、配列のコピーを作ります。結果はスライスです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] slice = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>],
      slice2 = slice.<span class="dt">dup</span>;

writeln(slice == slice2);
writeln(slice.<span class="dt">ptr</span> != slice2.<span class="dt">ptr</span>);

<span class="dt">int</span>[<span class="dv">10</span>] stArray;
<span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(stArray.<span class="dt">dup</span>));   <span class="co">// int[]  (コンパイル時に出力)</span></code></pre>
<ul>
<li><code>immutable(T)[] array.idup</code></li>
</ul>
<p>新しいヒープ領域を確保し、配列のコピーを作ります。結果の型は要素が<code>immutable</code>なスライスです。 <code>immutable</code>とは、「生まれたら最後、一生書き換えられない」という意味です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] slice = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];
<span class="kw">immutable</span>(<span class="dt">int</span>)[] slice2 = slice.<span class="dt">idup</span>;

writeln(slice == slice2);
writeln(slice.<span class="dt">ptr</span> != slice2.<span class="dt">ptr</span>);

<span class="dt">int</span>[<span class="dv">10</span>] stArray;
<span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(stArray.<span class="dt">dup</span>));   <span class="co">// int[]  (コンパイル時に出力)</span></code></pre>
<p>ちなみに、dmd 2.063から入った変更によって、<code>dup</code>でも<code>idup</code>の機能は満たせます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] slice = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];
<span class="kw">immutable</span>(<span class="dt">int</span>)[] slice2 = slice.<span class="dt">dup</span>;    <span class="co">// OK</span></code></pre>
<ul>
<li><code>T[] array.sort</code></li>
</ul>
<p>配列の要素をインプレース(その場)で昇順(小さい順)に並び替えます。 静的配列であっても、結果の型はスライスです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>];

writeln(arr.<span class="dt">sort</span>);       <span class="co">// [1, 2, 3]</span></code></pre>
<p><code>sort</code>プロパティは<a href="#仕様">廃止予定</a>なので、<code>std.algorithm.sort</code>を使うのがよいでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm;

<span class="dt">int</span>[] arr = [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>];

writeln(sort(arr));     <span class="co">// [1, 2, 3]</span>
writeln(arr);           <span class="co">// [1, 2, 3]</span>

arr.<span class="dt">sort</span>!<span class="st">&quot;a &gt; b&quot;</span>();     <span class="co">// [3, 2, 1]</span>
                        <span class="co">// 降順並び替え</span>
writeln(arr);</code></pre>
<ul>
<li><code>T[] array.reverse</code></li>
</ul>
<p>配列の要素をインプレースで反転させます。 静的配列であっても、結果の型はスライスです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];

writeln(arr.<span class="dt">reverse</span>);       <span class="co">// [3, 2, 1]</span>
writeln(arr.<span class="dt">reverse</span>);       <span class="co">// [1, 2, 3]</span></code></pre>
<p><code>sort</code>プロパティと同様に<code>reverse</code>プロパティも<a href="#仕様">廃止予定</a>なので、<code>std.algorithm.reverse</code>を使うのがよいでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm;

<span class="dt">int</span>[] arr = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];

reverse(arr);               <span class="co">// こうするか</span>
writeln(arr);

arr.<span class="dt">reverse</span>();              <span class="co">// こうする</span>
writeln(arr);</code></pre>
<ul>
<li><code>slice.capacity</code></li>
</ul>
<p>スライスへの追加を行う際に、再割当てされるかどうかを予測したい場合に活用します。 <code>slice.capacity</code>は、そのスライスが、メモリを再確保しないで、最大で何要素まで要素を持つことができるか返します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr;
writeln(arr.capacity);      <span class="co">// 0</span>

arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];
<span class="dt">int</span>* before = arr.<span class="dt">ptr</span>;

<span class="kw">foreach</span>(i; <span class="dv">0</span> .. arr.capacity - arr.<span class="dt">length</span>)
    arr ~= i;               <span class="co">// メモリの再確保は起こらない</span>

<span class="kw">assert</span>(before == arr.<span class="dt">ptr</span>);  <span class="co">// 追加前と追加後ではポインタは変わっていない</span>
                            <span class="co">// つまり、最確保されていない</span></code></pre>
<ul>
<li><code>size_t slice.reserve(size_t n)</code></li>
</ul>
<p>そのスライスが、メモリを再確保しないで、最低<code>n</code>の長さまで拡大、追加できるように、必要であれば再確保します。 返り値は、変更後の<code>slice.capacity</code>です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">5</span>];
<span class="dt">size_t</span> cap = arr.reserve(arr.<span class="dt">length</span> + <span class="dv">5</span>);   <span class="co">// あと最低でも5要素は追加可能にしておく</span>
<span class="kw">assert</span>(cap - arr.<span class="dt">length</span> &gt;= <span class="dv">5</span>);              <span class="co">//追加可能な要素は5以上</span></code></pre>
<ul>
<li><code>void slice.assumeSafeAppend()</code></li>
</ul>
<p>そのスライスが参照しているメモリの末端までそのスライスが拡張可能であるとランタイムに強制します。 気をつけて行わないと、想定外の動作を起こす可能性があります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>],
      arr2 = arr;
arr[] = <span class="dv">1</span>;
writeln(arr2);                  <span class="co">// [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span>

<span class="dt">size_t</span> cap = arr.capacity;

arr = arr[<span class="dv">0</span> .. <span class="dv">5</span>];
<span class="kw">assert</span>(arr.capacity == <span class="dv">0</span>);      <span class="co">// arrを拡大することは、arr2を破壊することにつながる</span>
                                <span class="co">// よって、capacityは0</span>

arr.assumeSafeAppend();
<span class="kw">assert</span>(arr.capacity == cap);    <span class="co">// 縮小前のcapacityと同じ</span>

arr.<span class="dt">length</span> = <span class="dv">6</span>;
writeln(arr);                   <span class="co">// [1, 1, 1, 1, 1, 0]</span>
                                <span class="co">// 新しい領域はT.initで初期化</span>
writeln(arr2);                  <span class="co">// [1, 1, 1, 1, 1, 0, 1, 1, 1, 1]</span>
                                <span class="co">// arrやarr2に代入していないのに、arr2[5]が0に書き換わっている</span>
                                <span class="co">// プログラマが意図していないメモリの書き換えになっている</span>
                                <span class="co">// つまり、assumeSafeAppendはちゃんと管理しなければ安全でない</span></code></pre>
<h2 id="多次元配列配列の配列"><a href="#多次元配列配列の配列">多次元配列(配列の配列)</a></h2>
<p>配列の配列を作成することも可能です。たとえば、<code>int[3][]</code>は、<code>int[3]</code>という静的配列のスライスです。<code>int[][][]</code>であれば、intのスライスのスライスのスライスです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dv">3</span>][] arr2d = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">3</span>][](<span class="dv">10</span>);
writeln(arr2d.<span class="dt">length</span>);          <span class="co">// 10</span>
writeln(arr2d[<span class="dv">0</span>].<span class="dt">length</span>);       <span class="co">// 3</span>

arr2d[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
writeln(arr2d[<span class="dv">0</span>]);              <span class="co">// [1, 0, 0]</span>

<span class="dt">int</span>[][][] arr3d = <span class="kw">new</span> <span class="dt">int</span>[][][](<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);

writeln(arr3d.<span class="dt">length</span>);          <span class="co">// 1</span>
writeln(arr3d[<span class="dv">0</span>].<span class="dt">length</span>);       <span class="co">// 2</span>
writeln(arr3d[<span class="dv">0</span>][<span class="dv">0</span>].<span class="dt">length</span>);    <span class="co">// 3</span></code></pre>
<h2 id="配列操作のまとめ"><a href="#配列操作のまとめ">配列操作のまとめ</a></h2>
<p>よく使用する配列操作を纏めておきます。 実際には、配列とレンジの両方を活用することで効率的なプログラムが書けます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm;
<span class="kw">import</span> std.array;

<span class="dt">void</span> main()
{
    {
        <span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">1024</span>];      <span class="co">// 宣言と初期化と確保</span>
    }
    {
        <span class="dt">int</span>[] arr;                      <span class="co">// 宣言とデフォルト初期化</span>
        arr.<span class="dt">length</span> = <span class="dv">1024</span>;              <span class="co">// 拡張</span>
    }
    
    <span class="dt">int</span>[] arr;
    arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">1024</span>];

    <span class="dt">size_t</span> n = arr.<span class="dt">length</span>;              <span class="co">// 配列の大きさの取得</span>

    n = <span class="dv">5</span>;

    <span class="kw">auto</span> e = arr[n];                    <span class="co">// インデックスによるアクセス</span>
    arr[n] = e + <span class="dv">5</span>;

    <span class="dt">int</span>* p = &amp;arr[n];                   <span class="co">// n番目の要素へのポインタ</span>
    p = arr.<span class="dt">ptr</span>;                        <span class="co">// 先頭要素へのポインタ</span>

    <span class="kw">auto</span> arr2 = arr[n .. n + <span class="dv">8</span>];        <span class="co">// 配列のn要素目から8個だけの配列を取得</span>

    arr ~= e;                           <span class="co">// 末尾に単一要素を追加</span>
    arr ~= arr2;                        <span class="co">// 末尾に他の配列を追加</span>

    arr.popBack();                      <span class="co">// 末尾の単一要素削除</span>
    arr = arr[<span class="dv">0</span> .. $ - n];              <span class="co">// 末尾のn個の要素削除</span>

    arr.insertInPlace(<span class="dv">0</span>, e);            <span class="co">// 先頭に単一要素の追加</span>
    arr = [e] ~ arr;                    <span class="co">// 同上</span>
    arr.insertInPlace(<span class="dv">0</span>, arr2);         <span class="co">// 先頭に他の配列を追加</span>
    arr = arr2 ~ arr;                   <span class="co">// 同上</span>

    arr.popFront();                     <span class="co">// 先頭の単一要素削除</span>
    arr = arr[n .. $];                  <span class="co">// 先頭のn個の要素削除</span>

    arr.insertInPlace(n, e);            <span class="co">// n番目に単一要素を追加</span>
    arr.insertInPlace(n, arr2);         <span class="co">// n番目に配列を追加</span>

    arr = arr.remove(n);                <span class="co">// n番目の単一要素を削除</span>

    <span class="kw">import</span> std.typecons;
    arr = arr.remove(tuple(n, n + <span class="dv">5</span>));  <span class="co">// n～n+4番目までの要素を削除</span>

    arr.<span class="dt">sort</span>();                         <span class="co">// 昇順ソート(std.algorithm.sort)</span>
    arr.<span class="dt">sort</span>!<span class="st">&quot;a &gt; b&quot;</span>();                 <span class="co">// 降順ソート(std.algorithm.sort)</span>

    arr.<span class="dt">sort</span>;                           <span class="co">// 昇順ソート(プロパティ)</span>

    arr.<span class="dt">reverse</span>();                      <span class="co">// 配列の反転(std.algorithm.reverse)</span>
    arr.<span class="dt">reverse</span>;                        <span class="co">// 配列の反転(プロパティ)</span>
}</code></pre>
<h2 id="問題---解答-6"><a href="#問題---解答-6">問題 -&gt; <a href="answer.md#array">解答</a></a></h2>
<ul>
<li>問1<br /><code>int</code>型の配列<code>arr</code>を適当に6要素初期化し、その内容を1要素ずつ改行して表示するプログラムを作ってください。<br />たとえば、<code>[0, 2, 4, 1, 3, 5]</code>と初期化されているなら以下のように表示すること。</li>
</ul>
<pre><code>0
2
4
1
3
5</code></pre>
<ul>
<li><p>問2<br />問2のプログラムとは逆順で表示させるようにしてください。<code>foreach</code>文を使ったなら<code>for</code>文でやってみましょう。</p></li>
<li><p>問3<br /><code>writefln</code>や<code>writef</code>のフォーマット指定は、詳細に指定可能です。たとえば、問2のプログラムであれば以下のように書けます。</p></li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span>[] arr = [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>];

    writefln(<span class="st">&quot;%(%s\n%)&quot;</span>, arr);
}</code></pre>
<p><code>%(</code>から<code>%)</code>までをサブフォーマット(Sub-format)といい、配列の1要素のフォーマット指定になります。 ただし、最終要素のみは<code>%s</code>などの書式指定子もしくは<code>%|</code>のデリミタ(区切り文字, Delimiter)の出現位置までしか表示しません。 デリミタの方が優先度が高く、たとえ前方に<code>%s</code>などの書式指定子あっても<code>%|</code>までを区切りとします。 また、<code>%|</code>以降に<code>%s</code>などの書式指定子やデリミタ<code>%|</code>を置くことはできません。 (<code>%(%|%d%)</code>や<code>%(%s%|%|%)</code>は不正なフォーマット)</p>
<p>では、各要素を<code>[001]</code>のように<code>[]</code>でくくって3桁ずつ表示するにはどうすればいいでしょうか？ ヒントとして、<code>%(-%s-%|\n%)</code>というようにデリミタ<code>%|</code>を使うことで、以下の様な出力が得られます。</p>
<pre><code>-0-
-2-
-4-
-1-
-3-
-5-</code></pre>
<ul>
<li><p>問4<br /><code>new int[10];</code>とすることで、10要素の配列を確保し、各要素にインデックス値<code>idx</code>の10倍の値<code>idx * 10</code>を格納し、表示するプログラムを書いてください。 出力のフォーマットはどのような形式でも構いません。</p></li>
<li><p>問題募集中</p></li>
</ul>
<h2 id="終わりに"><a href="#終わりに">終わりに</a></h2>
<p>配列の中でもスライスは、D言語の特徴的な機能の一つです。 スライスを使えば、本当に思った通りにプログラムが動くので、バグを起こしにくくなります。 C++での<code>vector</code>と比較すれば、使い勝手ではDのスライスが圧勝するでしょうね。 (というより、機能や概念が違うから比較すべきではないかも) 私はC言語にも、ガベージコレクタはなくても、スライスだけでも導入して欲しいと思ってます。 もちろん、ガベージコレクタがなくなっているので結合や追加はできませんが、Cでも十分綺麗なコードが書けるはずです。</p>
<p>次は文字の配列である「文字列」について解説します。 D言語の文字列は、他言語とくらべて圧倒的に操作しやすくなっています。</p>
<h2 id="キーワード-6"><a href="#キーワード-6">キーワード</a></h2>
<ul>
<li>配列(Array)</li>
<li>リスト(List)</li>
<li>要素(Element)</li>
<li>長さ(<code>arr.length</code>, <code>&amp;</code>)</li>
<li>添字(Index)</li>
<li>スタック(Stack)</li>
<li>ヒープ(Heap)</li>
<li>静的配列(<code>T[N]</code>)</li>
<li>スライス(<code>T[]</code>, 動的配列, Slice, Dynamic Array)</li>
<li>ポインタ(<code>T*</code>, Pointer)</li>
<li><code>new</code></li>
<li>結合(<code>~=</code>, <code>~</code>)</li>
<li>ガベージコレクタ(Garbage Collector, GC)</li>
<li>スライス演算子(<code>arr[]</code>, <code>arr[]</code>)</li>
<li><code>foreach</code>文</li>
<li>Range</li>
<li>多重配列</li>
</ul>
<h2 id="仕様-2"><a href="#仕様-2">仕様</a></h2>
<ul>
<li>静的配列 <a href="http://www.kmonos.net/alang/d/arrays.html#static-arrays">日本語</a> <a href="http://dlang.org/arrays.html#static-arrays">英語</a></li>
<li>動的配列(スライスのこと) <a href="http://www.kmonos.net/alang/d/arrays.html#dynamic-arrays">日本語</a> <a href="http://dlang.org/arrays.html#dynamic-arrays">英語</a></li>
<li><code>foreach</code>文 <a href="http://www.kmonos.net/alang/d/statement.html#ForeachStatement">日本語</a> <a href="http://dlang.org/statement.html#ForeachStatement">英語</a></li>
<li><code>sort</code> と <code>reverse</code> の廃止について <a href="http://dlang.org/deprecate.html#.sort%20and%20.reverse%20properties%20for%20arrays">英語</a></li>
</ul>
<h1 id="文字列"><a href="#文字列">文字列</a></h1>
<p>文字とは<code>'a'</code>とか<code>'@'</code>のことです。この文字が連なり文字列となります。 配列が操れるあなたにとってD言語の文字列操作はすごく簡単です。</p>
<h2 id="文字コード"><a href="#文字コード">文字コード</a></h2>
<p>あなたがいつもプログラムを打ち込んでいるテキストエディタはどうやって文字を区別しているでしょうか？ つまり、「文字に対してどのように値を割り当ててるのでしょうか？」ということです。 実はこれが文字型の値です。</p>
<p>実際、文字は文字コードと呼ばれる符号によって1バイトから4バイト程度まで(連結文字を含めるとそれ以上の)数値が割振られています。 文字コードにはいろいろあって、例えばASCIIやShift JIS, UTF-8, UTF-16, UTF-32などがそれです。</p>
<p>D言語では、文字がUTF-8やUTF-16, UTF-32でエンコーディングされていることを前提に設計されています。 それぞれ<code>char</code>, <code>wchar</code>, <code>dchar</code>という型に対応します。 例として、<code>'a', 'A', '@', '&amp;'</code>の文字それぞれのUTF-8での値は10進数表記で以下のようになっています。</p>
<pre><code>&#39;a&#39; =&gt; 97
&#39;A&#39; =&gt; 65
&#39;@&#39; =&gt; 64
&#39;&amp;&#39; =&gt; 38</code></pre>
<p>では、様々な文字のUTF-8, 16, 32でのエンコーディングを見てみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// example00402.d</span>
<span class="co">// このプログラムを理解する必要はありません。</span>
<span class="kw">import</span> std.stdio;
<span class="kw">import</span> std.typetuple;

<span class="dt">void</span> main()
{
    <span class="kw">foreach</span>(S; TypeTuple!(<span class="dt">string</span>, <span class="dt">wstring</span>, <span class="dt">dstring</span>)){
        S[] ss = [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;A&quot;</span>, <span class="st">&quot;@&quot;</span>, <span class="st">&quot;&amp;&quot;</span>, <span class="st">&quot;あ&quot;</span>, <span class="st">&quot;ア&quot;</span>, <span class="st">&quot;阿&quot;</span>];

        writeln(S.<span class="dt">stringof</span>);
        <span class="kw">foreach</span>(s; ss)
            writefln(<span class="st">&quot;\t&quot;`%(%s%) =&gt; %(%02X%)`</span>, [s], (<span class="kw">cast</span>(<span class="kw">immutable</span>(<span class="dt">ubyte</span>)[])s).<span class="dt">dup</span>.<span class="dt">reverse</span>);
        writeln();
    }
}</code></pre>
<pre><code>string
    &quot;a&quot; =&gt; 61
    &quot;A&quot; =&gt; 41
    &quot;@&quot; =&gt; 40
    &quot;&amp;&quot; =&gt; 26
    &quot;あ&quot; =&gt; 8281E3
    &quot;ア&quot; =&gt; A282E3
    &quot;阿&quot; =&gt; BF98E9

immutable(wchar)[]
    &quot;a&quot; =&gt; 0061
    &quot;A&quot; =&gt; 0041
    &quot;@&quot; =&gt; 0040
    &quot;&amp;&quot; =&gt; 0026
    &quot;あ&quot; =&gt; 3042
    &quot;ア&quot; =&gt; 30A2
    &quot;阿&quot; =&gt; 963F

immutable(dchar)[]
    &quot;a&quot; =&gt; 00000061
    &quot;A&quot; =&gt; 00000041
    &quot;@&quot; =&gt; 00000040
    &quot;&amp;&quot; =&gt; 00000026
    &quot;あ&quot; =&gt; 00003042
    &quot;ア&quot; =&gt; 000030A2
    &quot;阿&quot; =&gt; 0000963F</code></pre>
<p>結果を見ればわかりますが、UTF-8は最低1バイト, UTF-16は最低2バイト, UTF-32は最低4バイトになっています。 また、文字コードが可変長であることがわかりました。 UnicodeについてはTDPLがわかりやすいので参考にしましょう。</p>
<h2 id="文字リテラルと文字列リテラルと型"><a href="#文字リテラルと文字列リテラルと型">文字リテラルと文字列リテラルと型</a></h2>
<p>説明するよりも以下のコードを見たほうがわかりやすいでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">char</span> c = <span class="ch">&#39;a&#39;</span>;               <span class="co">// 文字リテラル</span>
                            <span class="co">// &#39;&#39;の中に1文字</span>

<span class="dt">wchar</span> wc = <span class="ch">&#39;あ&#39;</span>;             <span class="co">// wcharはUTF-16</span>
<span class="dt">dchar</span> dc = <span class="ch">&#39;う&#39;</span>;             <span class="co">// dcharはUTF-32</span>

<span class="dt">string</span> str = <span class="st">&quot;ふぉおお&quot;</span>;        <span class="co">// UTF-8</span>
<span class="dt">wstring</span> wstr = <span class="st">&quot;ばああ&quot;</span>;       <span class="co">// UTF-16</span>
<span class="dt">dstring</span> dstr = <span class="st">&quot;ほげええ&quot;</span>;      <span class="co">// UTF-32</span>

<span class="kw">auto</span> _str = <span class="st">&quot;foo&quot;</span>;          <span class="co">// string型</span>
<span class="kw">auto</span> _wstr = <span class="st">&quot;foo&quot;w</span>;        <span class="co">// wstring型</span>
<span class="kw">auto</span> _dstr = <span class="st">&quot;foo&quot;d</span>;        <span class="co">// dstring型</span>

str = [c];                  <span class="co">// string == immutable(char)[]なので</span>
wstr = [wc];                <span class="co">// wstring == immutable(wchar)[]なので</span>
dstr = [dc];                <span class="co">// dstring == immutable(dchar)[]なので</span>

str = <span class="st">`これも文字列リテラル(WYSIWYG: What You See Is What You Get, (訳)見たものが手に入るものである)`</span>;
wstr = <span class="st">`この中では、エスケープシーケンス(後述)は使えない`</span>;
dstr = <span class="st">r&quot;これもWYSIWYG文字列リテラルなので、エスケープシーケンスを使えない&quot;</span>;</code></pre>
<p>各文字コード間で変換するには<code>std.conv.to</code>が便利です。 <code>std.utf.toUTF8</code>, <code>std.utf.toUTF16</code>, <code>std.utf.toUTF32</code>でも同様に変換可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.conv;

<span class="dt">void</span> main()
{
    <span class="dt">string</span> str = <span class="st">&quot;ふうううう&quot;</span>;
    <span class="dt">wstring</span> wstr = str.to!<span class="dt">wstring</span>();
    <span class="dt">dstring</span> dstr = str.to!<span class="dt">dstring</span>();
    str = <span class="dt">dstring</span>.to!<span class="dt">string</span>();
}</code></pre>
<h2 id="改行文字と制御文字"><a href="#改行文字と制御文字">改行文字と制御文字</a></h2>
<p>テキストデータではどのようにして改行の情報を保持していると思いますか？</p>
<p>実は改行の情報も1文字(Windowsでは2文字)と数えられているのです。 改行文字(列)はLF(Line Feed)と呼ばれたり、CRLF(Carriage Return, Line Feed)と呼ばれます。 Windowsでは通常CRLFで表されますが、LinuxやMacではLFです。</p>
<p>LFは<code>&quot;\n&quot;</code>、CRLFは<code>&quot;\r\n&quot;</code>で表します。 <code>writeln</code>を使えば改行有りで表示しましたが、<code>write</code>を使えば改行されません。 また、<code>stdstdio.write</code>系関数ではWindowsでも<code>&quot;\n&quot;</code>は<code>&quot;\r\n&quot;</code>へと内部で変換されるので、<code>write(&quot;\n&quot;);</code>と書けば改行されます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    write(<span class="st">&quot;改行なし&quot;</span>);
    write(<span class="st">&quot;\n&quot;</span>);          <span class="co">// 改行文字の出力</span>
    write(<span class="st">&quot;改行\nあり&quot;</span>);
}</code></pre>
<pre><code>改行なし
改行
あり</code></pre>
<p>つまり文字列リテラルでは、改行したい位置に<code>\n</code>を入れておけばよいのです。 このような<code>\</code>から始まる文字列を<strong>エスケープシーケンス</strong>といい、制御文字などを表します。 文字リテラル<code>''</code>もしくは文字列リテラル<code>&quot;&quot;</code>の中でのみエスケープシーケンスは有効です。</p>
<p>代表的なエスケープシーケンスを以下に示しておきます。</p>
<pre><code>\r          =&gt; CR
\n          =&gt; LF
\t          =&gt; タブ
\\          =&gt; 文字としての`\`
\&quot;          =&gt; 文字としての`&quot;`
\&#39;          =&gt; 文字としての`&#39;`
\0          =&gt; ヌル文字
\xHH        =&gt; UTF-8の16進数表記
\uHHHH      =&gt; UTF-16の16進数表記
\UHHHHHHHH  =&gt; UTF-32の16進数表記</code></pre>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;\&quot;&quot;</span>);                  <span class="co">// &quot; &lt;- の表示</span>
    writeln(<span class="st">`&quot;\n\r\n\0\\x00`</span>);      <span class="co">// ``で囲まれた文字列リテラル内ではエスケープシーケンスは無効</span>
    writeln(<span class="st">x&quot;31 23 44&quot;</span>);           <span class="co">// &quot;\x31\x23\x44&quot;と同じ</span>
}</code></pre>
<pre><code>&quot;
&quot;\n\r\n\0\\x00
1#D</code></pre>
<h2 id="基本的な文字列操作"><a href="#基本的な文字列操作">基本的な文字列操作</a></h2>
<h3 id="文字列と配列"><a href="#文字列と配列">文字列と配列</a></h3>
<p>文字列は、「文字の列」という名前の通り文字が順番に並んだものです。 <code>string</code>, <code>wstring</code>, <code>dstring</code>は実際にはそれぞれ<code>immutable(char)[]</code>, <code>immutable(wchar)[]</code>, <code>immutable(dchar)[]</code>に付けられた別名です。 長い型を注意深く観察すれば、文字列型は文字型の配列であることがわかりますね。 つまり、文字列も<code>int[]</code>などの配列と同様に扱うことができます。</p>
<h3 id="文字列の先頭の文字を得るには"><a href="#文字列の先頭の文字を得るには">文字列の先頭の文字を得るには？</a></h3>
<p>文字列は実は配列だというのは先ほど分かりましたが、配列の先頭要素は<code>arr[0]</code>で取得できましたね。 <code>dstring</code>はそれでも問題無いのですが、<code>string</code>や<code>wstring</code>はそれではダメなのです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// example00404.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">string</span> str =   <span class="st">&quot;山田太郎&quot;</span>;
    <span class="dt">wstring</span> wstr = <span class="st">&quot;鈴木次郎&quot;w</span>;
    <span class="dt">dstring</span> dstr = <span class="st">&quot;斎藤三郎&quot;d</span>;

    writeln(str[<span class="dv">0</span>]);
    writeln(wstr[<span class="dv">0</span>]);
    writeln(dstr[<span class="dv">0</span>]);
}</code></pre>
<pre><code>$ rdmd exmaple00404.d
?
鈴
斎</code></pre>
<p>上記例では<code>string</code>のみ失敗しましたが、<code>wstring</code>に関しても<code>wstr[0]</code>が意図した通りに動くとは限りません。 通常は以下のように<code>std.array.front</code>を使います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// example00405.d</span>
<span class="kw">import</span> std.array, std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">string</span> str =   <span class="st">&quot;山田太郎&quot;</span>;
    <span class="dt">wstring</span> wstr = <span class="st">&quot;鈴木次郎&quot;w</span>;
    <span class="dt">dstring</span> dstr = <span class="st">&quot;斎藤三郎&quot;d</span>;

    writeln(str.front);
    writeln(wstr.front);
    writeln(dstr.front);
}</code></pre>
<pre><code>$ rdmd example00405.d
山
鈴
斎</code></pre>
<p>ちゃんと表示できましたね。 文字列型に対する<code>std.array.front</code>が返す値の型は<code>string</code>, <code>wstring</code>, <code>dstring</code>関係なく<code>dchar</code>型であることに注意しなければいけません。</p>
<p>あと注目して欲しいのは、<code>front(str)</code>でなくて<code>str.front</code>なことです。 これはUFCS(Uniform Function Call Syntax)といい、「関数呼び出しが<code>foo(a, b, c, ...)</code>などの場合に、<code>a.foo(b, c, ...)</code>と書ける」記法です。 また<code>foo(a)</code>はUFCSで<code>a.foo()</code>となりますが、D言語の特徴で<code>()</code>は外してもいいので<code>a.foo</code>となります。 以前は<code>a</code>が配列(<code>string</code>は配列と言いましたね)の場合だけに許された記法でしたが、dmd 2.059でUFCSとしてどのような型でも可能になりました。</p>
<p>「じゃあ、<code>front(str)</code>と書くのはいけないのか？」という話ですが、結論からいうとD言語の<strong>お作法的にダメ</strong>です。 次の項で説明する<code>popFront</code>や<code>empty</code>もUFCSを使って書くのがお作法です。 これはRangeという考え方に沿っていますが、このRangeについて説明するのはかなり後になるでしょう。</p>
<h3 id="文字目以降を得る"><a href="#文字目以降を得る">2文字目以降を得る</a></h3>
<p>山田さんの<code>&quot;山&quot;</code>だけ取得できてもそんなに嬉しくないので、<code>&quot;田&quot;</code>も取ってみたいところです。 すこし変更して、<code>&quot;田&quot;</code>以降の各文字も出力できるようにしてみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// example.d</span>
<span class="kw">import</span> std.array, std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">string</span> str = <span class="st">&quot;山田太郎&quot;</span>;

    writefln(<span class="st">&quot;%s : %s&quot;</span>, str.front, str);
    str.popFront();
    writefln(<span class="st">&quot;%s : %s&quot;</span>, str.front, str);
    str.popFront();
    writefln(<span class="st">&quot;%s : %s&quot;</span>, str.front, str);
    str.popFront();
    writefln(<span class="st">&quot;%s : %s&quot;</span>, str.front, str);

    writeln(str.empty);     <span class="co">// 文字列が空か？ =&gt; false</span>
    str.popFront();
    writeln(str.empty);     <span class="co">// 文字列が空か？ =&gt; true</span>
}</code></pre>
<pre><code>$ rdmd example.d
山 : 山田太郎
田 : 田太郎
太 : 太郎
郎 : 郎
false
true</code></pre>
<p>山田太郎さんの4文字すべて列挙できました！</p>
<p><code>std.array.popFront</code>を使えば、文字列の先頭から1文字削除することができます。 <code>front</code>の場合とは違い、<code>popFront</code>は<code>str.popFront()</code>という風に最後に<code>()</code>を付けるのがお作法です。</p>
<p><code>std.array.empty</code>を使えば文字列が空かどうか判定できます。 文字列に文字が一切含まれていないなら、この関数は<code>true</code>を返します。</p>
<h3 id="文字列からある部分を取り出す"><a href="#文字列からある部分を取り出す">文字列からある部分を取り出す</a></h3>
<p>実は<code>string</code>型の<code>&quot;山田太郎&quot;</code>から、真ん中の<code>&quot;田太&quot;</code>を抜き出すのは多少手間がかかります。 もし<code>dstring</code>型であれば、配列のスライス演算子によって<code>a[1 .. 3]</code>とできるのですが、<code>string</code>型ではそのようなことができません。 非常に残念ですね。</p>
<p>え？スライス演算子を忘れた？ そんな方は、配列の章まで戻って勉強しましょう！</p>
<p>さて話を戻して、もし<code>string</code>型に入っている文字が半角英数字だと仮定できるなら、<code>a[1 .. 3]</code>としても大丈夫です。 つまり、<code>&quot;yamada taro&quot;</code>の<code>&quot;da ta&quot;</code>を取り出すことは簡単なのです。 なぜなら、半角英数字であれば各文字は1バイト、つまり<code>string</code>の要素である<code>char</code>に収まり、「1文字 == 配列の一要素」となるからです。 マルチバイト文字と呼ばれる日本語などはUTF-8では1バイト以上で表されることは、この章の最初のほうで説明しましたね。 つまり、「1文字 == 配列の一要素」という規則は通用しません。</p>
<p>では簡単な<code>yamada taro</code>の<code>da ta</code>を取得することをしてみましょう。 <code>yamadaのd</code>は先頭から5文字目で、<code>taro</code>の<code>a</code>は先頭から9文字目です。 なので次のソースコードを動かせば<code>da ta</code>が手に入ります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">string</span> str = <span class="st">&quot;yamada taro&quot;</span>;

    writeln(str[<span class="dv">5</span>-<span class="dv">1</span> .. <span class="dv">9</span>]); <span class="co">// da ta</span>
}</code></pre>
<p><code>5-1</code>としている理由や、<code>str[5-1 .. 9]</code>はわかりますよね？ 分からない場合は、「配列の章まで戻って勉強し直しの刑」に処されるべきです</p>
<p>しかし、この方法はマルチバイト文字が使われないという保証がある場合にのみ使うべきです。 保証できない場合には、やはり<code>to!dstring</code>で<code>dstring</code>に変換するか、Rangeインターフェースを用いるのがよいでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// example.d</span>
<span class="kw">import</span> std.stdio;

<span class="kw">import</span> std.range    : take, drop;
<span class="kw">import</span> std.conv     : to;


<span class="dt">void</span> main()
{
    <span class="dt">string</span> str = <span class="st">&quot;山田太郎&quot;</span>;
    writeln(str.drop(<span class="dv">1</span>).take(<span class="dv">2</span>));       <span class="co">// 先頭から1文字削って2文字取得した文字列</span>
    writeln(str.to!<span class="dt">dstring</span>()[<span class="dv">1</span> .. <span class="dv">3</span>]);  <span class="co">// dstringに変換してからスライス演算子で取得</span>
}</code></pre>
<pre><code>$ rdmd example.d
田太
田太</code></pre>
<h3 id="文字列を結合する"><a href="#文字列を結合する">文字列を結合する</a></h3>
<p>文字列は配列なので、配列と同様に<code>a ~ b</code>という結合演算子によって結合を行います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// example.d</span>
<span class="kw">import</span> std.stdio;


<span class="dt">void</span> main()
{
    <span class="dt">string</span> str = <span class="st">&quot;foo&quot;</span>;

    writeln(str ~ str ~ str);

    str ~= str[<span class="dv">1</span> .. $] ~ str[<span class="dv">0</span> .. <span class="dv">2</span>];

    writeln(str);

    writeln(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span>);       <span class="co">// 実は、文字列リテラルの場合には結合演算子ナシで結合できる</span>
    writeln(<span class="st">`fooo`&quot;\n&quot;`bar`</span>);   <span class="co">// ``の中ではエスケープシーケンスが使えないが&quot;&quot;と併用することで使用可能</span>
}</code></pre>
<pre><code>$ rdmd example.d
foofoofoo
foooofo
foobar
fooo
bar</code></pre>
<h3 id="文字列の比較"><a href="#文字列の比較">文字列の比較</a></h3>
<p>配列の比較や順序付けは辞書順でしたので、文字列型についてもその法則が成り立ちます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="st">&quot;foo&quot;</span> == <span class="st">&quot;bar&quot;</span>      =&gt;      <span class="kw">false</span>
<span class="st">&quot;foo&quot;</span> == <span class="st">&quot;foo&quot;</span>      =&gt;      <span class="kw">false</span>
<span class="st">&quot;abc&quot;</span> &lt; <span class="st">&quot;bbc&quot;</span>       =&gt;      <span class="kw">true</span>
<span class="st">&quot;aaa&quot;</span> &lt; <span class="st">&quot;aab&quot;</span>       =&gt;      <span class="kw">true</span>
<span class="st">&quot;aaa&quot;</span> &lt; <span class="st">&quot;aaa&quot;</span>       =&gt;      <span class="kw">false</span>
<span class="st">&quot;bar&quot;</span> &gt; <span class="st">&quot;foo&quot;</span>       =&gt;      <span class="kw">false</span>
<span class="st">&quot;aaaa&quot;</span> &lt; <span class="st">&quot;aaa&quot;</span>      =&gt;      <span class="kw">false</span></code></pre>
<h3 id="boolへの変換"><a href="#boolへの変換"><code>bool</code>への変換</a></h3>
<p>配列同様に未割り当ての文字列は<code>false</code>となりますが、実際に使う場合には文字列が空かどうかを調べたいので、<code>str.length != 0</code>か、Rangeインターフェースの<code>std.array.empty</code>を使って<code>!str.empty</code>という風に文字列が空かどうかチェックするのがよいでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;
<span class="kw">import</span> std.array;


<span class="dt">void</span> main()
{
    <span class="dt">string</span> foo;

    writeln(!!foo);             <span class="co">// false</span>
                                <span class="co">// 未割り当てなので</span>

    foo = <span class="st">&quot;foo&quot;</span>;
    writeln(!!foo);             <span class="co">// true</span>
                                <span class="co">// 割り当ているので</span>

    foo = foo[<span class="dv">0</span> .. <span class="dv">0</span>];
    writeln(!!foo);             <span class="co">// true</span>
                                <span class="co">// 空でも問題なし</span>

    foo = <span class="kw">null</span>;
    writeln(!!foo);             <span class="co">// false</span>
                                <span class="co">// 未割り当て状態</span>

    foo = <span class="st">&quot;bar&quot;</span>;

    writeln(foo.empty);         <span class="co">// false</span>
                                <span class="co">// fooは空でない</span>

    writeln(foo[<span class="dv">0</span> .. <span class="dv">0</span>].empty); <span class="co">// true</span>
                                <span class="co">// [0 .. 0]なので空</span>
}</code></pre>
<h2 id="少しレベルアップした文字列操作"><a href="#少しレベルアップした文字列操作">少しレベルアップした文字列操作</a></h2>
<p>Phobosは素晴らしい機能がたくさん搭載された標準ライブラリなので、文字列もある程度簡単に行うことができます。 文字列に関する便利な関数を探す場合には、<code>std.algorithm</code>, <code>std.ascii</code>, <code>std.range</code>, <code>std.string</code>, <code>std.uni</code>, <code>std.utf</code>を覗いてみましょう。 また、正規表現(Regular Expression)という素晴らしい機能については<code>std.regex</code>を使いましょう。</p>
<p>もし、文字列からある型の値などへ変換したい場合、あるいは様々な型の値から文字列へ変換したいのであれば<code>std.conv.to</code>を使用しましょう。 <code>std.conv.to</code>は、あなたが思っている以上の変換を行ってくれるでしょう。</p>
<h2 id="問題"><a href="#問題">問題</a></h2>
<p><a href="answer.md#string">解答</a></p>
<ul>
<li><strong><em>問題1</em></strong></li>
</ul>
<p>ASCIIコードという文字を表す符号系列があります。 ASCIIコードは2進数7bit、つまりたった128文字だけしか表現できません。 しかし、英文だけを表現する場合には128文字だけで十分なのです。</p>
<p>D言語の言語仕様として、<code>char</code>型に入る文字はUTF-8でエンコードされていると仮定されると説明しましたが、実はUTF-8はASCIIコードと互換性を持っています。 つまり、ASCIIコードで表すことができる文字列はUTF-8と解釈することも可能です。 逆にUTF-8で書かれた文字列をASCIIとして読み込んだとしても、正常には表示できません。 (このような関係を「UTF-8はASCIIに対して上位互換性がある」といいます。)</p>
<p>さて、問題へ移りましょう。 あなたが行うべきことは簡単です。 ASCIIコードのうち、表示可能な文字、つまり画面上に文字として表示できるアルファベットか数字, もしくは記号の一覧をプログラムを書くことによって求めてください。</p>
<p>あなたが特殊な知識を持っていない限り、この問題を解くためにはPhobosの力が必要でしょう。 さあ、プログラムの見通しが立ったのであれば、<a href="http://dlang.org/phobos/index.html">Phobos</a>から目的の関数を探してみましょう。</p>
<ul>
<li><strong><em>問題2</em></strong></li>
</ul>
<p>標準入力から1行取得したいのであれば、<code>std.stdio.readln</code>を使うのがもっとも便利です。 しかし気をつけなければいけないのは、<code>readln</code>が返す文字列は終端に改行文字が存在することです。</p>
<p>この問題でもあなたがすべきことは問1よりも明確に理解できるでしょうが、油断してはいけません。 Phobosをあまり使ったことのないD言語初心者にとっては少し難しいかもしれません。 というのも、この問題も解くためにはPhobosのたくさんのモジュール達から適切な関数を探さなければいけないからです。</p>
<p>これからあなたに作ってもらうプログラムは、ユーザーからのたった2行の入力を処理するプログラムです。 1行目は数値、と言っても整数値で<code>int</code>型に収まる大きさとしましょう。 2行目についてはより簡単、<code>int</code>型の値を表す数値です。</p>
<p>…ええ、つまり2行とも<code>int</code>型の数値を表す文字列を要求します。 あなたは、この2行の入力に与えられた数値を<code>int</code>の数値へ変換し、その合計値を出力すればよいのです。</p>
<ul>
<li><strong><em>問題3</em></strong></li>
</ul>
<p>正規表現というのは、かの偉大なWikipediaから言葉を借りれば以下の様なものです。</p>
<blockquote>
<p>正規表現(せいきひょうげん、regular expression)とは、文字列の集合を一つの文字列で表現する方法の一つである。正則表現(せいそくひょうげん)とも呼ばれ、形式言語理論の分野では比較的こちらの訳語の方が使われる。まれに正規式と呼ばれることもある。</p>
</blockquote>
<p><a href="http://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE">Wikipedia:正規表現</a>より引用</p>
<p>つまり、正規表現というのは文字列によってある程度のパターンを持った文字列を表す方法のことです。 D言語で正規表現を使いたい場合には<code>std.regex</code>というモジュールを使います。</p>
<p>この第三問目は正規表現を使って解いてもらうわけですが、<code>std.regex</code>の使い方は説明しません。 しかし、正規表現はD言語に限らず様々な言語で実装されているのでネット上に大量に資料が転がっています。 たとえば「ruby 正規表現」とGoogleなどで検索すれば良いサイトが多数ヒットするでしょう。</p>
<p>肝心の問題ですが、以下の様な仕様です。</p>
<p>入力として文章が与えられる。 この文章中には複数の数値が書かれている。 数値のフォーマットを詳しく書けば次のリストの通りである。</p>
<ul>
<li>数値は10進数で書かれており、もちろん使用される文字は<code>0123456789</code>である。</li>
<li>負の数を表す場合には先頭に<code>-</code>をつける。また、明示的に正の数を表すために<code>+</code>を付加する可能性がある。</li>
<li>桁区切りとして<code>,</code>一文字を使用できる。区切る桁数は1桁でも2桁でも3桁でもよいが、一桁も桁を区切らないようなカンマの打ち方は禁止されている。</li>
<li>小数点として<code>.</code>を使用している。もちろん文章中に現れる数値らしき文字列1つあたりに小数点が2つ以上存在することはない。つまり、ドキュメント中に<code>1.2.3</code>のような文字列は絶対に出現しないことは保証されている。</li>
<li>小数点以下では<code>,</code>を使って桁を区切ることはない。</li>
<li>小数点以上には、1桁でも数字が無ければいけない。</li>
</ul>
<p>今回あなたがしなければいけない課題は、<strong>1行の</strong>ドキュメント中に現れるこのような数値の合計を、<strong>小数点以下3桁</strong>の精度で精確に表示することである。</p>
<p>以下に文章の例と、その場合の解を示しておく。</p>
<ul>
<li><p>例1</p>
<pre><code>foobarhogehoge123oooxxy3.1415+5-3*123,455,1,0,,123</code></pre>
<p>この場合、<code>123</code>, <code>3.1415</code>, <code>+5</code>, <code>-3</code>, <code>123,455,1,0</code>, <code>123</code>が仕様に適合する。 <code>*</code>は今回は関係なく、また<code>,,</code>は「一桁も桁を区切らないカンマの打ち方」になり、 よってその合計である<code>12345761.1415</code>から±0.001以下の精度で出力すればよい。</p></li>
<li><p>例2</p>
<pre><code>1;2;3;;4.412411:4214221.1412 +.41241</code></pre>
<p><code>1</code>, <code>2</code>, <code>3</code>, <code>4.412411</code>, <code>4214221.1412</code>, <code>41241</code>が数値であり、その合計である<code>4255472.553611</code>の±0.001以下の誤差を含んだ解が正解である。</p></li>
<li><p>例3</p>
<pre><code>+++3-4.34,23,4.5</code></pre>
<p><code>+3</code>, <code>-4.34</code>, <code>23,4.5</code>が数値であり、その合計は<code>233.16</code>である。</p></li>
<li><p>例4</p>
<pre><code>fooo1.1.1bar</code></pre>
<p>このような文章は決して現れないので、考慮しなくてよい。</p></li>
</ul>
<h2 id="おわりに-6"><a href="#おわりに-6">おわりに</a></h2>
<p>D言語の文字列操作の素晴らしさが感じれましたか？</p>
<p>最後の問題は少し難しすぎたかもしれませんが、それでもC言語で実装する場合よりも明らかにソースコードは簡単になるでしょう。 <code>std.algorithm</code>や<code>std.range</code>, <code>std.string</code>などのPhobosについてはこれから必要になればちょっとずつドキュメントを覗いてみてください。 たくさんの便利な関数や機能があなたを待っていることでしょう。</p>
<p>さて、次回は連想配列<code>Associative Array</code>について書きます。 Dの連想配列はスライスと同様に、他の言語とは違って言語組み込み機能です。お楽しみに。</p>
<h2 id="キーワード-7"><a href="#キーワード-7">キーワード</a></h2>
<ul>
<li>文字(character)</li>
<li>文字列(string)</li>
<li>文字コード
<ul>
<li>ASCII</li>
<li>Unicode; UTF-8, UTF-16, UTF-32</li>
</ul></li>
<li>改行文字</li>
<li>制御文字</li>
<li>エスケープシーケンス</li>
<li>UFCS(Uniform Function Call Syntax)</li>
<li>正規表現</li>
</ul>
<h2 id="仕様-3"><a href="#仕様-3">仕様</a></h2>
<ul>
<li>文字列リテラル <a href="http://dlang.org/lex.html#StringLiteral">英語</a> <a href="http://www.kmonos.net/alang/d/lex.html#StringLiteral">日本語</a></li>
</ul>
<h1 id="連想配列"><a href="#連想配列">連想配列</a></h1>
<h2 id="連想配列associative-arrayとは"><a href="#連想配列associative-arrayとは">連想配列(Associative Array)とは？</a></h2>
<p>連想配列は、その名前の通り、「キー(key)から、値(value)を連想する」配列です。 ちゃんと言うと、「インデックスが整数じゃなかったり、飛び飛びの値になっている配列」になります。 つまり、「文字列をインデックスとして<code>double</code>型の値を格納した連想配列」というのもできます。 連想配列では、配列でインデックスと呼ばれたものは「キー(key)」といわれます。</p>
<h2 id="基本操作"><a href="#基本操作">基本操作</a></h2>
<p>キーの型を<code>K</code>、値の型を<code>V</code>とすれば、連想配列の型は<code>V[K]</code>です。</p>
<p>百聞は一見に如かず、以下のサンプルソースコードを確認してみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// test00901.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">int</span>[<span class="dt">string</span>] aa = [<span class="st">&quot;homu&quot;</span> : <span class="dv">1</span>, <span class="st">&quot;mami&quot;</span> : <span class="dv">2</span>];

    writeln(aa[<span class="st">&quot;homu&quot;</span>]);        <span class="co">// 1</span>
    writeln(aa[<span class="st">&quot;mami&quot;</span>]);        <span class="co">// 2</span>
    <span class="co">//writeln(aa[&quot;saya&quot;]);      // core.exception.RangeError@test00901(9): Range violation</span>
                                <span class="co">// 存在しないキーにアクセスしたから、エラーが出た.</span>

    aa[<span class="st">&quot;foo&quot;</span>] = <span class="dv">12</span>;             <span class="co">// キー&quot;foo&quot;に値`12`を格納</span>
    aa[<span class="st">&quot;bar&quot;</span>] = <span class="dv">13</span>;
    writeln(aa[<span class="st">&quot;foo&quot;</span>]);         <span class="co">// 12</span>
    writeln(aa[<span class="st">&quot;bar&quot;</span>]);         <span class="co">// 13</span>

    aa[<span class="st">&quot;foo&quot;</span>] = <span class="dv">15</span>;             <span class="co">// 再度代入</span>
    writeln(aa[<span class="st">&quot;foo&quot;</span>]);         <span class="co">// 15</span>

    <span class="dt">size_t</span> len = aa.<span class="dt">length</span>;     <span class="co">// 現在格納している要素数</span>
    writeln(len);               <span class="co">// 4</span>

    <span class="dt">bool</span> b = aa.remove(<span class="st">&quot;foo&quot;</span>);  <span class="co">// &quot;foo&quot;を削除, removeはaaが&quot;foo&quot;を持っていたかどうかを返す</span>
    writeln(b);                 <span class="co">// true</span>
    len = aa.<span class="dt">length</span>;
    writeln(len);               <span class="co">// 3</span>

    aa = <span class="kw">null</span>;                  <span class="co">// nullを代入すると、初期化される</span>
    len = aa.<span class="dt">length</span>;
    writeln(len);               <span class="co">// 0</span>

    <span class="kw">auto</span> aa2 = aa;              <span class="co">// 連想配列は「凄いポインタ」なので、代入はポインタ値の代入に等しい</span>
    aa2[<span class="st">&quot;home&quot;</span>] = <span class="dv">2</span>;            <span class="co">// aa2の&quot;home&quot;の書き換え</span>
    writeln(aa[<span class="st">&quot;home&quot;</span>]);        <span class="co">// 2</span>
                                <span class="co">// aaも書き換わる</span>

    aa2[<span class="st">&quot;mado&quot;</span>] = <span class="dv">100</span>;          <span class="co">// aa2に&quot;mado&quot;を追加</span>
    writeln(aa[<span class="st">&quot;mado&quot;</span>]);        <span class="co">// 100</span>
                                <span class="co">// aaにも&quot;mado&quot;が追加されている</span>
}</code></pre>
<p>文章で説明する必要はないと思いますが、連想配列リテラルは<code>[&lt;key0&gt;: &lt;value0&gt;, &lt;key1&gt;:&lt;value1&gt;, ...]</code>というように書きます。 また、キーを指定して値の左辺値を得る方法は、<code>&lt;aa&gt;[&lt;key&gt;]</code>です。</p>
<p>ある一組のキーと値を、連想配列から取り除きたい場合には、<code>&lt;aa&gt;.remove(&lt;key&gt;)</code>とします。 また、全要素削除したいなら、<code>null</code>を代入します。</p>
<p>連想配列について注意しなければいけないのは、実際には「凄いポインタ」であるということです。 つまり、代入したとしても、凄いポインタなので、ポインタ値が代入されるだけで全く同じ連想配列を指しています。</p>
<h3 id="in演算子"><a href="#in演算子">in演算子</a></h3>
<p>たとえば、連想配列<code>aa</code>が、キー<code>key</code>の要素を持っているかどうかわからない状況があります。 そのような場合に、連想配列が実際にそのキーを持っているか確認する方法が、<code>in</code>演算子です。</p>
<p><code>in</code>演算子は、2項演算子で、<code>&lt;key&gt; in &lt;aa&gt;</code>という形式になります。 間違いやすいのは、キーと連想配列の位置ですが、英文的に考えれば自然的でしょう 。</p>
<p><code>in</code>演算子の結果は、値へのポインタ<code>V*</code>です。 もし、連想配列にそのキーがなければ<code>null</code>を返しますが、ある場合にはそのキーに対応する値へのポインタになります。</p>
<p><code>&lt;key&gt; !in &lt;aa&gt;</code>とすれば、連想配列にそのキーがない場合に<code>true</code>となり、ある場合には<code>false</code>となります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// test00902.d</span>
<span class="kw">import</span> std.stdio;
<span class="kw">import</span> std.exception : enforce;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                     <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];

    <span class="co">// if文と組み合わせて使うと便利</span>
    <span class="kw">if</span>(<span class="kw">auto</span> p = <span class="st">&quot;mami&quot;</span> <span class="kw">in</span> madoMagi)             <span class="co">// false</span>
        writefln(<span class="st">&quot;マミさん(%s)は生きています。&quot;</span>, *p);
    <span class="kw">else</span>
        writeln(<span class="st">&quot;マミさんは、マミられたようです&quot;</span>);

    madoMagi.remove(<span class="st">&quot;saya&quot;</span>);


    <span class="kw">if</span>(<span class="st">&quot;saya&quot;</span> !<span class="kw">in</span> madoMagi)                     <span class="co">// true</span>
        writeln(<span class="st">&quot;さやかちゃんは魔女化したようです&quot;</span>);
}</code></pre>
<h3 id="同値テスト-is"><a href="#同値テスト-is">同値テスト(<code>==</code>, <code>is</code>)</a></h3>
<p>2つの連想配列が等しい<code>==</code>とは、2つの連想配列のキーがすべて等しく、その対応する値がお互いに等しい場合にいいます。 また、2つの連想配列が全く同じ連想配列を指しているなら、<code>a is b</code>は<code>true</code>となります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> aa1 = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>, <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];
<span class="kw">auto</span> aa2 = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>, <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];

writeln(aa1 == aa2);            <span class="co">// true</span>
writeln(aa1 <span class="kw">is</span> aa2);            <span class="co">// false</span>

aa1[<span class="st">&quot;mami&quot;</span>] = <span class="dv">5</span>;
writeln(aa1 != aa2);            <span class="co">// true</span>

aa1 = aa2;
writeln(aa1 <span class="kw">is</span> aa2);            <span class="co">// true</span></code></pre>
<h2 id="プロパティ"><a href="#プロパティ">プロパティ</a></h2>
<h3 id="size_t-aa.length"><a href="#size_t-aa.length"><code>size_t aa.length</code></a></h3>
<p>その連想配列が持つ要素の数を返します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dt">int</span>] aa = [<span class="dv">0</span>:<span class="dv">0</span>, <span class="dv">1</span>:<span class="dv">1</span>, <span class="dv">2</span>:<span class="dv">2</span>];

writeln(aa.<span class="dt">length</span>);         <span class="co">// 3</span></code></pre>
<h3 id="vk-aa.dup"><a href="#vk-aa.dup"><code>V[K] aa.dup</code></a></h3>
<p>配列に対する<code>dup</code>同様に、新しい連想配列にすべてコピーし、返します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dt">int</span>] aa = [<span class="dv">0</span>:<span class="dv">0</span>, <span class="dv">1</span>:<span class="dv">1</span>, <span class="dv">2</span>:<span class="dv">2</span>];
<span class="kw">auto</span> aa2 = aa;

aa2[<span class="dv">0</span>] = <span class="dv">12</span>;
writeln(aa);                <span class="co">// 12</span>
                            <span class="co">// aa2を書き換えると、aa3も書き換わってしまう</span>

aa2 = aa.<span class="dt">dup</span>;

aa2[<span class="dv">0</span>] = <span class="dv">13</span>;
writeln(aa[<span class="dv">0</span>]);             <span class="co">// 12</span>
                            <span class="co">// aa2を書き換えても、aaには影響はない</span></code></pre>
<h3 id="v-aa.getk-key-lazy-v-defvalue"><a href="#v-aa.getk-key-lazy-v-defvalue"><code>V aa.get(K key, lazy V defValue)</code></a></h3>
<p><code>aa</code>の<code>key</code>の要素を返します。 <code>aa[key]</code>とは違い、もし<code>key</code>が<code>aa</code>に無ければ<code>defValue</code>を返します。 また、返されるのは右辺値なので、その値を通しての書き換えは不可能です。 <code>defValue</code>は、<code>key</code>が<code>aa</code>にない場合にのみ評価されます。 (<code>lazy</code>は遅延評価を表し、式の評価を遅らせることを意味します。)</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[<span class="dt">int</span>] aa = [<span class="dv">0</span>:<span class="dv">0</span>, <span class="dv">1</span>:<span class="dv">1</span>, <span class="dv">2</span>:<span class="dv">2</span>];

writeln(aa.get(<span class="dv">0</span>, -<span class="dv">1</span>));         <span class="co">// 0</span>

writeln(aa.get(<span class="dv">10</span>, -<span class="dv">1</span>));        <span class="co">// -1</span></code></pre>
<h3 id="k-aa.keys"><a href="#k-aa.keys"><code>K[] aa.keys</code></a></h3>
<p>連想配列が持つ、キーすべてをスライスにして返します。 キーの並び順は予測不能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];

writeln(madoMagi.<span class="dt">keys</span>);
    <span class="co">// [&quot;homu&quot;, &quot;saya&quot;, &quot;mado&quot;, &quot;anko&quot;]</span>
    <span class="co">// 実際に必ずこのような順番になるかはわからない</span></code></pre>
<h3 id="v-aa.values"><a href="#v-aa.values"><code>V[] aa.values</code></a></h3>
<p>連想配列が持つ値すべてをスライスにして返します。 <code>.keys</code>同様に、並び順は予測不能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];

writeln(madoMagi.<span class="dt">values</span>);
    <span class="co">// [2, 3, 1, 4]</span>
    <span class="co">// 実際に必ずこのような順番になるかはわからない</span></code></pre>
<h3 id="auto-aa.bykey"><a href="#auto-aa.bykey"><code>auto aa.byKey</code></a></h3>
<p>連想配列が持つキーをすべて、レンジ(<code>Input Range</code>)にして返します。 もちろん、並び順は予測不能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];

<span class="kw">auto</span> keyRng = madoMagi.byKey;
<span class="co">//keyRng.front = &quot;majo&quot;;        // .frontは左辺値を返すので経由で書き換え可能だが、</span>
                                <span class="co">// 危険なので書き換えてはいけない。</span>

writeln(keyRng);                <span class="co">// [&quot;homu&quot;, &quot;saya&quot;, &quot;mado&quot;, &quot;anko&quot;]</span></code></pre>
<h3 id="auto-aa.byvalue"><a href="#auto-aa.byvalue"><code>auto aa.byValue</code></a></h3>
<p>連想配列が持つキーをすべて、レンジ(<code>Input Range</code>)にして返します。 何度もいいますが、並び順は予測不能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];

writeln(madoMagi.byValue);      <span class="co">// [2, 3, 1, 4]</span>
    <span class="co">// [&quot;homu&quot;, &quot;saya&quot;, &quot;mado&quot;, &quot;anko&quot;]</span>
    <span class="co">// 実際に必ずこのような順番になるかはわからない</span>

<span class="kw">auto</span> valueRng = madoMagi.byValue;
valueRng.front = <span class="dv">100</span>;

valueRng.popFront();
valueRng.front = <span class="dv">100</span>;           <span class="co">// これは、.byKeysとは違いOK</span>

writeln(madoMagi);              <span class="co">// [&quot;homu&quot;:100, &quot;saya&quot;:100, &quot;mado&quot;:1, &quot;anko&quot;:4]</span></code></pre>
<h3 id="vk-aa.rehash"><a href="#vk-aa.rehash"><code>V[K] aa.rehash()</code></a></h3>
<p>詳しくは「ハッシュ」の節で説明しますが、連想配列の各要素に高速にアクセス可能なようにします。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>];

writeln(madoMagi);  <span class="co">// [&quot;homu&quot;:2, &quot;saya&quot;:3, &quot;mado&quot;:1, &quot;anko&quot;:4]</span>

madoMagi.<span class="dt">rehash</span>();

writeln(madoMagi);  <span class="co">// [&quot;homu&quot;:2, &quot;saya&quot;:3, &quot;anko&quot;:4, &quot;mado&quot;:1]</span>
                    <span class="co">// 最適化されたので、並び順が上と異なっている！</span></code></pre>
<h2 id="foreach"><a href="#foreach">foreach</a></h2>
<p>連想配列は、さまざまな方法を使って<code>foreach</code>で回すことができます。</p>
<h3 id="ベーシックな方法"><a href="#ベーシックな方法">ベーシックな方法</a></h3>
<p>もっとも基本的な方法は、<code>foreach(key, value; aa)</code>とすることです。 <code>value</code>の方は<code>ref</code>をつけて参照(書き換え可能)にできますが、<code>key</code>を<code>ref</code>にすると危険なので、できません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>, <span class="st">&quot;mami&quot;</span>: <span class="dv">5</span>];

<span class="kw">foreach</span>(k, v; madoMagi)
    writefln(<span class="st">&quot;%s : %s&quot;</span>, k, v);

writeln();

<span class="kw">foreach</span>(k, <span class="kw">ref</span> v; madoMagi)
    v = <span class="dv">100</span>;

writefln(<span class="st">&quot;%-(%s : %s%|\n%)&quot;</span>, madoMagi);

<span class="co">/* 実行結果</span>
<span class="co">homu : 2</span>
<span class="co">saya : 3</span>
<span class="co">mado : 1</span>
<span class="co">anko : 4</span>
<span class="co">mami : 5</span>

<span class="co">homu : 100</span>
<span class="co">saya : 100</span>
<span class="co">mado : 100</span>
<span class="co">anko : 100</span>
<span class="co">mami : 100</span>
<span class="co">*/</span></code></pre>
<h3 id="aa.keysを使った方法"><a href="#aa.keysを使った方法"><code>aa.keys</code>を使った方法</a></h3>
<p><code>aa.keys</code>はキーのスライスを返すので、そのスライスを<code>foreach</code>でたどれば良いのです。 ただし、新たに領域が確保されてしまいます。 先ほどの例と同じ動作をするものを<code>.keys</code>で書くと、以下のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>, <span class="st">&quot;mami&quot;</span>: <span class="dv">5</span>];

<span class="kw">foreach</span>(k; madoMagi.<span class="dt">keys</span>)
    writefln(<span class="st">&quot;%s : %s&quot;</span>, k, madoMagi[k]);

writeln();

<span class="kw">foreach</span>(k; madoMagi.<span class="dt">keys</span>)
    madoMagi[k] = <span class="dv">100</span>;

writefln(<span class="st">&quot;%-(%s : %s%|\n%)&quot;</span>, madoMagi);</code></pre>
<h3 id="aa.bykeyを使った場合"><a href="#aa.bykeyを使った場合"><code>aa.byKey</code>を使った場合</a></h3>
<p><code>aa.byKey</code>は、キーを要素とするレンジなので、<code>.keys</code>同様に使えますが、新たな領域が確保されません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>, <span class="st">&quot;mami&quot;</span>: <span class="dv">5</span>];

<span class="kw">foreach</span>(k; madoMagi.byKey)
    writefln(<span class="st">&quot;%s : %s&quot;</span>, k, madoMagi[k]);

writeln();

<span class="kw">foreach</span>(k; madoMagi.byKey)
    madoMagi[k] = <span class="dv">100</span>;

writefln(<span class="st">&quot;%-(%s : %s%|\n%)&quot;</span>, madoMagi);</code></pre>
<h3 id="aa.valuesを使った場合"><a href="#aa.valuesを使った場合"><code>aa.values</code>を使った場合</a></h3>
<p>もしキーの値が要らないのであれば、<code>.values</code>を使うことで値だけイテレートできます。 <code>.keys</code>同様に、新しく領域が確保されます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>, <span class="st">&quot;mami&quot;</span>: <span class="dv">5</span>];

<span class="kw">foreach</span>(v; madoMagi.<span class="dt">values</span>)
    writeln(v);</code></pre>
<h3 id="aa.byvalueを使った場合"><a href="#aa.byvalueを使った場合"><code>aa.byValue()</code>を使った場合</a></h3>
<p><code>.values</code>同様に値のみでイテレートできますが、<code>.byValue</code>経由だと値の変更ができ、レンジなので新しく領域が確保されません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                 <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>, <span class="st">&quot;mami&quot;</span>: <span class="dv">5</span>];

<span class="kw">foreach</span>(v; madoMagi.byValue)
    writeln(v);

writeln();

<span class="kw">foreach</span>(<span class="kw">ref</span> v; madoMagi.byValue)
    v = <span class="dv">100</span>;

writefln(<span class="st">&quot;%-(%s : %s%|\n%)&quot;</span>, madoMagi);</code></pre>
<h2 id="クラスをキーとして使うには高度"><a href="#クラスをキーとして使うには高度">クラスをキーとして使うには(高度)</a></h2>
<p>連想配列のキーとしてクラスを使うには、クラスに次のメソッドを定義する必要があります。 <code>hash_t</code>は<code>size_t</code>の<code>alias</code>です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">hash_t</span> toHash()
<span class="dt">bool</span> opEquals(<span class="dt">Object</span>)
<span class="dt">int</span> opCmp(<span class="dt">Object</span>)</code></pre>
<p>構造体や共用体については、これらはデフォルトではバイナリから算出されます。 しかし、これらをプログラマが定義すると、プログラマ定義の方式でハッシュ, 比較されます。</p>
<h2 id="問題---解答-7"><a href="#問題---解答-7">問題 -&gt; <a href="answer.md#associative_array">解答</a></a></h2>
<ul>
<li>問題1</li>
</ul>
<p>入力として、人の名前とある数字がN行与えられる。先頭行はNがいくらかを示している。人名が重なることはなく、数字は重なっている可能性がある。たとえば、以下のように。</p>
<pre><code>11
kotoge      92
usagi       81
keika       25
uchizono    59
ayakura     18
shihori     33
sakagami    13
kasiwagi    13
takahashi   25
nakamura    11
fuzimiya    89</code></pre>
<p>このようなリストが与えられた場合に、名前をアルファベットでソートした順番(五十音順ではない)で数字も一緒に出力するようなプログラムを作成してください。<br />参考として、例のリストが入力された場合の正しい出力を以下に示しておきます。 この出力例でのフォーマットは<code>writefln(&quot;%-12s\t\t%s&quot;, name, value);</code>となっていますが、異なったフォーマットでも構いません。</p>
<pre><code>ayakura                 18
fuzimiya                89
kasiwagi                13
keika                   25
kotoge                  92
nakamura                11
sakagami                13
shihori                 33
takahashi               25
uchizono                59
usagi                   81</code></pre>
<ul>
<li>問題2</li>
</ul>
<p>問題1では、アルファベット順でしたが、今度は数字の順番で並べてみましょう。もし、同じ数字に複数人いる場合には、その中でもアルファベット順で出力してください。 つまり、例に対する出力は以下のようになります。<br />(ヒント: 数字ごとに人名リストを作る<code>string[][int]</code>という連想配列に格納してみると…)</p>
<pre><code>nakamura                11
kasiwagi                13
sakagami                13
ayakura                 18
keika                   25
takahashi               25
shihori                 33
uchizono                59
usagi                   81
fuzimiya                89
kotoge                  92</code></pre>
<h2 id="おわりに-7"><a href="#おわりに-7">おわりに</a></h2>
<p>連想配列は、配列よりもコストが大きいですが、その分様々な局面で活躍してくれるすごい機能です。 特にDの連想配列は、言語組込みという利点があり、<code>in</code>演算子や<code>dup</code>などのすごい機能が簡単に書けてしまいます。</p>
<p>さて、次回は今までよく出てきたポインタについて再学習します。</p>
<h2 id="キーワード-8"><a href="#キーワード-8">キーワード</a></h2>
<ul>
<li>連想配列(Associative Array)</li>
<li>キー(Key)</li>
<li>値(Value)</li>
<li><code>in</code></li>
<li><code>.length</code></li>
<li><code>.dup</code></li>
<li><code>.get(K key, lazy V defValue)</code></li>
<li><code>.keys</code></li>
<li><code>.values</code></li>
<li><code>.byKey</code></li>
<li><code>.byValue</code></li>
<li>ハッシュ(Hash)</li>
</ul>
<h2 id="仕様-4"><a href="#仕様-4">仕様</a></h2>
<p><a href="http://dlang.org/hash-map.html">英語</a> <a href="http://www.kmonos.net/alang/d/hash-map.html">日本語</a></p>
<h1 id="ポインタ"><a href="#ポインタ">ポインタ</a></h1>
<h2 id="ポインタとは復習"><a href="#ポインタとは復習">ポインタとは(復習)</a></h2>
<p>これまでの記事でポインタは何回も出てきたので、ここまで読み進めた方にはわかると思いますが、ポインタとは「メモリ上でのアドレス」です。</p>
<h3 id="アドレスってなんやねん"><a href="#アドレスってなんやねん">アドレスってなんやねん！</a></h3>
<p>メモリには1バイトごとにアドレスが振り分けられています。 たとえば、32bitのシステムですと、アドレスが<code>0x00000000 ~ 0xFFFFFFFF</code>の<code>2^^32</code>個しかないので、1バイトごとにアドレスを割り振れば<code>2^^32</code>バイト(大体4GB, 丁度4GiB)のメモリが使用可能です。 これが64bitのシステムだと、アドレスが<code>0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF</code>の<code>2^^64</code>個もあるので、1バイトごとだと<code>2^^64</code>バイト(大体16EB, 丁度16EiB)もメモリ空間が広がっています。</p>
<p>アドレスがある理由は、よく配達業に例えられるのですが、配達したいものがあっても配達先の住所がなければ配達できない、ということです。IPアドレスとか、URLとかと存在理由は同じですね。</p>
<h3 id="アドレスとポインタってなにがどうやねん"><a href="#アドレスとポインタってなにがどうやねん">アドレスとポインタってなにがどうやねん！</a></h3>
<p>「ポインタ型の値」に格納されている値が「メモリ上でのアドレス」です。 (正確に言えば、ポインタ変数の用途によるので、「ポインタ型の値に格納されている値は、メモリ上でのアドレスと期待しても良い」が正しいのでしょう)</p>
<p>D言語では、ポインタの値はアドレス値に等しいので、ポインタとメモリ上でのアドレスは等しいと考えても構いません。</p>
<h3 id="変数のアドレスってどこやねん"><a href="#変数のアドレスってどこやねん">変数のアドレスってどこやねん！</a></h3>
<p>変数(左辺値)のポインタは<code>&amp;a</code>で取得できますし、配列の先頭要素へのポインタは<code>arr.ptr</code>もしくは<code>&amp;a[0]</code>で得れますね。 連想配列では<code>key in aa</code>とすることで、連想配列にキーがあるかどうか調べることと、そのキーへのポインタを返すことができました。</p>
<p>さて、変数のアドレス、つまりメモリ上での位置はどのあたりでしょうか？ 正確に言えることは、「<code>null</code>ではないが、実行してみない限り分からない」ことです。 ここで重要なのは、実体(instance)を指すポインタは必ず<code>null</code>ではなく、逆に実態のないものを指すポインタは必ず<code>null</code>ですし、<code>null</code>にしなければいけません。</p>
<p>つまり、ポインタが<code>null</code>であるかどうか調べることで、ポインタが参照する先に実体があるかどうか確認できます。 この仕組みを使ったのが、連想配列での<code>key in aa</code>なのです。</p>
<h2 id="ポインタの使い方"><a href="#ポインタの使い方">ポインタの使い方</a></h2>
<p>この章では今までより一歩踏み込んで、ポインタに対する演算や、ポインタの使い方について説明します。 ただし、D言語的な書き方をしている限りは、ポインタに出くわすことはないので、参考程度に捉えてください。</p>
<h3 id="ポインタと配列とインデックス演算子とポインタへの加算"><a href="#ポインタと配列とインデックス演算子とポインタへの加算">ポインタと配列とインデックス演算子とポインタへの加算</a></h3>
<p>配列の先頭要素へのポインタは<code>arr.ptr</code>であり、<code>n</code>要素目へのポインタは<code>&amp;(arr[n])</code>と書けます。 同様に、<code>arr.ptr + n</code>も<code>n</code>要素目へのポインタですし、<code>&amp;(arr.ptr[n])</code>も<code>n</code>要素目へのポインタになります。</p>
<p>つまり、ポインタ<code>p</code>と整数<code>n</code>に対して、<code>p + n</code>は、<code>p[n]</code>へのポインタを示します。 このように、ポインタは加算や減算はもちろん、インクリメントとデクリメントもできます。</p>
<p>加算や減算の場合、<code>p + n</code>はポインタ<code>p</code>を<code>n * typeof(*p).sizeof</code>だけ進めます。 つまり、<code>int* p</code>に対して<code>p + 3</code>はpから12バイト(3 * 4バイト)先のintを指すことになります。 よって、<code>p[n] == *(p + n)</code>なのです。</p>
<h3 id="ポインタと左辺値"><a href="#ポインタと左辺値">ポインタと左辺値</a></h3>
<p>左辺値からは<code>&amp;lvalue</code>によってポインタを得ることができますし、<code>*p</code>とすればポインタから左辺値が得られます。 D言語では、C++の<code>int&amp;</code>というような左辺値を参照する変数を定義できないので、代わりに、ポインタやクラスを使うことになります。 (関数の引数については例外で、参照で受け取ることが可能)</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> a = <span class="dv">2</span>,
    b = <span class="dv">3</span>;

<span class="dt">int</span>* p = a &lt; b ? &amp;a : &amp;b;

*p = <span class="dv">10</span>;                <span class="co">// a = 10と同じ</span>

writeln(a);             <span class="co">// 10</span>
writeln(b);             <span class="co">// 3</span></code></pre>
<h3 id="ポインタの初期値とゼロ値"><a href="#ポインタの初期値とゼロ値">ポインタの初期値とゼロ値</a></h3>
<p>ポインタの初期値<code>(T*).init</code>は<code>null</code>という値です。 <code>null</code>の性質として、<code>null</code>は<code>true</code>か<code>false</code>かでいうと、<code>false</code>になり、<code>null</code>でないポインタは<code>true</code>です。 また、<code>null</code>なポインタを通してアクセスしようとすると、例外(いわゆる「ぬるぽ」)が発生します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>* p;
writeln(p);             <span class="co">// null</span>

<span class="kw">if</span>(!p)                  <span class="co">// !p は true</span>
    writeln(<span class="st">&quot;ぬるぽ&quot;</span>);

*p = <span class="dv">10</span>;                <span class="co">// 例外(いわゆる「ぬるぽ」)</span>

<span class="co">/*  以下は例外の内容</span>
<span class="co">object.Error: Access Violation</span>
<span class="co">----------------</span>
<span class="co">0x00402021 in _imp__LeaveCriticalSection</span>
<span class="co">0x0040947C in _NULL_IMPORT_DESCRIPTOR</span>
<span class="co">0x004094B7 in _NULL_IMPORT_DESCRIPTOR</span>
<span class="co">0x004090B5 in _NULL_IMPORT_DESCRIPTOR</span>
<span class="co">*/</span></code></pre>
<h3 id="特別なポインタvoidとスライスvoid"><a href="#特別なポインタvoidとスライスvoid">特別なポインタ<code>void*</code>とスライス<code>void[]</code></a></h3>
<p>すべてのポインタは<code>void*</code>というポインタ型に暗黙変換可能です。 <code>void*</code>は特別なポインタであり、<code>*p</code>や<code>p[0]</code>という風に参照先の値にアクセスできません。 <code>void*</code>型は、アドレスを指定しているだけで、実際にどのような型の値を取得するかわからないからです。 よって、アクセスする際にはキャストで違うポインタへ変換する必要があります。</p>
<p>スライス<code>void[]</code>も全てのスライスから暗黙変換可能で、長さはスライスが所有しているバイト数になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];

<span class="dt">void</span>* p = a.<span class="dt">ptr</span>;
<span class="co">//writeln(*p);                  Error: expression *p is void and has no value</span>
<span class="co">//writeln(p[0]);                Error: (略)</span>

<span class="dt">void</span>[] slice = a;
<span class="co">//writeln(slice[0]);            Error: (略)</span>
writeln(slice);                 <span class="co">// [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]</span>
                                <span class="co">// リトルエンディアン</span>

writeln(*<span class="kw">cast</span>(<span class="dt">int</span>*)p);          <span class="co">// 1</span>
writeln((<span class="kw">cast</span>(<span class="dt">int</span>[])slice));    <span class="co">// [1, 2, 3]</span></code></pre>
<h2 id="おわりに-8"><a href="#おわりに-8">おわりに</a></h2>
<p>さて、ポインタが終わってしまいました。 D言語ではポインタはそれほど出てこないので、重要度はかなり低い方です。 ただ、クラスやデリゲート、関数ポインタ、連想配列、配列はポインタのすごいバージョンとも捉えられますし、ポインタを知っていると参照型は理解しやすいかと思います。</p>
<h1 id="関数"><a href="#関数">関数</a></h1>
<h2 id="関数とは"><a href="#関数とは">関数とは？</a></h2>
<p><b>関数</b>(function)は、</p>
<ol type="1">
<li>データを受け取って、</li>
<li>データの加工や、何か処理を行い、</li>
<li>結果を返す</li>
</ol>
<p>ものです。</p>
<p>関数が受け取るデータのことを、<b>引数</b>(argument)といい、 関数が返す結果を<b>返り値</b>または<b>戻り値</b>(return value)といいます。</p>
<p>数学での関数<code>f(x, y, z, ...)</code>は、引数が同じであれば、常に同じ結果を返します。 しかし、プログラムの関数はそうではありません。</p>
<p>プログラムの関数では、同じ引数が与えられたとしても、外界の状態によっては計算結果が変わるからです。 たとえば、「コンソールで入力された数を<code>int</code>型で返す」関数<code>readInt</code>があったとします。 その関数は「何も受け取らず、ただ<code>int</code>型を返すような関数」だと定義できます。 この関数の返す値は人間がコンソールに入れる値に左右されます。</p>
<h3 id="関数による処理のまとめ"><a href="#関数による処理のまとめ">関数による処理のまとめ</a></h3>
<p>頻繁に使う処理をまとめて関数にしておくことによってソースコードの可読性やメンテナンス性が向上します。 たとえば、もし、配列の総和を返す関数<code>sum</code>が定義されているなら、総和を計算する箇所では<code>foreach</code>文の代わりに<code>sum</code>関数を使って書くことができます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// before: sumを使わない</span>
{
    <span class="dt">int</span> s;              <span class="co">// 合計</span>

    <span class="kw">foreach</span>(e; arr1)
        s += e;


    <span class="dt">int</span> av;             <span class="co">// 平均</span>

    <span class="kw">foreach</span>(e; arr2)
        av += e;

    av /= arr2.<span class="dt">length</span>;
}


<span class="co">// after: sumを使う</span>
{
    <span class="dt">int</span> s = sum(arr1),
        av = sum(arr2) / arr2.<span class="dt">length</span>;
}</code></pre>
<p>もし、プログラミング言語に関数という機能がないとしたら、プログラミングという作業は非常につらい作業になったことでしょう。 もしくは、ユーザーは関数を定義できない言語だとしたら、あなたはプログラムを書くことを辞めたくなるはずです。 それほど、関数が行う処理の「隠蔽」と「まとめ」は重要なのです。</p>
<h2 id="関数の基礎"><a href="#関数の基礎">関数の基礎</a></h2>
<h3 id="宣言の書き方と関数本体"><a href="#宣言の書き方と関数本体">宣言の書き方と関数本体</a></h3>
<p>D言語では、引数リスト<code>ParameterList</code>を受け取り、<code>ReturnType</code>を返す関数を以下のように書きます。 この基本の構文は、C言語やC++などの言語と同じ構文です。</p>
<pre class="sourceCode d"><code class="sourceCode d">ReturnType functionName(ParameterList)
{
    FunctionBody
}</code></pre>
<p><b>関数本体</b>(<code>FunctionBody</code>)は省略して、<b>関数プロトタイプ</b>のみにすることができます。 その場合には、<code>{FunctionBody}</code>の代わりに<code>;</code>を付けておきます。</p>
<pre class="sourceCode d"><code class="sourceCode d">ReturnType functionName(ParameterList);</code></pre>
<p>たとえば、<code>int</code>型の値を2つ受け取って、それらの和を返す関数<code>addInt</code>は、次のように書きます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> addInt(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
    <span class="kw">return</span> a + b;
}</code></pre>
<p><code>return</code>文は<code>return &lt;expr&gt;;</code>という形式をとり、機能は「<code>&lt;expr&gt;</code>を返し、処理を呼び出し元に復帰する文」です。 簡単にいえば、呼び出し元に結果を返してから、その関数を即座に終了させる効果があります。 返り値がある関数では、必ず<code>return</code>で値を返して関数を終了させます。</p>
<p>もちろん<code>return</code>文は、次のように関数の任意の場所に書くことができます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> foo(<span class="dt">int</span> a)
{
    <span class="kw">if</span>(a)
        <span class="kw">while</span>(a)
            <span class="kw">do</span>
                <span class="kw">return</span> a;
            <span class="kw">while</span>(a);

    <span class="kw">return</span> a;
}</code></pre>
<p><a href="#Q1">Goto: 問題1 「readIntを実装しよう」</a><br /><a href="#Q2">Goto: 問題2 「sumを実装しよう」</a></p>
<p>関数のすべての条件分岐や最後に<code>return</code>が無ければ、コンパイルエラーとなります。 ということは、関数内の絶対に到達し得ない場所にも<code>return</code>が必要である、ということになります。 なぜなら、コンパイラでは「絶対に到達し得ない場所」という判断が行えず、また絶対に<code>return</code>しなければ、その関数が値を返さずに終了してしまうという事態に陥るからです。</p>
<p>次の状況を想像してみましょう。 関数人であるB君は、同じく関数人であるAさんに愛情(引数)をもらって一生懸命働きます。 しかし、B君はAさんに給料(返り値)を渡しませんでした。 そんな状況は有ってはならないのです。 もちろん、最初から見返りがない(返り値型が<code>void</code>)場合はいいのですが。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// 意味のない関数</span>
<span class="dt">int</span> foo(<span class="dt">int</span> a)
{
    <span class="kw">if</span>(a || !a){
        <span class="kw">while</span>(a){
            <span class="kw">if</span>(a)
                <span class="kw">return</span> a;
        }
    }
    
    <span class="co">// ここには絶対到達しない</span>
    <span class="co">// しかし、returnしておかないとコンパイラに怒られる</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>絶対に到達し得ないのに<code>return 0;</code>と書いていると、他人が読んだ時に「こいつ何書いてるんだ？」というふうに思われてしまします。 また、<code>return 0;</code>というコードを入れることによって、その関数が失敗したから<code>0</code>を返したのか、成功した結果の<code>0</code>なのかわからなくなります。 よって、このような場合には<code>return</code>の代わりに<code>assert(0);</code>を入れてあげます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// 意味のない関数</span>
<span class="dt">int</span> foo(<span class="dt">int</span> a)
{
    <span class="kw">if</span>(a || !a){
        <span class="kw">while</span>(a){
            <span class="kw">if</span>(a)
                <span class="kw">return</span> a;
        }
    }
    
    <span class="co">// ここには絶対到達しない</span>
    <span class="kw">assert</span>(<span class="dv">0</span>);
}</code></pre>
<p><code>assert(0);</code>があれば、<code>return</code>がなくてもコンパイルは通ります。 もしその<code>assert(0);</code>が実行されてしまったとしても次のようなメッセージと共にプログラムはただちに終了します。</p>
<pre><code>core.exception.AssertError@foo(10): Assertion failure
----------------
0x0040323B
0x0040201E
0x0040202A
0x00402633
0x00402231
0x00402054
0x75B933AA in BaseThreadInitThunk
0x772F9EF2 in RtlInitializeExceptionChain
0x772F9EC5 in RtlInitializeExceptionChain
----------------</code></pre>
<p>次の状況を想像してみましょう。 関数人であるB君は、同じく関数人であるAさんに愛情(引数)をもらって一生懸命働きます。 しかし、B君はAさんに給料(返り値)を渡しませんでした。 実は、関数人には爆弾(<code>assert(0);</code>)が仕かけられています。 その爆弾が爆発するのは、恩など(返り値)を返さなかったときです。 つまり、B君は爆発しました。 悲しいことに、B君が爆発してしまったがために給料がもらえなかったAさんは、Aさん自身の仕事を遂行できなくなりました。 その結果、AさんはAさんの親(関数Aの呼び出し元)に給料を送ることができなくなりました。 すると、Aさんの爆弾も爆発し、つまり最終的にはmain関数ちゃんまでもが爆発して、プログラム界は破滅します。</p>
<p><a href="#Q3">Goto: 問題3 「コンパイルできない！」</a></p>
<p>何も返さない関数を書きたいのであれば、<code>ReturnType</code>を<code>void</code>とします。 そのような関数では、<code>return</code>を関数中に書く必要はなく、関数を途中で終わらせたい場合にだけ<code>return;</code>と書きます。 返り値がない関数で、<code>return</code>文が実行されることなく関数の最後まで到達した場合には、<code>return</code>文と同様の効果により関数が終了します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> foo(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
    <span class="kw">if</span>(a &gt; <span class="dv">0</span>)
        <span class="kw">return</span>; <span class="co">// a &gt; 0 の場合には、関数は終わり、即座に処理が呼び出し元に戻る</span>
    <span class="kw">else</span>
        writeln(b - a);

    <span class="co">// a &lt;= 0 の場合にはここまで来て、処理が呼び出し元に戻る</span>
}</code></pre>
<p>この説明が分かりにくければ、<code>main</code>関数を思い出してみましょう。 <code>main</code>関数は、<code>ReturnType</code>が<code>void</code>な関数でしたが、<code>return</code>文をいちいち入れませんでしたね。 しかし、<code>main</code>関数はちゃんと終了していました。</p>
<p><code>return</code>文を入れて、<code>main</code>関数を途中で強制的に終わらせることもできます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.conv, std.stdio, std.string;


<span class="co">/// 例：コンソールで入力された数字をint型で返す関数</span>
<span class="dt">int</span> readInt()
{
    <span class="kw">return</span> readln().strip().to!<span class="dt">int</span>();
}


<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;main&quot;</span>);
    writeln(<span class="st">&quot;10以上整数を入力すると終了----&quot;</span>);

    <span class="kw">if</span>(readInt() &gt;= <span class="dv">10</span>)     <span class="co">// ある条件を満たせば、</span>
        <span class="kw">return</span>;             <span class="co">// 終了</span>

    writeln(<span class="st">&quot;end&quot;</span>);
}</code></pre>
<p><a href="#Q4">Goto: 問題4 「helpメッセージを表示せよ」</a></p>
<h3 id="関数の引数"><a href="#関数の引数">関数の引数</a></h3>
<p>関数は引数を受け取りますが、関数宣言で書かれている<code>int a</code>や<code>int b</code>を<b>仮引数</b>(parameter)といいます。 逆に、<code>addInt(4, 5)</code>とした場合の<code>4</code>や<code>5</code>は<b>実引数</b>(argument)といわれます。</p>
<p>関数本体が無い場合、もしくは仮引数を関数本体で使わない場合には、仮引数を省略して型だけにすることもできます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// intを3つ受け取るが、関数本体がないので仮引数は型だけしか書かない</span>
<span class="dt">int</span> add(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);</code></pre>
<p>通常、実引数は仮引数にコピーされて関数に渡されます。 つまり、値型であれば仮引数を変更しても実引数には影響しませんが、参照型であればその参照(住所)をコピーしますから、コピーされた参照を通して参照元に影響を与える可能性があります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// aは値型</span>
<span class="dt">void</span> addToValue(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
    a += b;
}


<span class="co">// aはポインタ(参照型)</span>
<span class="dt">void</span> addToRef(<span class="dt">int</span>* a, <span class="dt">int</span> b)
{
    *a += b;        <span class="co">// ポインタの参照先のインクリメント</span>
                    <span class="co">// 呼び出し元に影響を与える操作</span>

    a = <span class="kw">null</span>;       <span class="co">// ポインタの書き換え</span>
                    <span class="co">// この操作では呼び出し元に影響はない</span>
}


<span class="dt">void</span> main()
{
    <span class="dt">int</span> m = <span class="dv">2</span>,
        n = <span class="dv">13</span>;

    addToValue(m, n);
    writefln(<span class="st">&quot;m: %s, n:%s&quot;</span>, m, n);      <span class="co">// 2, 13</span>

    addToRef(&amp;m, n);                    <span class="co">// ポインタ(参照型)を渡す</span>
    writefln(<span class="st">&quot;m: %s, n:%s&quot;</span>, m, n);      <span class="co">// 15, 13</span>
                                        <span class="co">// m が書き換えられてる！</span>
}</code></pre>
<p>宣言された仮引数の型のリストと実引数の型のリストが一致しなければコンパイル時にエラーがでます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// test00901.d</span>
<span class="dt">int</span> add(<span class="dt">int</span> a, <span class="dt">int</span> b) { <span class="kw">return</span> a + b; }

<span class="dt">void</span> main()
{
    <span class="dt">int</span> a = add(<span class="dv">3</span>, <span class="dv">5</span>),
        b = add(<span class="dv">3</span>),             <span class="co">// Error: function test00901.add (int a, int b) is not callable using argument types (int)</span>
        c = add(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>),       <span class="co">// Error: function test00901.add (int a, int b) is not callable using argument types (int, int, int)</span>
        d = add(<span class="fl">3.0</span>, <span class="dv">4</span>);        <span class="co">// Error: function test00901.add (int a, int b) is not callable using argument types (double, int)</span>
}</code></pre>
<h2 id="デフォルト引数"><a href="#デフォルト引数">デフォルト引数</a></h2>
<p>仮引数にはデフォルト値を設定することができます。 デフォルト値が設定された仮引数に渡す実引数は省略することができます。 省略された場合には、仮引数に設定されたデフォルト値が仮引数の値となります。</p>
<p>しかし、デフォルト値を設定したとしても、その仮引数の後ろにデフォルト値が設定されていない仮引数がある場合にはコンパイルエラーとなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> getValue(<span class="dt">int</span>* p, <span class="dt">size_t</span> idx = <span class="dv">0</span>)
{
    <span class="kw">return</span> p[idx];
}


<span class="co">// idxはデフォルト値が設定されているが、後ろにデフォルト値が設定されていない v があるのでエラー</span>
<span class="co">// Error: default argument expected for v</span>
<span class="co">/*</span>
<span class="co">bool getAndTest(int* p, size_t idx = 0, int v)</span>
<span class="co">{</span>
<span class="co">    return p[idx] == v;</span>
<span class="co">}</span>
<span class="co">*/</span>

<span class="co">// デフォルト値は2つ以上の引数にも設定可能</span>
<span class="dt">int</span> getValue2d(<span class="dt">int</span>** p, <span class="dt">size_t</span> i = <span class="dv">0</span>, <span class="dt">size_t</span> j = <span class="dv">0</span>)
{
    <span class="kw">return</span> p[i][j];
}


<span class="dt">void</span> main()
{
    <span class="dt">int</span>* p = (<span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>]).<span class="dt">ptr</span>;
    <span class="kw">foreach</span>(i, <span class="kw">ref</span> e; p[<span class="dv">0</span> .. <span class="dv">10</span>])
        e = i;

    p[<span class="dv">0</span> .. <span class="dv">10</span>].<span class="dt">reverse</span>;

    writeln(p[<span class="dv">0</span> .. <span class="dv">10</span>]);            <span class="co">// [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>

    <span class="co">// idxを指定して呼び出し</span>
    writeln(getValue(p, <span class="dv">4</span>));        <span class="co">// 5</span>

    <span class="co">// idxを省略して呼び出すと、idxは0であると解釈される</span>
    writeln(getValue(p));           <span class="co">// 9</span>

    <span class="dt">int</span>** pp = &amp;p;
    writeln(getValue2d(pp));          <span class="co">// 9</span>
}</code></pre>
<h2 id="引数の記憶域クラス"><a href="#引数の記憶域クラス">引数の記憶域クラス</a></h2>
<p>関数の引数にも、普通の変数と同様に<a href="variable_type.md#%E8%A8%98%E6%86%B6%E5%9F%9F%E3%82%AF%E3%83%A9%E3%82%B9storage-class">記憶域クラス(storage class)</a>を付けることができます。</p>
<p>一切記憶域クラスがついていない引数は、値が(参照型ならその参照が)コピーされます。 これに対して、<code>ref</code>や<code>out</code>, <code>lazy</code>は特殊な渡され方をされます。</p>
<ul>
<li><p><code>const</code></p>
<p><code>const</code>が付けられた仮引数の型は<code>const(Type)</code>となり、その仮引数は書き換え不可能になります。 <code>const T arg</code>と<code>const(T) arg</code>は同じ意味です。</p>
<p><code>const</code>な引数は、mutableな値(<code>const</code>, <code>immutable</code>ではない)でも非mutableな値(<code>const</code>か<code>immutable</code>)でも、受け取ることができます。</p>
<p>(「mutableな」とは、「変更可能な」という意味です。)</p>
<p><a href="variable_type.md#const"><code>const</code>型の解説</a></p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> getValue(<span class="kw">const</span> <span class="dt">int</span>* p)
{
    <span class="co">//*p += 3;                  // pはconst(int*)型、*pはconst(int)型なので書き換え不可</span>

    <span class="kw">return</span> *p;                  <span class="co">// *pはconst(int)型なので、int型として返せる</span>
}</code></pre></li>
<li><p><code>immutable</code></p>
<p><code>immutable</code>記憶域クラスとなっている引数はその引数の型が<code>immutable(Type)</code>となります。</p>
<p><code>immutable</code>記憶域クラスな引数は<code>immutable</code>な値しか受け付けません。 もちろん、引数はコピーされるため<code>immutable</code>でない値型も受け付けます。 値型であれば<code>immutable</code>なコピーを作ることができるからです。</p>
<p><a href="variable_type.md#immutable"><code>immutable</code>型の解説</a></p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">immutable</span>(<span class="dt">int</span>)* getValue(<span class="kw">immutable</span> <span class="dt">int</span>* p)
{
    <span class="co">//*p += 3;                  // pはimmutable(int*)型、*pはimmutable(int*)型なので書き換え不可</span>

    <span class="kw">return</span> *p;                  <span class="co">// *pはimmutable(int*)型なので、immutable(int)*型として返せる</span>
}</code></pre></li>
<li><p><code>inout</code></p>
<p>このストレージクラスとなった引数は<code>inout</code>型になります。 仮引数に<code>inout</code>型を一つでも含む関数はinout関数と呼ばれます。 inout関数は、その関数を呼び出す実引数によって関数の返り値の型が変わります。</p>
<p>まずは仮引数に<code>inout</code>型を1つだけ含む関数<code>inout(int[]) getFront(inout(int[]) x);</code>について考えてみましょう。 この関数には<code>int[]</code>や<code>const(int[])</code>、さらには<code>immutable(int[])</code>型の値を渡すことが出来ます。 <code>getFront</code>関数の返り値は、実引数が<code>int[]</code>の場合には<code>int[]</code>が、<code>const(int[])</code>の場合には<code>const(int[])</code>が、そして<code>immutable(int[])</code>の場合には<code>immutable(int[])</code>になります。</p>
<p>コンパイラが3つのパターンについて<code>getFront</code>関数を生成しているわけではないことに注意しましょう。 コンパイラは、呼び出し毎に、実引数の型を調査して、それに見合った返り値の型を設定しているのです。</p>
次に、仮引数に<code>inout</code>型が1つよりも多く存在した場合ですが、コンパイラは呼び出し毎にすべての<code>inout</code>仮引数に対する実引数を調査します。 コンパイラによる実引数の調査の結果、コンパイラは次のように返り値の型を変更します。
<ol type="1">
<li><code>inout</code>に対応する型がすべて<code>immutable</code>であれば返り値の<code>inout</code>も<code>immutable</code>に置き換わった型になります。</li>
<li><code>inout</code>に対応するすべての実引数の型がmutable(<code>const</code>でも<code>immutable</code>でもない)であれば、返り値の<code>inout</code>は取り除かれます。</li>
<li>1や2にマッチしなかった場合は返り値の<code>inout</code>は<code>const</code>に置き換わります。</li>
</ol>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">inout</span>(<span class="dt">int</span>)[] foo(<span class="kw">inout</span>(<span class="dt">int</span>[]) x, <span class="kw">inout</span>(<span class="dt">int</span>[]) y)
{
    <span class="kw">return</span> x ~ y;
}


<span class="dt">void</span> main()
{
    <span class="dt">int</span>[] marr = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">const</span> carr = marr;
    <span class="kw">immutable</span> iarr = marr.<span class="dt">dup</span>;

    <span class="co">// (mutable, mutable) =&gt; mutable</span>
    <span class="kw">auto</span> a = foo(marr, marr);
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(<span class="dt">typeof</span>(a) == <span class="dt">int</span>[]));

    <span class="co">// (mutable, const) =&gt; const</span>
    <span class="kw">auto</span> b = foo(marr, carr);
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(<span class="dt">typeof</span>(b)== <span class="kw">const</span>(<span class="dt">int</span>)[]));

    <span class="co">// (mutable, immutable) =&gt; const</span>
    <span class="kw">auto</span> c = foo(marr, iarr);
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(<span class="dt">typeof</span>(c) == <span class="kw">const</span>(<span class="dt">int</span>)[]));

    <span class="co">// (const, immutable) =&gt; const</span>
    <span class="kw">auto</span> d = foo(carr, iarr);
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(<span class="dt">typeof</span>(d) == <span class="kw">const</span>(<span class="dt">int</span>)[]));

    <span class="co">// (immutable, immutable) =&gt; immutable</span>
    <span class="kw">auto</span> e = foo(iarr, iarr);
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(<span class="dt">typeof</span>(e) == <span class="kw">immutable</span>(<span class="dt">int</span>)[]));
}</code></pre>
<p>また、inout関数内でのみ<code>inout</code>型の変数を宣言できます。 <code>inout(T)</code>という型は<code>const(T)</code>へは暗黙変換可能ですが、<code>T</code>や<code>immutable(T)</code>へは暗黙変換できません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.traits;

<span class="dt">void</span> foo(<span class="kw">inout</span>(<span class="dt">int</span>)[] x)
{
    <span class="kw">inout</span>(<span class="dt">int</span>)[] y = x;
    <span class="kw">auto</span> z = x ~ y;
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(<span class="dt">typeof</span>(z) == <span class="kw">inout</span>(<span class="dt">int</span>)[]));

    <span class="co">//int[] mz = z;     Error</span>
    <span class="kw">const</span> cz = z;
    <span class="co">//immutable iz = z; Error</span>

    <span class="co">// inout と mutable の CommonType =&gt; const</span>
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(CommonType!(<span class="kw">inout</span>(<span class="dt">int</span>)[], <span class="dt">int</span>[])
        == <span class="kw">const</span>(<span class="dt">int</span>)[]));

    <span class="co">// inout と const の CommonType =&gt; const</span>
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(CommonType!(<span class="kw">inout</span>(<span class="dt">int</span>)[], <span class="kw">const</span>(<span class="dt">int</span>)[])
        == <span class="kw">const</span>(<span class="dt">int</span>)[]));

    <span class="co">// inout と immutable の CommonType =&gt; inout(const(int))</span>
    <span class="kw">static</span> <span class="kw">assert</span>(<span class="kw">is</span>(CommonType!(<span class="kw">inout</span>(<span class="dt">int</span>)[], <span class="kw">immutable</span>(<span class="dt">int</span>)[])
        == <span class="kw">inout</span>(<span class="kw">const</span>(<span class="dt">int</span>))[]));
}</code></pre></li>
<li><p><code>shared</code></p>
<p>この記憶域クラスとなっている引数の型は、<code>shared</code>型になります。</p>
<p><a href="variable_type.md#shared"><code>shared</code>型の解説</a></p></li>
<li><p><code>scope</code></p>
<p><code>scope</code>が付いた引数は、その引数が持つ参照をその関数の外部に移動することができなくなります。 つまり、値型な引数に<code>scope</code>をつけても意味はありませんが、スライスやデリゲート、クラスなどのような参照を持つ型はグローバル変数に代入したり、関数から返すことはできなくなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span>[] gSlice;               <span class="co">// global変数</span>

<span class="dt">int</span>[] foo(<span class="kw">scope</span> <span class="dt">int</span>[] x)
{
    gSlice = x;             <span class="co">// コンパイルエラー</span>
    <span class="kw">return</span> x;               <span class="co">// コンパイルエラー</span>
}</code></pre>
<p>ただし、現在のdmd(dmd 2.063.2)では、この<code>scope</code>は機能していないようで、上記のようなコードもコンパイルが通ってしまいます。</p>
bugzilla
<ul>
<li><a href="http://d.puremagic.com/issues/show_bug.cgi?id=6931">Issue 6931</a></li>
</ul></li>
<li><p><code>in</code></p>
<p><code>const scope</code>と等しくなります。 よって、<code>const</code>同様に変更ができなくなります。 参照型に対しては、参照を関数外部に持っていくことも出来ないようになります。</p>
<p><small>ただし、現在のdmd(dmd 2.063.2)では<code>scope</code>記憶域クラスは機能してないようなので、<code>const</code>に等価な記憶域クラス？[要出典]</small></p></li>
<li><p><code>ref</code></p>
<p>実引数として左辺値を受け取り、仮引数への操作はすべて受け取った実引数への操作になります。 つまり、左辺値を関数内で操作し、関数を超えてその左辺値に影響を与えたい場合に利用します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> moveFront(<span class="kw">ref</span> <span class="dt">int</span>[] arr)
{
    <span class="kw">auto</span> dst = arr[<span class="dv">0</span>];

    arr = arr[<span class="dv">1</span> .. $];
    <span class="kw">return</span> dst;
}


<span class="dt">void</span> main()
{
    <span class="dt">int</span>[] arr = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    writeln(moveFront(arr));        <span class="co">// 0</span>
    writeln(arr.<span class="dt">length</span>);            <span class="co">// 3</span>
                                    <span class="co">// arrが変更されている</span>

    writeln(moveFront(arr));        <span class="co">// 1</span>
    writeln(arr.<span class="dt">length</span>);            <span class="co">// 2</span>
                                    <span class="co">// arrが変更されている</span>
}</code></pre></li>
<li><p><code>auto ref</code></p>
<p>この記憶域クラスは、テンプレート関数でのみ使用可能になります。 なので今は気にする必要はありませんが、機能としては「<code>ref</code>で引数が取れるなら<code>ref</code>でとる」という記憶域クラスです。 つまり、呼び出した際の実引数が左辺値であれば参照<code>ref</code>で受け取って、右辺値なら<code>non-ref</code>で受け取ります。</p></li>
<li><p><code>out</code></p>
<p>左辺値を受け取るという特性は<code>ref</code>と同じですが、関数に入る時点でその参照の値がデフォルト初期化値<code>.init</code>で初期化され、以降は<code>ref</code>と同様の動作になります。</p>
<p>返り値以外に出力をしたい場合に使用します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> findMax(<span class="kw">in</span> <span class="dt">int</span>[] arr, <span class="kw">out</span> <span class="dt">size_t</span> idx)
{
    <span class="kw">foreach</span>(i, e; arr)
        <span class="kw">if</span>(e &gt; arr[idx])
            idx = i;
    <span class="kw">return</span> arr[idx];
}


<span class="dt">void</span> main()
{
    <span class="co">// どうせ、findMax呼び出し時に初期化されるからvoidでもよい</span>
    <span class="dt">size_t</span> idx = <span class="dt">void</span>;

    writeln(findMax([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">0</span>], idx));     <span class="co">// 5</span>
    writeln(idx);                               <span class="co">// 2</span>
}</code></pre></li>
<li><p><code>lazy</code></p>
<p>この記憶域クラスでは、実引数の評価は遅延評価され、関数内で必要になった時に初めて評価されます。</p>
<p>仕組みとしては、引数を返すデリゲートを作り、そのデリゲートを呼び出しています。 つまり、<code>foo(expr)</code>が<code>foo((){return expr;})</code>になります。 デリゲートについては、後ほど説明するので、「遅延評価され、仮引数を複数回評価すると、実引数も複数回評価される」とだけ覚えておいてください。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> get(<span class="dt">int</span>* p, <span class="kw">lazy</span> <span class="dt">int</span> defValue)
{
    <span class="kw">return</span> p ? *p : defValue;
}


<span class="dt">void</span> main()
{
    <span class="dt">int</span> a = <span class="dv">3</span>;

    writeln(get(&amp;a, ++a));      <span class="co">// 3</span>
                                <span class="co">// get(&amp;a, (){ return ++a; })に等価</span>

    writeln(get(<span class="kw">null</span>, ++a));    <span class="co">// 4</span>
                                <span class="co">// get(null, (){ return ++a; })に等価</span>
}</code></pre>
<p>次のように複数回評価することもできます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.array;
<span class="kw">import</span> std.stdio;


<span class="dt">int</span>[] callN(<span class="kw">lazy</span> <span class="dt">int</span> v, <span class="dt">size_t</span> n)
{
    <span class="co">// 配列に要素を追加していく場合には、std.array.appenderを使う</span>
    <span class="kw">auto</span> app = appender!(<span class="dt">int</span>[])();

    <span class="co">// n回評価して、追加していく</span>
    <span class="kw">foreach</span>(unused; <span class="dv">0</span> .. n)
        app.put(v);

    <span class="kw">return</span> app.data;            <span class="co">// appenderが管理している配列を返す</span>
}


<span class="dt">void</span> main()
{
    <span class="dt">int</span> a = <span class="dv">3</span>;

    writeln(callN(++a, <span class="dv">3</span>));               <span class="co">// [4, 5, 6]</span>
}</code></pre>
<p><code>lazy</code>がどれほど素晴らしい機能なのかを体験するために、次のソースコードをコンパイルして実行してみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;
<span class="kw">import</span> std.datetime;

<span class="dt">int</span> tarai_lazy(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="kw">lazy</span> <span class="dt">int</span> z)
{
    <span class="kw">if</span> (x &lt;= y) <span class="kw">return</span> y;
    <span class="kw">return</span> tarai_lazy(tarai_lazy(x-<span class="dv">1</span>, y, z), tarai_lazy(y-<span class="dv">1</span>, z, x), tarai_lazy(z-<span class="dv">1</span>, x, y));
}


<span class="dt">int</span> tarai(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> z)
{
    <span class="kw">if</span> (x &lt;= y) <span class="kw">return</span> y;
    <span class="kw">return</span> tarai(tarai(x-<span class="dv">1</span>, y, z), tarai(y-<span class="dv">1</span>, z, x), tarai(z-<span class="dv">1</span>, x, y));
}


<span class="dt">void</span> main()
{
    {
        <span class="kw">auto</span> mt = measureTime!(a =&gt; writefln(<span class="st">&quot;non-lazy: %s[usecs]&quot;</span>, a.usecs))();
        tarai(<span class="dv">10</span>, <span class="dv">8</span>, <span class="dv">0</span>);
    }

    {
        <span class="kw">auto</span> mt = measureTime!(a =&gt; writefln(<span class="st">&quot;lazy: %s[usecs]&quot;</span>, a.usecs))();
        tarai_lazy(<span class="dv">10</span>, <span class="dv">8</span>, <span class="dv">0</span>);
    }
}</code></pre>
<p>実行結果はどのように出ましたか？ 私の環境では、以下のように出力されました。</p>
<pre><code>non-lazy: 3344[usecs]
lazy: 1[usecs]</code></pre>
<p>先ほどのプログラムは、「<a href="http://ja.wikipedia.org/wiki/%E7%AB%B9%E5%86%85%E9%96%A2%E6%95%B0">たらい回し関数(竹内関数)</a>」のD言語での実装でした。 たらい回し関数は、関数自体が短く、引数<code>x, y, z</code>が小さな数であったとしても、計算量が膨大な数になってしまう関数です。 私の環境だと<code>tarai(10, 8, 0)</code>に3ミリ秒程度かかったということになります。</p>
<p>しかし、遅延評価バージョン(<code>tarai_lazy(10, 8, 0)</code>)では、たった1マイクロ秒で計算が終わってます。 <code>tarai</code>と<code>tarai_lazy</code>の違いは、引数が<code>lazy int z</code>になってるだけです。 たらい回し関数は、<code>z</code>が遅延評価されると途端に計算量が低下する関数なので、このように<code>tarai_lazy</code>は高速なのです。</p></li>
</ul>
<h2 id="可変個引数関数"><a href="#可変個引数関数">可変個引数関数</a></h2>
<p>引数に取りたい実引数の数が、実行条件によって変わることがあります。 たとえば、<code>writeln</code>や<code>writefln</code>などの<code>write</code>系の関数は、引数をいくらでも取ることができます。</p>
<p>このような関数を作るのには、様々な方法があります。</p>
<ul>
<li><p>同じ型の引数を可変個取りたい場合</p>
<p>たとえば、次のように文字列をいくつか受け取って、それらを連結した文字列を返す関数は、次のように書けます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">string</span> chainString(<span class="dt">string</span>[] str...)
{
    <span class="dt">string</span> chained;

    <span class="kw">foreach</span>(e; str)
        chained ~= e;

    <span class="kw">return</span> chained;
}


<span class="dt">void</span> main()
{
    writeln(chainString());
    writeln(chainString(<span class="st">&quot;foo&quot;</span>));
    writeln(chainString(<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>));
    writeln(chainString(<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;hoge&quot;</span>));
}</code></pre>
<p>可変長パラメータである<code>str</code>に、引数のリストが入ります。 <code>str</code>を関数外に移動することは不正です (つまり、<code>scope</code>が暗黙的に付いていると考えれる？[要出典])。</p>
<p>実際には、静的配列にすることもできます。 たとえば、いくつかの数を受け取って、その中で最も大きな整数を返す関数は次のように書けます。</p>
<pre class="sourceCode d"><code class="sourceCode d">T max(T, <span class="dt">size_t</span> N)(T[N] nums...)
<span class="kw">if</span>(N &gt; <span class="dv">0</span>)
{
    T v = nums[<span class="dv">0</span>];

    <span class="kw">foreach</span>(e; nums[<span class="dv">1</span> .. $])
        v = v &gt; e ? v : e;

    <span class="kw">return</span> v;
}


<span class="dt">void</span> main()
{
    writeln(max(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>));       <span class="co">// 3</span>
}</code></pre>
<p>この関数は、テンプレート関数(Template Function)といい、任意の型Tと0より大きい任意のNに対してマッチするテンプレート関数です。</p></li>
<li><p>異なる型の引数を可変個取りたい場合</p>
<p><code>writeln</code>や<code>writefln</code>などは異なる型の引数を任意個取ることができます。 このような関数は可変個引数関数と呼ばれ、普通はテンプレートを使って作ります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    println(<span class="st">&quot; : &quot;</span>, <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="dv">2</span>, <span class="dv">4</span>);     <span class="co">// foo : bar : 2 : 4</span>
}


<span class="dt">void</span> println(T...)(<span class="dt">string</span> sep, T values)
{
    <span class="co">// valuesはforeachで回せる</span>
    <span class="kw">foreach</span>(i, e; values){
        <span class="kw">if</span>(i != <span class="dv">0</span>)
            write(sep);

        write(e);
    }

    writeln();

    <span class="co">/* Tもforeachで回せる</span>
<span class="co">    foreach(i, Unused; values){</span>
<span class="co">        write(values[i]);</span>

<span class="co">        if(i != T.length - 1)</span>
<span class="co">            write(sep);</span>
<span class="co">    }</span>

<span class="co">    writeln();</span>
<span class="co">    */</span>
}</code></pre>
<p>これについてはテンプレートの章で説明するとして、今回は全く使われない方法で可変個引数関数を作ります。 この方法にはCスタイルとDスタイルがありますが、全く使う機会がないのでさらっと流してしまいます。 詳しい仕様を知りたい場合には、<a href="http://www.kmonos.net/alang/d/function.html#variadic">可変個引数 - プログラミング言語D</a>を読みましょう。</p>
<ul>
<li><p>Cスタイルな可変個引数関数</p>
<p>関数の宣言は以下のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">extern</span>(C) <span class="dt">void</span> foo(<span class="dt">int</span> a, ...);
<span class="co">// extern(C) void bar(...);             // エラー</span></code></pre>
<p><code>...</code>の部分が可変個の引数を受け取れる部分です。 関数引数が<code>...</code>だけではいけません。 最低1つは可変個でない引数が必要です。 ちなみに、<code>extern(C)</code>は、「この関数はC言語みたいな関数だよ」ということです。</p></li>
<li><p>Dスタイルな可変個引数関数</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> foo(<span class="dt">int</span> a, ...);
<span class="dt">void</span> bar(...);                          <span class="co">// OK</span></code></pre>
<p>Dスタイルの可変個引数関数では、<code>_argptr</code>と<code>_arguments</code>という変数にアクセスできます。 <code>import core.vararg;</code>とし、<code>va_arg!T(_argptr)</code>で型<code>T</code>の引数を取ることが出来ます。 また、<code>va_arg</code>で引数を取ったあと次に<code>va_arg</code>を呼び出す場合は、その次の変数が読み出せます。</p>
<p><code>_arguments</code>という引数には、可変個引数部分の引数の型の情報が格納されています。 型は<code>TypeInfo[]</code>で、<code>if(_arguments[i] == typeid(int)){}</code>のように、<code>i</code>番目の引数の型が<code>int</code>型かどうか比較ができます。</p>
<p>これから例として先ほどの<code>println</code>関数を作りたいのですが、あらためて引数とその動作を以下に示します。</p>
<pre class="sourceCode d"><code class="sourceCode d">println(<span class="st">&quot; : &quot;</span>, <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="dv">2</span>, <span class="dv">4</span>);     <span class="co">// foo : bar : 2 : 4</span>
println(<span class="st">&quot;, &quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="ch">&#39;c&#39;</span>, <span class="st">&quot;foo&quot;</span>);        <span class="co">// 1, 2, c, foo</span></code></pre>
<p>対応する型は簡単化のために<code>int, char, string</code>でいいでしょう。 さて、<code>print</code>関数の動作と仕様がわかったので、実装していきたいと思います。</p>
<p><code>_arguments</code>は<code>TypeInfo[]</code>ですから、<code>foreach</code>で回すのが適切でしょう。 各要素で型を判別して、<code>va_arg!T</code>で引数を取得します。 よって、実装は次のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> core.vararg;
<span class="kw">import</span> std.stdio;       <span class="co">// write, writelnを使うから</span>

<span class="dt">void</span> println(<span class="dt">string</span> sep, ...)
{
    <span class="kw">foreach</span>(i, type; _arguments){
        <span class="kw">if</span>(type == <span class="kw">typeid</span>(<span class="dt">int</span>))
            write(va_arg!<span class="dt">int</span>(_argptr));
        <span class="kw">else</span> <span class="kw">if</span>(type == <span class="kw">typeid</span>(<span class="dt">char</span>))
            write(va_arg!<span class="dt">char</span>(_argptr));
        <span class="kw">else</span> <span class="kw">if</span>(type == <span class="kw">typeid</span>(<span class="dt">string</span>))
            write(va_arg!<span class="dt">string</span>(_argptr));
        <span class="kw">else</span>
            <span class="kw">assert</span>(<span class="dv">0</span>);

        <span class="kw">if</span>(i != _arguments.<span class="dt">length</span> - <span class="dv">1</span>)
            write(sep);
    }

    writeln();
}</code></pre></li>
</ul></li>
</ul>
<h2 id="オブジェクトを形成する引数"><a href="#オブジェクトを形成する引数">オブジェクトを形成する引数</a></h2>
<p>関数に渡されたの引数で、クラスのコンストラクタを走らせ、インスタンスを組み立てることができます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">class</span> Foo{ <span class="kw">this</span>(<span class="dt">int</span> x, <span class="dt">int</span> y){} }

<span class="co">// Fooのコンストラクタが呼ばれる</span>
<span class="dt">void</span> foo(Foo foo...)    <span class="co">// fooには暗黙的にscopeが付いているようなもの</span>
{
    writeln(foo);
}


<span class="dt">void</span> main()
{
    foo(<span class="dv">1</span>, <span class="dv">2</span>);  <span class="co">// Fooのコンストラクタは(int, int)</span>
}</code></pre>
<h2 id="返値型推論"><a href="#返値型推論">返値型推論</a></h2>
<p>関数の返り値の型が複雑で長くなる場合があります。 その場合は、返り値の型を<code>auto</code>と書いておけば、<code>return</code>文から返り値の型が推論されるようになり便利です。</p>
<p>また、<code>auto ref</code>とすることで、参照で返すかどうかも推論されます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm;

<span class="co">// この関数の返り値の型は MapResult!(unaryFun, FilterResult!(unaryFun, int[]))</span>
<span class="kw">auto</span> func(<span class="dt">int</span>[] arr)
{
    <span class="kw">return</span> arr.filter!<span class="st">&quot;a &gt; 2&quot;</span>().map!<span class="st">&quot;a &gt;&gt; 1&quot;</span>();
}


<span class="co">// 引数が左辺値(lvalue)なら、返り値もlvalue</span>
<span class="kw">auto</span> <span class="kw">ref</span> add1()(<span class="kw">auto</span> <span class="kw">ref</span> <span class="dt">int</span> x)         <span class="co">// 仮引数記憶域クラスのauto refは、テンプレート関数専用なので`()`が必要</span>
{
    x += <span class="dv">1</span>;
    <span class="kw">return</span> x;
}


<span class="dt">void</span> main()
{
    <span class="dt">int</span> a;
    ++add1(a);      <span class="co">// 返り値がlvalueなので、インクリメントできる</span>
    writeln(a);     <span class="co">// 2</span>

    <span class="co">//++add1(10);   // Error: add1(10) is not an lvalue</span>
                    <span class="co">// 10は右辺値(rvalue)なので、lvalueで返せない</span>
}</code></pre>
<h2 id="関数の属性"><a href="#関数の属性">関数の属性</a></h2>
<p>関数に属性をつけることで、コンパイラにその関数の情報を与えることができます。 たとえば、<code>@property</code>という属性を、引数が0個の関数に付けると、<code>()</code>を省略して呼び出すことができます。 また、外部に影響を与えないということが静的に保証されている関数には<code>pure</code>が付きます。</p>
<h3 id="プロパティ関数property"><a href="#プロパティ関数property">プロパティ関数<code>@property</code></a></h3>
<p>引数の数が0, 1, 2個の場合にのみ有効な属性です。 この属性が付いた関数は、次のような構文で関数を呼び出すことができるようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;


<span class="co">// 引数の数が0個のプロパティ関数</span>
<span class="dt">int</span> foo() @property
{
    <span class="kw">return</span> <span class="dv">1</span>;
}


<span class="co">// 引数の数が1つのプロパティ関数</span>
<span class="dt">int</span> bar(<span class="dt">int</span> a) @property
{
    <span class="kw">return</span> a;
}


<span class="co">// 引数の数が2つのプロパティ関数</span>
<span class="dt">int</span> add(<span class="dt">int</span> a, <span class="dt">int</span> b) @property
{
    <span class="kw">return</span> a + b;
}


<span class="co">//Error: properties can only have zero, one, or two parameter</span>
<span class="co">/*</span>
<span class="co">int tri(int a, int b, int c) @property pure nothrow @safe</span>
<span class="co">{</span>
<span class="co">    return a + b + c;</span>
<span class="co">}</span>
<span class="co">*/</span>


<span class="dt">void</span> main()
{
    writeln(foo);               <span class="co">// 1</span>
                                <span class="co">// 引数の数が0の@property関数はカッコ()無しで変数みたいに呼べる</span>
    writeln(foo());             <span class="co">// もちろん、カッコ付きで読んでもOK</span>

    writeln(bar = <span class="dv">12</span>);          <span class="co">// 12</span>
                                <span class="co">// 引数の数が1つだと、プロパティ関数がさも代入されるかのような構文で呼べる</span>
                                <span class="co">// この場合は、bar(12)に等価</span>
    writeln(<span class="fl">12.</span>bar);            <span class="co">// UFCSとプロパティ関数の組み合わせ</span>

    writeln(<span class="fl">1.</span>add = <span class="dv">15</span>);        <span class="co">// 16</span>
                                <span class="co">// 引数の数が2つだと、first.func = secondのような構文でも呼べるようになる。</span>
                                <span class="co">// この場合はadd(1, 15)に等しい</span>
}</code></pre>
<p>プロパティ関数でない関数であっても、プロパティ関数のように呼び出すことは可能です。 しかし、dmdでは<code>-property</code>を指定することで、プロパティ関数でない関数がプロパティ関数のような構文で呼ばれている箇所がエラーになります。</p>
<p>構造体やクラスについては後の章で説明しますが、それらのメンバ関数がプロパティ関数の場合にも同様に呼び出すことができます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;


<span class="kw">struct</span> S
{
    <span class="co">// 引数の数は0個</span>
    <span class="dt">int</span> foo() @property
    {
        <span class="kw">return</span> <span class="dv">1</span>;
    }


    <span class="co">// 引数の数は1個</span>
    <span class="dt">int</span> bar(<span class="dt">int</span> a) @property
    {
        <span class="kw">return</span> a;
    }
}


<span class="dt">void</span> main()
{
    S s;

    writeln(s.foo);             <span class="co">// 1</span>
                                <span class="co">// メンバ関数の場合でも、引数の数が0個なら、関数呼び出しのカッコが省略できる</span>
    writeln(s.foo());           <span class="co">// もちろん、カッコ付きで読んでもOK</span>

    writeln(s.bar = <span class="dv">12</span>);        <span class="co">// 12</span>
                                <span class="co">// メンバ関数の場合でも、引数の数が1つだと、さも代入されるかのような構文で呼べる</span>
                                <span class="co">// この場合は、s.bar(12)に等価</span>
}</code></pre>
<h3 id="関数のメモリ安全性"><a href="#関数のメモリ安全性">関数のメモリ安全性</a></h3>
<p>D言語には、 - 未定義動作を引き起こさないこと(<b>メモリ安全性</b>といいます)を保証する - メモリ安全性を保証できない場合でも、そのようなコードを検証しやすくする</p>
<p>ための仕組みが用意されています。</p>
<p>関数に後述する属性を付けることでこの仕組みを利用することができ、未定義動作が原因の不可解で再現性のないバグを防ぐことができます。<br />メモリ安全性についての属性は3つあり、付けられた属性によって、関数を以下のように分類することができます。</p>
<ul>
<li><p><b>セーフ関数</b><code>@safe</code></p>
<p><b>セーフ関数</b>(safe function)は、その関数内でのすべての操作がメモリ安全な関数で、未定義動作を引き起こさないことがコンパイラによって保証されます。 そのため、次のような制約があります。</p>
<ul>
<li>インラインアセンブラは書けない</li>
<li><code>cast</code>によって、<code>const</code>や<code>immutable</code>, <code>shared</code>を取り除くことができない</li>
<li><code>cast</code>によって、<code>immutable</code>や<code>shared</code>を付加することができない</li>
<li><code>cast</code>によって、ポインタ型<code>T*</code>を、<code>void*</code>以外の他のポインタ型<code>U*</code>へ変換できない</li>
<li><code>cast</code>による、ポインタでない型から、ポインタ型へ変換できない</li>
<li>ポインタ値の変更(加算, 減算, …etc)不可</li>
<li>ポインタが指している要素以外は触れない(ptr[idx]は不可)</li>
<li>ポインタ型を含む<code>union</code>は触れない</li>
<li><code>class Exception</code>派生でない例外の<code>catch</code>ができない</li>
<li>システム関数(後述)の呼び出しができない</li>
<li>ローカル変数や関数引数へのアドレスの取得ができない</li>
<li><code>__gshared</code>な変数を触ることができない</li>
</ul>
<p><small>正確には、以下を参照:<br /><a href="http://www.kmonos.net/alang/d/function.html#safe-functions">関数#safe-functions - プログラミング言語 D (日本語訳)</a><br /><a href="http://dlang.org/function.html#safe-functions">Functions#safe-functions - D Programming Language</a><br /><a href="http://www.kmonos.net/alang/d/safed.html">SafeD - プログラミング言語 D (日本語訳)</a><br /><a href="http://dlang.org/safed.html">SafeD - D Programming Language</a></small></p>
<p>セーフ関数はコンパイル時に解析され、セーフ関数であるのにメモリ安全でない操作をしている場合には、コンパイルエラーとなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> foo(<span class="dt">int</span>* p) <span class="co">/*@safe*/</span>
{
    <span class="kw">return</span> p[<span class="dv">1</span>];            <span class="co">// *(p + 1)なので、fooはセーフ関数になれない</span>
}


<span class="dt">int</span> foo_safe(<span class="dt">int</span>* p) @safe
{
    <span class="kw">return</span> p[<span class="dv">0</span>];            <span class="co">// *pと等価なのでOK</span>
}


<span class="dt">int</span> bar(<span class="dt">int</span>[] arr) @safe
{
    <span class="dt">size_t</span> idx = <span class="dv">1</span>;
    <span class="kw">return</span> arr[idx];        <span class="co">// 配列(スライス)に対するidxアクセスはOK</span>
}</code></pre></li>
<li><p><b>信頼済み関数</b><code>@trusted</code></p>
<p><b>信頼済み関数</b>(trusted function)は、関数内ではメモリ安全ではない操作を行なっているけれども関数全体としてみれば安全であるような関数です。 信頼済み関数では、操作の静的な制約はありませんが、メモリ安全であることをプログラマが保証しなければいけません。 このため、関数を定義するプログラマは未定義動作を引き起こさないように注意する必要があります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> foo(<span class="dt">int</span>[] arr) @trusted
{
    <span class="kw">return</span> arr.<span class="dt">ptr</span>[arr.<span class="dt">length</span> - <span class="dv">1</span>];   <span class="co">// ポインタが指している要素以外に触っているので、fooはセーフ関数になれない</span>
                            <span class="co">// しかし、プログラマが保証するならば、信頼済み関数になれる</span>
}


<span class="dt">int</span> foo_safe(<span class="dt">int</span>* p) @safe
{
    <span class="kw">return</span> p[<span class="dv">0</span>];
}</code></pre></li>
<li><p><b>システム関数</b><code>@system</code></p>
<p><b>システム関数</b>(system function)は、<code>@safe</code>でも<code>@trusted</code>でもない関数です。属性に<code>@system</code>を付けることで、システム関数であることを明示することもできます。 システム関数は、操作の静的な制約がなく、メモリ安全であることを誰も保証してくれないので、これらの関数を定義するときや使用するときには未定義動作を引き起こさないように注意する必要があります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> foo(){}             <span class="co">// デフォルトではsystem関数</span>
<span class="dt">int</span> hoge() @system {}   <span class="co">// 明示的にsystem関数であることを表す</span>

<span class="dt">int</span> bar() @safe {}      <span class="co">// system関数じゃなくて、safe関数</span>
<span class="dt">int</span> baz() @trusted {}   <span class="co">// system関数じゃなくて、trusted関数</span></code></pre></li>
</ul>
<h3 id="純粋関数pure"><a href="#純粋関数pure">純粋関数<code>pure</code></a></h3>
<p>純粋関数とは、その関数が外部に影響を与えないことが静的に保証されている関数です。 つまり、I/O(入出力)は禁止、グローバル変数は触れません。 ネスト関数の場合には外のスコープも触ってはいけません。 もちろん、impureな関数(<code>pure</code>でない関数)を呼び出すことはできません。 以上の性質によって、純粋関数は引数以外の外部の影響に左右されずに動作します。</p>
<p>ただし、<code>pure</code>な関数でも引数が配列型などの参照型であれば、その引数を通して関数の外部に影響を与える可能性があります。 このような<code>pure</code>の振る舞いについては、後の章で詳しく説明します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> globalValue;

<span class="kw">immutable</span> <span class="dt">int</span> imm;
<span class="kw">const</span> <span class="dt">int</span>* cptr;

<span class="dt">void</span> foo(<span class="dt">int</span> x, <span class="dt">int</span> y) <span class="kw">pure</span>
{
    <span class="co">//globalValue = x;          // NG</span>
                                <span class="co">// グローバル変数の書き換えは不可</span>

    x = imm;                    <span class="co">// OK</span>
                                <span class="co">// immutableなグローバル変数の読み込みは可能</span>

    <span class="co">//x = *cptr;                // NG</span>
                                <span class="co">// constなポインタは、ポインタ値はconstだが、値は変化するので、読み込み不可</span>

    <span class="kw">static</span> <span class="dt">int</span> z;
    <span class="co">//z = x;                    // NG</span>
                                <span class="co">// static変数の書き換えは不可</span>

    <span class="kw">throw</span> <span class="kw">new</span> <span class="dt">Exception</span>(<span class="st">&quot;例外はOK&quot;</span>);

    <span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[x];     <span class="co">// newはOK</span>
}</code></pre>
<h3 id="例外を投げない関数nothrow"><a href="#例外を投げない関数nothrow">例外を投げない関数<code>nothrow</code></a></h3>
<p>例外についてはまだ説明していませんが、例外とは、プログラムがある処理をしている最中に起こった異常や、その異常を知らせるメッセージのことです。 「例外を投げる」とは、「異常が発生したというメッセージを発行する」ということになります。 例外は<code>throw ex;</code>で投げることができ、<code>catch</code>されるまで関数を遡っていきます。 <code>main</code>関数までさかのぼり、最終的に<code>catch</code>されなければプログラムは終了します。</p>
<p>ToDo: <a href="exception.md">例外の章へ</a></p>
<p><code>nothrow</code>関数は、そんな例外を絶対に投げないことが静的に保証されている関数です。 また、例外は関数を貫いて伝搬するため、<code>nothrow</code>関数内では<code>nothrow</code>関数しか呼ぶことが出来ません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> bar(){}                                <span class="co">// nothrow関数でない</span>

<span class="dt">void</span> foo() <span class="kw">nothrow</span>
{
    <span class="co">//throw new Exception(&quot;exception&quot;);     // nothrow関数内では例外を投げれない</span>
    <span class="co">//bar();                                // barはnothrow関数でないので、呼べない</span>
}</code></pre>
<p>例外を投げる可能性のある操作を関数内部に持っていても、その操作が<code>try</code>文中にあり、例外が関数外部にもれないのであれば構いません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> bar(){}                                <span class="co">// nothrow関数でない</span>

<span class="dt">void</span> foo() <span class="kw">nothrow</span>
{
    <span class="kw">try</span>{
        <span class="kw">throw</span> <span class="kw">new</span> <span class="dt">Exception</span>(<span class="st">&quot;exception:&quot;</span>);  <span class="co">// tryの中にあるのでOK</span>
        bar();                              <span class="co">// 同上</span>
    }
    <span class="kw">catch</span>(<span class="dt">Exception</span> ex){}
}</code></pre>
<p>ちなみに、整数の0除算や配列の範囲外参照, <code>assert</code>の失敗では、すべてエラーが投げられますが、これは例外ではないので、<code>nothrow</code>関数内でこれらの操作を行うことは可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> foo() <span class="kw">nothrow</span>
{
    <span class="kw">throw</span> <span class="kw">new</span> <span class="dt">Error</span>(<span class="st">&quot;error&quot;</span>);               <span class="co">// OK</span>
                                            <span class="co">// 例外じゃなくてエラー</span>

    <span class="dt">int</span>[] arr;
    <span class="kw">auto</span> b = arr[<span class="dv">1</span>];                        <span class="co">// エラーが投げられるが、例外でないのでOK</span>

    b /= <span class="dv">0</span>;                                 <span class="co">// エラーが投げられるが、例外でないのでOK</span>
}</code></pre>
<h3 id="udauser-defined-attribute"><a href="#udauser-defined-attribute">UDA(User Defined Attribute)</a></h3>
<p>ToDo: <a href="uda.md">UDAの章へ</a></p>
<h3 id="const-immutable-inout-abstract-final"><a href="#const-immutable-inout-abstract-final"><code>const</code>, <code>immutable</code>, <code>inout</code>, <code>abstract</code>, <code>final</code></a></h3>
<p>これらの属性は構造体<code>struct</code>やクラス<code>class</code>のメンバー関数でのみ使用することができます。</p>
<p>ToDo: <a href="union.md">共用体の章へ</a> ToDo: <a href="struct.md">構造体の章へ</a> ToDo: <a href="class.md">クラスの章へ</a></p>
<h2 id="関数オーバーロード多重定義-overload"><a href="#関数オーバーロード多重定義-overload">関数オーバーロード(多重定義, overload)</a></h2>
<p>D言語の関数は、引数が違えば、同じ関数名の関数を宣言することができます。</p>
<p>たとえば、C言語には「データをフォーマット指定して文字列に書き込みを行う」関数が<code>stdio.h</code>に以下のように複数あります。 それぞれは引数の型だけがことなるだけで、それらの関数の意味はすべて同じです。 しかし、C言語には関数のオーバーロードという機能がないので、各関数の名前が被ってはいけないという言語仕様上の制約があります。 ですから、<code>sprintf</code>系の関数では、その引数に応じて、先頭に<code>v</code>や<code>n</code>を付けて呼び出す関数を区別してやる必要があります。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Cでのsprintf系</span>
<span class="dt">int</span> sprintf(<span class="dt">char</span> *str, <span class="dt">const</span> <span class="dt">char</span> *format, ...);
<span class="dt">int</span> snprintf(<span class="dt">char</span> *str, size_t n, <span class="dt">const</span> <span class="dt">char</span> *format, ...);
<span class="dt">int</span> vsprintf(<span class="dt">char</span> *str, <span class="dt">const</span> <span class="dt">char</span> *format, va_list arg);
<span class="dt">int</span> vsnprintf(<span class="dt">char</span> *str, size_t n, <span class="dt">const</span> <span class="dt">char</span> *format, va_list arg);</code></pre>
<p>逆に、関数オーバーロードの機能があるD言語では、これらの関数は次のように、すべて<code>sprintf</code>という関数名で宣言することが可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// もし、Dでsprintf系をつくるならば</span>
<span class="dt">int</span> sprintf(<span class="dt">char</span>* str, <span class="kw">const</span> <span class="dt">char</span>* format, ...);
<span class="dt">int</span> sprintf(<span class="dt">char</span>* str, <span class="dt">size_t</span> n, <span class="kw">const</span> <span class="dt">char</span>* format, ...);
<span class="dt">int</span> sprintf(<span class="dt">char</span>* str, <span class="kw">const</span> <span class="dt">char</span>* format, <span class="dt">void</span>* argptr, <span class="dt">TypeInfo</span>[] arguments);
<span class="dt">int</span> sprintf(<span class="dt">char</span>* str, <span class="dt">size_t</span> n, <span class="kw">const</span> <span class="dt">char</span>* format, <span class="dt">void</span>* argptr, <span class="dt">TypeInfo</span>[] arguments);</code></pre>
<p>呼び出すときは引数にもっともマッチした関数が呼ばれます。 「もっともマッチした関数」とは、以下の優先順位でもっとも高い関数です。</p>
<ol type="1">
<li>完全にマッチしている</li>
<li><code>const</code>付きでマッチしている</li>
<li>暗黙の型変換によるマッチ</li>
<li>マッチしていない</li>
</ol>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> foo(<span class="dt">int</span>){ writeln(<span class="st">&quot;int&quot;</span>); }
<span class="dt">void</span> foo(<span class="kw">in</span> <span class="dt">int</span>){ writeln(<span class="st">&quot;in int&quot;</span>); }      <span class="co">// in は const scope のこと</span>

<span class="dt">void</span> bar(<span class="kw">in</span> <span class="dt">int</span>){ writeln(<span class="st">&quot;in int&quot;</span>); }
<span class="dt">void</span> bar(<span class="dt">long</span>){ writeln(<span class="st">&quot;long&quot;</span>); }

<span class="dt">void</span> hoge(<span class="dt">float</span>){ writeln(<span class="st">&quot;float&quot;</span>); }
<span class="dt">void</span> hoge(<span class="dt">double</span>){ writeln(<span class="st">&quot;double&quot;</span>); }

<span class="dt">void</span> main()
{
    foo(<span class="dv">1</span>);                 <span class="co">// int</span>
    foo(<span class="kw">cast</span>(<span class="kw">const</span>)<span class="dv">1</span>);      <span class="co">// in int</span>

    bar(<span class="dv">1</span>);                 <span class="co">// in int</span>
                            <span class="co">// 暗黙変換よりもconstは優先される</span>
    bar(<span class="kw">cast</span>(<span class="dt">long</span>)<span class="dv">1</span>);       <span class="co">// long</span>

    hoge(<span class="fl">1.0L</span>);           <span class="co">// コンパイルエラー:realはfloat, doubleの両方に等しく暗黙変換可能</span>
    <span class="co">/*</span>
<span class="co">    example.d(21): Error: function foo.hoge called with argument types:</span>
<span class="co">        ((real))</span>
<span class="co">    matches both:</span>
<span class="co">        example.d(9): foo.hoge(float _param_0)</span>
<span class="co">    and:</span>
<span class="co">        example.d(10): foo.hoge(double _param_0)</span>
<span class="co">    */</span>
}</code></pre>
<p>同一名称の関数が異なるモジュールに属している際には、コンパイラによる最適な関数の選択方法は複雑になります。 関数の呼び出しがあると、コンパイラはまずはモジュール毎にその関数の<b>オーバーロード集合</b>(overload set)を形成します。 次のステージでは、それぞれのモジュールでもっともマッチする関数を選択します。 前ステージでのマッチする関数の合計がただ一つの場合、つまりは、ただひとつのモジュールだけしかマッチしなければ、そのマッチした関数が呼ばれます。 そうでなければ(複数のモジュールでマッチしたのなら)、コンパイルエラーとなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// foo1.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> foo(<span class="dt">int</span>){ writeln(<span class="st">&quot;foo1.foo(int)&quot;</span>); }
<span class="dt">void</span> foo(<span class="kw">in</span> <span class="dt">int</span>){ writeln(<span class="st">&quot;foo1.foo(in int)&quot;</span>); }</code></pre>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// foo2.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> foo(<span class="dt">long</span>){ writeln(<span class="st">&quot;foo2.foo(long)&quot;</span>); }
<span class="dt">void</span> foo(<span class="dt">real</span>){ writeln(<span class="st">&quot;foo2.foo(real)&quot;</span>); }</code></pre>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// main.d</span>

<span class="kw">import</span> foo1, foo2;

<span class="dt">void</span> main()
{
    <span class="co">//foo(1);       // Error: foo2.foo at foo2.d(4) conflicts with foo1.foo at foo1.d(4)</span>
                    <span class="co">// モジュールfoo1ではfoo(int)が、foo2ではfoo(long)がマッチし、</span>
                    <span class="co">// 結果的に2つ以上のモジュールでマッチしたのでエラー</span>

    foo(<span class="dt">long</span>.<span class="dt">max</span>);  <span class="co">// foo2.foo(long)</span>
    foo(<span class="fl">1.0</span>);       <span class="co">// foo2.foo(real)</span>
                    <span class="co">// 上記2つともに、モジュールfoo2でのみマッチする</span>
}</code></pre>
<p>もし、<code>foo1</code>と<code>foo2</code>に分けられたオーバーロード集合を一つに結合したい場合には、次のように<code>alias</code>を使います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> foo1, foo2;

<span class="co">// モジュールfoo1とfoo2の、fooに関するオーバーロード集合を一つに結合する</span>
<span class="kw">alias</span> foo = foo1.foo;
<span class="kw">alias</span> foo = foo2.foo;

<span class="dt">void</span> main()
{
    foo(<span class="dv">1</span>);         <span class="co">// foo1.foo(int)</span>
    foo(<span class="dt">long</span>.<span class="dt">max</span>);  <span class="co">// foo2.foo(long)</span>
    foo(<span class="fl">1.0</span>);       <span class="co">// foo2.foo(real)</span>
}</code></pre>
<p>オーバーロード集合を結合せずとも、明示的に所属するモジュールを指定してやることで解決します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> foo1, foo2;

<span class="dt">void</span> main()
{
    foo1.foo(<span class="dv">1</span>);         <span class="co">// foo1.foo(int)</span>
    foo2.foo(<span class="dt">long</span>.<span class="dt">max</span>);  <span class="co">// foo2.foo(long)</span>
    foo2.foo(<span class="fl">1.0</span>);       <span class="co">// foo2.foo(real)</span>
}</code></pre>
<h2 id="ローカルstatic変数"><a href="#ローカルstatic変数">ローカル<code>static</code>変数</a></h2>
<p>関数内には<code>static</code>と付いた変数を宣言することができます。 静的変数は「その関数だけが触れるグローバル変数」となります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> foo()
{
    <span class="kw">static</span> <span class="dt">int</span> cnt;

    writefln(<span class="st">&quot;%s回目の呼び出し&quot;</span>, ++cnt);
}


<span class="dt">void</span> main()
{
    foo();          <span class="co">// 1回目の呼び出し</span>
    foo();          <span class="co">// 2回目の呼び出し</span>
    foo();          <span class="co">// 3回目の呼び出し</span>
    foo();          <span class="co">// 4回目の呼び出し</span>
}</code></pre>
<p>ローカル<code>static</code>変数を初期化するには、初期化値がコンパイル時定数である必要があります。 つまり、実行時に決まるような値で初期化できません。 このような場合は<code>static bool firstCall</code>というような変数を用いて、初期化しましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">string</span> foo(<span class="dt">string</span> line)
{
    <span class="kw">static</span> <span class="dt">bool</span> firstCall = <span class="kw">true</span>;       <span class="co">// リテラルはコンパイル時定数</span>
    <span class="kw">static</span> <span class="dt">int</span> hold<span class="co">/* = line*/</span>;         <span class="co">// ローカル変数や仮引数はコンパイル時定数ではない</span>

    <span class="co">// 第一回目の関数呼び出しのときにのみ中の文が実行される</span>
    <span class="kw">if</span>(firstCall){
        hold = line;
        firstCall = !firstCall;
    }

    <span class="kw">return</span> hold;
}</code></pre>
<p><a href="#Q5">Goto: 問題5 「Grand Total」</a><br /><a href="#Q6">Goto: 問題6 「Tagged Grand Total」</a></p>
<h2 id="ネスト関数"><a href="#ネスト関数">ネスト関数</a></h2>
<p>なんと関数内には関数を記述できます！ また、その関数は外側の関数のシンボルを参照することができます。 もし、ネスト関数が<code>static</code>であれば、その外部の関数の<code>static</code>なものしか参照できません。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    <span class="dt">int</span> a;
    <span class="kw">static</span> <span class="dt">int</span> s;

    <span class="dt">void</span> inc(){ ++a; }

    <span class="kw">static</span> <span class="dt">void</span> inc_static(){ ++s; }    <span class="co">// staticなものだけ触れる</span>

    writeln(a);         <span class="co">// 0</span>
    inc();
    inc();
    writeln(a);         <span class="co">// 2</span>
}</code></pre>
<h2 id="関数ポインタ"><a href="#関数ポインタ">関数ポインタ</a></h2>
<p>関数を変数に代入して持ち運べたり、違う関数に渡せると嬉しくないですか？ 実は、関数ポインタ型というデータ型が存在し、この型へ関数へのポインタを格納しておけば、関数への参照を持ち運ぶことができます。 関数ポインタの型は、<code>ReturnType function(ParameterList)</code>となります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> foo(<span class="dt">int</span> a){ writeln(<span class="st">&quot;foo !!!&quot;</span>); }
<span class="dt">void</span> bar(<span class="dt">int</span> b){ writeln(<span class="st">&quot;bar !!!&quot;</span>); }

<span class="dt">void</span> main()
{
    <span class="co">// intを受け取る関数を参照する型</span>
    <span class="dt">void</span> <span class="kw">function</span>(<span class="dt">int</span>) fptr = &amp;foo;

    fptr(<span class="dv">0</span>);                    <span class="co">// foo !!!</span>

    fptr = &amp;bar;
    fptr(<span class="dv">0</span>);                    <span class="co">// bar !!!</span>
}</code></pre>
<p>関数ポインタを使用すれば、関数を値として扱えます。 そのため、条件によって実行する関数を変えたり、関数に関数を渡せたり、関数から関数を返すことも作成可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">int</span> sum(<span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="kw">return</span> a + b; }
<span class="dt">int</span> prd(<span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="kw">return</span> a * b; }


<span class="co">/// std.algorithm.reduceと同じような関数</span>
<span class="dt">int</span> reduce(<span class="dt">int</span> ini, <span class="dt">int</span>[] arr, <span class="dt">int</span> <span class="kw">function</span>(<span class="dt">int</span>, <span class="dt">int</span>) f)
{
    <span class="kw">while</span>(arr.<span class="dt">length</span>){
        ini = f(ini, arr[<span class="dv">0</span>]);
        arr = arr[<span class="dv">1</span> .. $];
    }

    <span class="kw">return</span> ini;
}


<span class="co">// 状態stateによって、返す関数を変える関数</span>
<span class="dt">int</span> <span class="kw">function</span>(<span class="dt">int</span>, <span class="dt">int</span>) getFunc(<span class="dt">bool</span> state)
{
    <span class="kw">if</span>(!state)      <span class="co">// falseのとき</span>
        <span class="kw">return</span> &amp;sum;
    <span class="kw">else</span>
        <span class="kw">return</span> &amp;prd;
}


<span class="dt">void</span> main()
{
    writeln(reduce(<span class="dv">0</span>, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], &amp;sum));     <span class="co">// 10</span>
                                                <span class="co">// 総和</span>

    writeln(reduce(<span class="dv">1</span>, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], &amp;prd));     <span class="co">// 24</span>
                                                <span class="co">// 総乗</span>

    writeln(getFunc(<span class="kw">false</span>) == &amp;sum);
    writeln(getFunc(<span class="kw">true</span>) == &amp;prd);
}</code></pre>
<p>すべての関数に対して、<code>&amp;&lt;function&gt;</code>が関数ポインタを返すわけではありません。 非<code>static</code>なネスト関数やメンバ関数(メソッド)についてはデリゲートというものを返します。</p>
<h2 id="デリゲートdelegate"><a href="#デリゲートdelegate">デリゲート<code>delegate</code></a></h2>
<p>関数ポインタを使えば、たしかに関数から関数を返すことは可能です。 では、引数<code>int a</code>を取り、「引数<code>int b</code>を取って、<code>a</code>と<code>b</code>の和を返す関数」を返す関数<code>accum</code>を作れるでしょうか？ つまり、次のようなコードを満たす関数です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// accum関数は引数を一つ取って、関数を返す</span>
<span class="kw">auto</span> func1 = accum(<span class="dv">5</span>);
writeln(func1(<span class="dv">3</span>));          <span class="co">// 8</span>
                            <span class="co">// 5 + 3</span>

<span class="kw">auto</span> func2 = accum(<span class="dv">8</span>);
writeln(func2(<span class="dv">12</span>));         <span class="co">// 20</span>
                            <span class="co">// 12 + 8</span>

writeln(func1(<span class="dv">3</span>));          <span class="co">// 8</span>
                            <span class="co">// 5 + 3</span>
                            <span class="co">// func1の状態は、func2に影響されない</span></code></pre>
<p>グローバル変数に最初の引数の値を保存すれば実現できそうですが、<code>func1</code>の状態が<code>func2</code>に影響されてしまします。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;


<span class="dt">int</span> a;  <span class="co">// accumで、第一引数を保存する変数</span>


<span class="kw">auto</span> accum(<span class="dt">int</span> a)
{
    <span class="co">// グローバルなaにローカルなaを代入</span>
    .a = a;

    <span class="co">// accumImplへの関数ポインタを返す</span>
    <span class="kw">return</span> &amp;accumImpl;
}


<span class="dt">int</span> accumImpl(<span class="dt">int</span> b)
{
    <span class="co">// グローバルなaとローカルのbの和を返す</span>
    <span class="kw">return</span> .a + b;
}


<span class="dt">void</span> main()
{
    <span class="co">// accum関数は引数を一つ取って、関数を返す</span>
    <span class="kw">auto</span> func1 = accum(<span class="dv">5</span>);
    writeln(func1(<span class="dv">3</span>));          <span class="co">// 8</span>
                                <span class="co">// 5 + 3</span>

    <span class="kw">auto</span> func2 = accum(<span class="dv">8</span>);
    writeln(func2(<span class="dv">12</span>));         <span class="co">// 20</span>
                                <span class="co">// 8 + 12</span>

    writeln(func1(<span class="dv">3</span>));          <span class="co">// 11</span>
                                <span class="co">// 5 + 3 = 8 なのに、func2の影響を受けて、</span>
                                <span class="co">// 8 + 3 = 11 になってしまった。</span>
}</code></pre>
<p>グローバル変数の代わりに<code>static</code>変数を使ってもこのような関数は作れないのですが、では関数のローカル変数を触れるネスト関数を作り、その関数ポインタを返すのはどうでしょう？この実装だと、仕様を満たす関数になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> accum(<span class="dt">int</span> a)
{
    <span class="dt">int</span> accumImpl(<span class="dt">int</span> b)
    {
        <span class="kw">return</span> a + b;
    }

    <span class="kw">return</span> &amp;accumImpl;
}</code></pre>
<p>実は、<code>accum</code>は関数ポインタを返すのではなくて、<b>デリゲート</b>(delegate)というものを返しています。 試しに、返り値の推論をやめて<code>int function(int) accum(int a)</code>と書けばコンパイルエラーになりますね。</p>
<pre><code>Error: cannot implicitly convert expression (&amp;accumImpl) of type int delegate(int b) to int function(int)</code></pre>
<p>コンパイラがいうには、「<code>(&amp;accumImpl)</code>は<code>int delegate(int)</code>型であって、<code>int function(int)</code>型には暗黙変換できませんよ」ということなのです。 <code>int delegate(int)</code>型は<code>int</code>を受け取って<code>int</code>を返すデリゲート型のことです。</p>
<p>デリゲートは、関数ポインタと、それが作られた環境についての情報(スタックポインタ)を併せて持っています。 そのため、<code>accumImpl</code>から作られたデリゲートは<code>accum</code>の<code>a</code>の値を参照できるのです。 この<code>a</code>の寿命は、<code>accum</code>関数が終了しても継続し続け、<code>accumImpl</code>から作られたデリゲートや、そのデリゲートのコピーがすべて無くなったら、次のガベージコレクタの回収時に回収されます。<br /><small>(このようなデリゲートをクロージャ(closure)と呼びます。)</small></p>
<p><code>accum</code>を2回呼び出し、その2つの返り値のデリゲートが持っているスタックポインタを比較すると、それらは異なります。 つまり、<code>accum</code>の環境(スタック)の複製をデリゲートは持ちます。 このような性質により、<code>accum</code>を何回呼び出したとしてもメモリがある限り、返されるデリゲートは独立します。</p>
<p>「<code>A</code>型を受け取り、<code>B</code>型を返すデリゲート」の型は<code>B delegate(A)</code>となります。</p>
<p>関数オブジェクト(関数ポインタや、<code>opCall</code>の定義 されている構造体やクラス)をデリゲートに変換したい場合には、<code>std.functional.toDelegate</code>を使います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.functional;

<span class="dt">int</span> foo(<span class="dt">int</span> a){ <span class="kw">return</span> a; }

<span class="dt">void</span> main()
{
    <span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) dlg = toDelegate(&amp;foo);   <span class="co">// 関数ポインタ -&gt; デリゲート</span>
    writeln(dlg(<span class="dv">3</span>));                            <span class="co">// 3</span>
}</code></pre>
<p><a href="#Q7">Goto: 問題7 「カウンター」</a></p>
<h2 id="関数のリテラルとラムダ"><a href="#関数のリテラルとラムダ">関数のリテラルとラムダ</a></h2>
<p>先の例では、関数内にネスト関数を宣言し、そのネスト関数から作られるデリゲートを返していました。 しかし、関数(関数ポインタやデリゲート)がリテラルとしてソースコード中に表現できるなら、わざわざネスト関数を宣言する必要はありませんね。</p>
<p>今回は先ほどの<code>accum</code>をなるべく短く実装していきましょう。 ネスト関数を使った<code>accum</code>を以下にもう一度示しておきます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) accum(<span class="dt">int</span> a)
{
    <span class="dt">int</span> accumImpl(<span class="dt">int</span> b)
    {
        <span class="kw">return</span> a + b;
    }

    <span class="kw">return</span> &amp;accumImpl;
}</code></pre>
<p>まず、<code>accumImpl</code>をリテラルで表現してみると次のようになります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) accum(<span class="dt">int</span> a)
{
    <span class="kw">return</span> <span class="kw">delegate</span> <span class="dt">int</span>(<span class="dt">int</span> b){ <span class="kw">return</span> a + b; };
}</code></pre>
<p>行数が極端に減りましたね。 もし、関数ポインタを返したいなら、<code>delegate</code>を<code>function</code>にしますが、関数ポインタでは外部の環境(<code>a</code>)へアクセスできないので、今回の場合は関数ポインタにできません。</p>
<p>リテラル表現では、<code>delegate</code>や返り値の<code>int</code>を省くことができます。 すると、次のようにさらに短くなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) accum(<span class="dt">int</span> a)
{
    <span class="kw">return</span> (<span class="dt">int</span> b){ <span class="kw">return</span> a + b; }
}</code></pre>
<p>このようなリテラルの場合には、関数ポインタかデリゲートかどうかが推論されます。 今回の場合には、外部の<code>a</code>をリテラル内で触っているので、もちろんデリゲートになります。</p>
<p>さらに、ラムダという記法を用いると、もっと短くなります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) accum(<span class="dt">int</span> a)
{
    <span class="kw">return</span> (<span class="dt">int</span> b) =&gt; a + b;
}</code></pre>
<p>さて、最終の仕上げですが、引数の型も推論してもらいましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) accum(<span class="dt">int</span> a)
{
    <span class="kw">return</span> b =&gt; a + b;
}</code></pre>
<p>おまけとして、<code>accum</code>をもっと短くすると、次のような面白い書き方になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">enum</span> accum = (<span class="dt">int</span> a) =&gt; (<span class="dt">int</span> b) =&gt; a + b;</code></pre>
<p>もっとも短い関数を表すリテラルは<code>{}</code>でしょう。 次いで<code>{;}</code>、<code>(){}</code>になります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> <span class="kw">function</span>() f1 = {},
                f2 = {;},
                f3 = (){};

<span class="dt">void</span> <span class="kw">delegate</span>() d1 = {},
                d2 = {;},
                d3 = (){};</code></pre>
<p>ラムダでも<code>function</code>や<code>delegate</code>の指定ができます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) accum(<span class="dt">int</span> a)
{
    <span class="kw">return</span> <span class="kw">delegate </span>(<span class="dt">int</span> b) =&gt; a + b;
}</code></pre>
<p><code>pure</code>や<code>nothrow</code>, <code>@safe</code>などの関数属性は、リテラル表現では推論されますが、次のように指定することも可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> <span class="kw">delegate</span>(<span class="dt">int</span>) accum(<span class="dt">int</span> a)
{
    <span class="kw">return</span> <span class="kw">delegate</span> <span class="dt">int</span>(<span class="dt">int</span> b) <span class="kw">nothrow</span> @safe { <span class="kw">return</span> a + b; };
    <span class="kw">return</span> <span class="kw">delegate </span>(<span class="dt">int</span> b) <span class="kw">nothrow</span> @safe { <span class="kw">return</span> a + b; };
    <span class="kw">return</span> (<span class="dt">int</span> b) <span class="kw">nothrow</span> @safe { <span class="kw">return</span> a + b; };
    <span class="kw">return</span> (<span class="dt">int</span> b) <span class="kw">nothrow</span> @safe =&gt; a + b;
    <span class="kw">return</span> (b) <span class="kw">nothrow</span> @safe =&gt; a + b;
}</code></pre>
<p>セーフ関数の中でメモリセーフでない関数や機能を使いたい場合には、<code>@trusted</code>付きのリテラルを使うのが習慣のようです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> unsafe();           <span class="co">// セーフでない操作</span>

<span class="dt">void</span> foo() <span class="co">/*@safe*/</span>    <span class="co">// 関数全体でみるとメモリ安全なのに、unsafeがあるから@safeになれない</span>
{
    <span class="co">//... unsafeの操作がメモリ安全になるような操作</span>

    <span class="kw">auto</span> a = unsafe();
    
    <span class="co">//... unsafeの操作がメモリ安全になるような操作</span>
}


<span class="dt">void</span> bar() @safe        <span class="co">// メモリ安全でない操作を行ってても、関数全体でみればメモリ安全だからOK</span>
{
    <span class="co">//... unsafeの操作がメモリ安全になるような操作</span>

    <span class="kw">auto</span> a = () @trusted =&gt; unsafe();

    <span class="co">//... unsafeの操作がメモリ安全になるような操作</span>
}</code></pre>
<p><a href="#Q8">Goto: 問題8 「関数型スタイルなD」</a></p>
<h2 id="ufcsuniform-function-call-syntax"><a href="#ufcsuniform-function-call-syntax">UFCS(Uniform Function Call Syntax)</a></h2>
<p>関数は通常<code>func(a, b, c)</code>のように呼び出しますが、UFCSという糖衣構文を使うことで、<code>a.func(b, c)</code>というように、<code>func</code>が<code>a</code>のメンバ関数であるかのように記述できます。 たとえば、<code>std.conv.to</code>は、様々な型から他の型への変換を提供しますが、<code>to!string(a)</code>と書くよりも、<code>a.to!string()</code>の方がより英文みたいになってわかりやすくなります。 さらに、<code>f1(f2(f3(a)))</code>と書くよりも、<code>a.f3().f2().f1()</code>と書くほうが、<code>a</code>がどのような順番でどのような処理を受けるかがすぐにわかります。</p>
<p>スライスがレンジとして機能する理由は、UFCSによって<code>std.array</code>の関数が<code>arr.front</code>, <code>arr.popFront()</code>, <code>arr.empty</code>というように呼び出せるからです。</p>
<p>もちろん、<code>a.f()</code>の<code>()</code>はプロパティの記法によって省略できるので、<code>a.f3.f2.f1</code>とも書けます。 素晴らしいですね。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm;
<span class="kw">import</span> std.array;
<span class="kw">import</span> std.random;
<span class="kw">import</span> std.range;
<span class="kw">import</span> std.stdio;


<span class="dt">void</span> main()
{
    <span class="kw">auto</span> gen = Random(unpredictableSeed),   <span class="co">// 乱数生成器を作る</span>
         r = iota(<span class="dv">100</span>).randomCover(gen);    <span class="co">// 0 ~ 99までをランダムな順番にする。</span>

    <span class="co">// ランダムに並んだ0 ~ 99のうち、偶数のみを抜き取り(filter!&quot;!(a&amp;1)&quot;), 文字列に変換(map!&quot;a.to!string()&quot;)して、それを表示</span>
    writeln(r.filter!<span class="st">&quot;!(a&amp;1)&quot;</span>().map!<span class="st">&quot;a.to!string()&quot;</span>());


    <span class="dt">int</span> a = <span class="dv">5</span>;

    <span class="co">// 狂気の如く連ねることも可能</span>
    a.identity.identity.identity.identity.identity.identity.identity.writeln;
}


<span class="co">// そのまま返す関数</span>
<span class="kw">auto</span> <span class="kw">ref</span> T identity(T)(<span class="kw">auto</span> <span class="kw">ref</span> T a)
{
    <span class="kw">return</span> a;
}</code></pre>
<h2 id="ctfecompile-time-function-execution"><a href="#ctfecompile-time-function-execution">CTFE(Compile Time Function Execution)</a></h2>
<p>関数は、ある程度の条件を満たせばコンパイル時に実行することができます。 コンパイル時とは、そのままの意味で、実行時ではなくてコンパイルしている段階ということです。 C++のテンプレートを用いたテンプレートメタプログラミング(TMP)や、<code>constexpr</code>を使用した経験がある人にとっては、D言語のCTFEは素晴らしい機能だとわかるでしょう。 コンパイル時プログラミングの経験がない人にとっては、コンパイル時に関数が走ってなにが嬉しいのだろうと思うでしょう。</p>
<p>もし、定数を事前に(コンパイル時に)計算できるなら？ もし、コンパイル時に関数がプログラムを生成してくれたら？</p>
<p>D言語では、CTFE以外にも快適なコンパイル時プログラミングを支援する機能が揃っています。</p>
<p>さて、話はCTFEに戻って、関数がCTFEableであるためには、以下の制約を満たす必要があります。 これらの制約はそのうち緩和される可能性があります。</p>
<ul>
<li>関数本体がD言語のソースコードとしてある</li>
<li>関数の中で実行する式や文では以下の操作は行えない(実行されない式や文が、以下の操作を行うかもしれなくても、OK)
<ul>
<li>グローバル変数や、ローカルstatic変数の参照</li>
<li>インラインアセンブラ(<code>asm</code>文)</li>
<li>プラットフォーム依存なキャスト(<code>int[]</code>から<code>float[]</code>や、エンディアン依存なキャスト)</li>
<li>CTFEableでない関数の呼び出し</li>
<li><code>delete</code>文</li>
</ul></li>
</ul>
<p>特別なシンボルとして<code>__ctfe</code>というものがあり、CTFE時には<code>true</code>となり、実行時には<code>false</code>となります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.regex;
<span class="kw">import</span> std.stdio;


<span class="kw">pragma</span>(msg, ctEvaluated());                     <span class="co">// true</span>


<span class="co">/// コンパイル時と、実行時で値が変わる関数。trueならコンパイルに評価された</span>
<span class="dt">bool</span> ctEvaluated()
{
    <span class="kw">if</span>(!__ctfe){
        <span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];
        <span class="kw">delete</span> arr;                 <span class="co">// コンパイル時には絶対に実行されないのでOK</span>
    }

    <span class="kw">return</span> __ctfe;
}


<span class="dt">void</span> main()
{
    <span class="kw">enum</span> enumValue = ctEvaluated();
    <span class="kw">immutable</span> immValue = ctEvaluated();
    <span class="kw">const</span> cntValue = ctEvaluated();
    <span class="dt">bool</span> mutValue = ctEvaluated();

    <span class="kw">static</span> staticValue = ctEvaluated();

    writeln(<span class="st">&quot;enum:          &quot;</span>, enumValue);      <span class="co">// true</span>
    writeln(<span class="st">&quot;immutable:     &quot;</span>, immValue);       <span class="co">// false</span>
    writeln(<span class="st">&quot;const:         &quot;</span>, cntValue);       <span class="co">// false</span>
    writeln(<span class="st">&quot;local mutable: &quot;</span>, mutValue);       <span class="co">// false</span>
    writeln(<span class="st">&quot;local static:  &quot;</span>, staticValue);    <span class="co">// true</span>
}</code></pre>
<h2 id="問題-1"><a href="#問題-1">問題</a></h2>
<p><a href="answer.md#function">解答</a></p>
<ul>
<li><p><a name = "Q1">問題1 「readIntを実装しよう」</a></p>
<p>ユーザーが入力する数字を読み取って、<code>int</code>型で返す関数<code>readInt</code>を書いてください。 <code>readInt</code>の引数や返り値の型は以下のとおりです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> readInt();</code></pre>
ヒント
<ul>
<li><code>std.conv.to!int</code><br /></li>
<li><code>std.stdio.readln</code><br /></li>
<li><code>std.string.chomp</code></li>
</ul></li>
<li><p><a name = "Q2">問題2 「sumを実装しよう」</a></p>
<p>配列<code>int[]</code>を受け取って、その総和を返す関数<code>sum</code>を書いてください。 <code>sum</code>の引数や戻り値の型は以下のとおりです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">int</span> sum(<span class="dt">int</span>[]);</code></pre></li>
<li><p><a name = "Q3">問題3 「コンパイルできない！」</a></p>
<p>次のプログラムをコンパイルしてみると、<code>Deprecation: non-final switch statement without a default is deprecated</code>というメッセージと共にコンパイルエラー となってしまいます。 エラー文を読んでみると、9行目の普通の<code>switch</code>文で、<code>default</code>が抜けているようです。 <code>idx</code>の値は<code>1, 2, 3</code>しか受け取らないと仮定し、すべての間違いを修正して、コンパイルできるようにしてください。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">int</span> g1 = <span class="dv">1</span>,
    g2 = <span class="dv">10</span>,
    g3 = <span class="dv">20</span>;


<span class="dt">int</span> getGlobalValue(<span class="dt">size_t</span> idx)
{
    <span class="kw">switch</span>(idx){
        <span class="kw">case</span> <span class="dv">1</span>:
            <span class="kw">return</span> g1;

        <span class="kw">case</span> <span class="dv">2</span>:
            <span class="kw">return</span> g2;

        <span class="kw">case</span> <span class="dv">3</span>:
            <span class="kw">return</span> g3;
    }
}


<span class="dt">void</span> main()
{
    writeln(getGlobalValue(<span class="dv">1</span>));
    writeln(getGlobalValue(<span class="dv">10</span>));
    writeln(getGlobalValue(<span class="dv">20</span>));
}</code></pre></li>
<li><p><a name = "Q4">問題4 「helpメッセージを表示せよ」</a></p>
<p>コンソールでコマンドを叩くときに、コマンドライン引数に<code>-h</code>とか<code>--help</code>を入れると、そのコマンドに対するメッセージがだいたい出力されますよね。 試しに<code>dmd --help</code>と打ってみると、dmdのコマンド引数の一覧が出力されると思います。(<code>dmd</code>の場合は、<code>dmd</code>だけで表示されるのですが)</p>
<p>以下に示すプログラムは、<code>add --a=12 --b=13</code>というように呼び出すと<code>12 + 13 = 15</code>と表示されるプログラムです。 また、<code>getopt(...);</code>後の変数<code>h_sw</code>には、コマンド引数に<code>-h</code>や<code>--help</code>が出現したかどうかが入っています。 (出現したら<code>true</code>)</p>
<p>このプログラムを少し書き換えて、<code>-h</code>や<code>--help</code>がコマンド引数に現れた場合には<code>writeln(appInfo);</code>をして即座にプログラムが終了するようにしてください。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.getopt;
<span class="kw">import</span> std.stdio;


<span class="kw">immutable</span> appInfo = <span class="st">`example:</span>
<span class="st">$ add --a=12 --b=13</span>
<span class="st">a + b = 25</span>

<span class="st">$ add --b=1, --a=3</span>
<span class="st">a + b = 4</span>
<span class="st">`</span>;


<span class="dt">void</span> main(<span class="dt">string</span>[] args)
{
    <span class="dt">int</span> a, b;
    <span class="dt">bool</span> h_sw;              <span class="co">// argsに-h, --helpが出現したかどうか</span>

    getopt(args,
        <span class="st">&quot;a&quot;</span>, &amp;a,
        <span class="st">&quot;b&quot;</span>, &amp;b,
        <span class="st">&quot;h|help&quot;</span>, &amp;h_sw);

    writeln(<span class="st">&quot;a + b = &quot;</span>, a + b);
}</code></pre></li>
<li><p><a name = "Q5">問題5 「Grand Total」</a></p>
<p>関数を呼び出す毎に過去と今の<code>int</code>型引数の総和を返す関数<code>gt</code>を作ってください。 つまり、次のような関数です。</p>
<pre class="sourceCode d"><code class="sourceCode d">writeln(gt(<span class="dv">10</span>));            <span class="co">// 10</span>
writeln(gt(<span class="dv">1</span>));             <span class="co">// 11</span>
writeln(gt(<span class="dv">9</span>));             <span class="co">// 20</span>
writeln(gt(<span class="dv">8</span>));             <span class="co">// 28</span>

writeln(gt(<span class="dv">5</span>, <span class="kw">true</span>));       <span class="co">// 5    第二引数をtrueにすると、0になる</span>
writeln(gt(<span class="dv">10</span>));            <span class="co">// 10</span></code></pre></li>
<li><p><a name = "Q6">問題6 「Tagged Grand Total」</a></p>
<p><a href="#Q5">Q5</a>とほとんど同じですが、今回の関数は新たにもう一つ引数として<code>string</code>型をとります。 この引数<code>string</code>を「タグ」と呼ぶことにしましょう。 <code>taggedGt</code>関数を作ってもらうわけですが、先ほどの<code>gt</code>は関数<code>gt</code>1つにつき、同時に合計が計算できるのは1つでした。 <code>taggedGt</code>では、タグを指定することで、同時に複数の合計を計算できるようにしてください。</p>
<pre class="sourceCode d"><code class="sourceCode d">writeln(taggedGt(<span class="st">&quot;A&quot;</span>, <span class="dv">10</span>));             <span class="co">// 10</span>
writeln(taggedGt(<span class="st">&quot;B&quot;</span>, <span class="dv">1</span>));              <span class="co">// 1</span>
writeln(taggedGt(<span class="st">&quot;C&quot;</span>, <span class="dv">3</span>));              <span class="co">// 3</span>

writeln(taggedGt(<span class="st">&quot;A&quot;</span>, <span class="dv">100</span>));            <span class="co">// 110</span>
writeln(taggedGt(<span class="st">&quot;B&quot;</span>, <span class="dv">10</span>));             <span class="co">// 11</span>
writeln(taggedGt(<span class="st">&quot;C&quot;</span>, <span class="dv">3</span>));              <span class="co">// 6</span>

writeln(taggedGt(<span class="st">&quot;A&quot;</span>, <span class="dv">3</span>, <span class="kw">true</span>));        <span class="co">// 3    第3引数がtrueでクリア</span>

writeln(taggedGt(<span class="st">&quot;B&quot;</span>, <span class="dv">2</span>, <span class="kw">true</span>, <span class="kw">true</span>));  <span class="co">// 2    第4引数がtrueなら、そのタグの終了</span>

writeln(taggedGt(<span class="st">&quot;A&quot;</span>, <span class="dv">3</span>));              <span class="co">// 6</span>
writeln(taggedGt(<span class="st">&quot;B&quot;</span>, <span class="dv">4</span>));              <span class="co">// 4</span>
writeln(taggedGt(<span class="st">&quot;C&quot;</span>, <span class="dv">5</span>));              <span class="co">// 11</span>

taggedGt(<span class="st">&quot;A&quot;</span>, <span class="dv">0</span>, <span class="kw">true</span>, <span class="kw">true</span>);           <span class="co">// 数え上げ終わりのときは、必ず第4引数をtrueにする</span>
taggedGt(<span class="st">&quot;B&quot;</span>, <span class="dv">0</span>, <span class="kw">true</span>, <span class="kw">true</span>);           <span class="co">// 同上</span>
taggedGt(<span class="st">&quot;C&quot;</span>, <span class="dv">0</span>, <span class="kw">true</span>, <span class="kw">true</span>);           <span class="co">// 同上</span></code></pre>
ヒント:
<ul>
<li>連想配列</li>
<li>第4引数がtrueのときは、連想配列からそのタグを削除</li>
</ul></li>
<li><p><a name = "Q7">問題7 「カウンター」</a></p>
<p>次のようなソースコードを満たす、<code>createCounter</code>を実装してください。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> cnt1 = createCounter();

writeln(cnt1());             <span class="co">// 1</span>
cnt1();
cnt1();
writeln(cnt1());             <span class="co">// 4</span>

<span class="kw">auto</span> cnt2 = createCounter();

writeln(cnt2());            <span class="co">// 1</span>
writeln(cnt1());            <span class="co">// 5</span>
writeln(cnt2());            <span class="co">// 2</span></code></pre></li>
<li><p><a name = "Q8">問題8 「関数型スタイルなD」</a></p>
<p>関数を関数に渡して処理の内容を変えたりするという技法は、関数型プログラミングというものに属するそうです。 D言語の標準ライブラリPhobosは、基本的にこの技法をベースにして作成されています。</p>
<p>例えば、<code>std.algorithm.map</code>を見てみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm,
       std.conv,
       std.stdio;

<span class="dt">void</span> main(){
    <span class="kw">auto</span> r = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>];

    writeln(r.map!(a =&gt; a + <span class="dv">1</span>)());          <span class="co">// [1, 2, 3]</span>
    writeln(r.map!(a =&gt; a.to!<span class="dt">string</span>()));    <span class="co">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span>
}</code></pre>
<p><code>map!(a =&gt; a + 1)</code>というシンタックスは見慣れませんね。 (まだ説明してないからなのですが。) 簡単に説明すると、<code>map</code>関数にコンパイル時引数として、ラムダ<code>a =&gt; a + 1</code>を渡しているという意味です。</p>
<p><code>r.map!(a =&gt; a + 1)()</code>は<code>r</code>の全ての要素に1足すという意味で、<code>r.map!(a =&gt; a.to!string())</code>は<code>r</code>のすべての要素を文字列表現に変換するという意味です。</p>
<p><code>filter</code>と<code>reduce</code>という素晴らしいものが<code>std.algorithm</code>にあるのですが、Phobosのドキュメントを読んで、次の関数を作ってください。</p>
<ul>
<li>配列<code>int[] arr</code>を受け取って、<code>arr</code>の要素のうち、偶数の要素の総和を返す関数<code>sumOfEven</code></li>
<li>配列<code>int[] arr</code>と<code>int needle</code>を受け取って、<code>arr</code>の中で最も<code>needle</code>に近い値を返す関数<code>getApprxEqElm</code></li>
</ul>
Phobosのドキュメント:
<ul>
<li>filter: <a href="http://dlang.org/phobos/std_algorithm.html#filter">英語</a>, <a href="http://www.kmonos.net/alang/d/phobos/std_algorithm.html#filter">日本語</a></li>
<li>reduce: <a href="http://dlang.org/phobos/std_algorithm.html#reduce">英語</a>, <a href="http://www.kmonos.net/alang/d/phobos/std_algorithm.html#reduce">日本語</a></li>
</ul></li>
<li><p>問題募集中</p></li>
</ul>
<h2 id="終わりに-1"><a href="#終わりに-1">終わりに</a></h2>
<p>実はこの関数の章は、文章量では、他の章に対して3倍(対：式と演算子)～15倍(対：ポインタ)もの量を誇っています。 それほど関数というのは複雑なのです。 ですが、これからは嫌というほど書いていくことになるので、自然と身につくはずです。</p>
<p>さて、次は「メイン関数」について説明します。</p>
<h2 id="キーワード-9"><a href="#キーワード-9">キーワード</a></h2>
<ul>
<li>関数(function)</li>
<li>引数(argument, parameter)
<ul>
<li>仮引数(parameter)</li>
<li>実引数(argument)</li>
</ul></li>
<li>戻り値, 返り値(return value)</li>
<li>関数本体</li>
<li>関数プロトタイプ</li>
<li><code>return</code>文</li>
<li><code>assert(0);</code></li>
<li>仮引数のデフォルト値(parameter’s default value)</li>
<li>仮引数の記憶域クラス(parameter storage class)
<ul>
<li><code>in</code></li>
<li><code>out</code></li>
<li><code>ref</code></li>
<li><code>lazy</code></li>
<li><code>const</code></li>
<li><code>immutable</code></li>
<li><code>shared</code></li>
<li><code>inout</code></li>
<li><code>scope</code></li>
<li>(<code>auto ref</code>)</li>
</ul></li>
<li>可変個引数関数(variadic function)</li>
<li><code>auto</code>関数, <code>auto ref</code>関数</li>
<li>関数属性(function attribute)
<ul>
<li><code>@property</code></li>
<li><code>@safe</code>, <code>@trusted</code>, <code>@system</code></li>
<li><code>pure</code></li>
<li><code>nothrow</code></li>
<li>UDA(User Defined Attribute)</li>
<li><code>const</code>, <code>immutable</code>, <code>inout</code>, <code>abstract</code>, <code>final</code></li>
</ul></li>
<li>関数オーバーロード(overload)
<ul>
<li>オーバーロード集合(overload set)</li>
</ul></li>
<li>ローカル<code>static</code>変数(local static variable)</li>
<li>ネスト関数(nested function)</li>
<li>関数ポインタ(function pointer)</li>
<li>デリゲート(delegate)</li>
<li>ラムダ(lambda, λ)</li>
<li>UFCS(Uniform Function Call Syntax)</li>
<li>CTFE(Compile Time Function Execution)</li>
<li>関数型プログラミング(functional programming)</li>
</ul>
<h2 id="仕様-5"><a href="#仕様-5">仕様</a></h2>
<ul>
<li>関数: <a href="http://dlang.org/function.html">英語</a>, <a href="http://www.kmonos.net/alang/d/function.html">日本語</a></li>
</ul>
<h1 id="main関数"><a href="#main関数">main関数</a></h1>
<p>この章では、今まで散々書いてきたmain関数について解説していきます。</p>
<h2 id="シグネチャ"><a href="#シグネチャ">シグネチャ</a></h2>
<p>関数名, 関数の戻り値型, 関数が取る引数の型リストの3つをまとめてシグネチャ(signature)といいます。 今まで書いてきたmain関数のシグネチャは<code>void main();</code>だけですが、実際には以下のバリエーションがあります。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main();
<span class="dt">void</span> main(<span class="dt">string</span>[] args);

<span class="co">// 以下2つは通常使われない</span>
<span class="dt">int</span> main();
<span class="dt">int</span> main(<span class="dt">string</span>[] args);</code></pre>
<p>実は、<strong>main関数は<code>string[]</code>型の引数を受け取ることができます！</strong></p>
<h2 id="コマンドライン引数とstd.getopt"><a href="#コマンドライン引数とstd.getopt">コマンドライン引数と<code>std.getopt</code></a></h2>
<p>この<code>string[] args</code>にはコマンドライン引数が配列として格納されています。 コマンドライン引数とは、プログラムを起動する際にシェルやコマンドプロンプトから渡される引数のことです。 <code>dmd</code>を例にすると、<code>dmd</code>に対するコマンドライン引数は<code>dmd foo bar</code>と打ち込んだ際の<code>foo</code>や<code>bar</code>のことです。 では実際に次のソースコードをコンパイルして、次のようにコマンドライン引数を渡して実行してみましょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// io_main.d</span>
<span class="kw">import</span> std.stdio;

<span class="dt">void</span> main(<span class="dt">string</span>[] args)
{
    writeln(args);
}</code></pre>
<p>[Windows]の場合:</p>
<pre><code>$ dmd io_main
$ ./io_main foo bar
[&quot;.\\io_main.exe&quot;, &quot;foo&quot;, &quot;bar&quot;]</code></pre>
<p>実行してみると、<code>args</code>の1つ目の要素にはプログラム名、2つ目には<code>&quot;foo&quot;</code>, 3つ目には<code>&quot;bar&quot;</code>が格納されていることがわかりますね。 つまり、実際にコンソールで渡した“foo”や“bar”が配列の第2要素以降へ格納されているのです。 引数は、スペースを区切り文字として区切られ<code>args</code>に格納されますが、もし<code>&quot;foo bar&quot;</code>というように<code>&quot;&quot;</code>で括っていれば、スペースで区切られずにそのままの表記となります。</p>
<pre><code>$ ./io_main &quot;foo bar&quot;
[&quot;.\\io_main.exe&quot;, &quot;foo bar&quot;]</code></pre>
<p>コマンドライン引数は、普通のプログラム、たとえば<code>dmd</code>だと<code>-run</code>とか<code>-m64</code>だとかのようにハイフン<code>-</code>と識別子を与えたり、<code>-version=Foo</code>のように値を設定したり, 対象のファイルのパスを指定するのに使用されます。</p>
<p>次のプログラムは2つのコマンドライン引数に設定された値の合計を出力するプログラムです。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">// io_main.d</span>
<span class="kw">import</span> std.stdio;
<span class="kw">import</span> std.conv;


<span class="dt">void</span> main(<span class="dt">string</span>[] args)
{
    <span class="dt">int</span> a, b;

    <span class="kw">foreach</span>(e; args[<span class="dv">1</span> .. $]){
        <span class="kw">if</span>(e[<span class="dv">0</span> .. <span class="dv">4</span>] == <span class="st">&quot;--a=&quot;</span>)
            a = e[<span class="dv">4</span> .. $].to!<span class="dt">int</span>();
        <span class="kw">else</span> <span class="kw">if</span>(e[<span class="dv">0</span> .. <span class="dv">4</span>] == <span class="st">&quot;--b=&quot;</span>)
            b = e[<span class="dv">4</span> .. $].to!<span class="dt">int</span>();
    }

    writeln(a + b);
}</code></pre>
<pre><code>$ dmd io_main
$ ./io_main --a=10 --b=5
15
$ ./io_main --b=2 --a=5
7</code></pre>
<p>しかし、引数の種類が多くなってくるとプログラムに渡されたコマンドライン引数を処理するのは難しくなります。 そのため、D言語の標準ライブラリであるPhobosには<code>std.getopt</code>というモジュールが含まれています。 <code>std.getopt.getopt</code>を使えば簡単に引数から情報を得ることが出来ます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;
<span class="kw">import</span> std.getopt;

<span class="dt">void</span> main(<span class="dt">string</span>[] msg)
{
    <span class="dt">int</span> a, b;

    getopt(msg,
           <span class="st">&quot;a&quot;</span>, &amp;a,
           <span class="st">&quot;b&quot;</span>, &amp;b);

    writeln(a + b);
}</code></pre>
<pre><code>$ dmd io_main
$ ./io_main --a=10 --b=5
15
$ ./io_main --b=2 --a=5
7
$ ./io_main --a 3 --b 2
5
$ ./io_main -a=10 -b=5
15
$ ./io_main -a 10 -b 5
15</code></pre>
<h2 id="返り値"><a href="#返り値">返り値</a></h2>
<p>main関数の返り値の型は<code>void</code>もしくは<code>int</code>ですが、普通は<code>void</code>にしておきます。 あなたがC言語ユーザーであったり、低レイヤーを扱っている場合で無い限りは返り値の型は<code>void</code>でいいでしょう。</p>
<p>もし返り値の型が<code>void</code>の場合には、D言語のランタイムが、つまりあなたの代わりにプログラムが適切な値を返してくれます。 ランタイムに任せておけば、あなたは何も考える必要はありません。</p>
<h2 id="問題-2"><a href="#問題-2">問題</a></h2>
<p>問題募集中</p>
<h2 id="キーワード-10"><a href="#キーワード-10">キーワード</a></h2>
<ul>
<li>メイン関数</li>
<li>コマンドライン引数</li>
<li><code>std.getopt</code></li>
</ul>
<h1 id="ファイルと標準入出力"><a href="#ファイルと標準入出力">ファイルと標準入出力</a></h1>
<h2 id="ファイル出力"><a href="#ファイル出力">ファイル出力</a></h2>
<p>ファイルに出力するには大きく分けて二通りの方法がよく使われます。</p>
<ol type="1">
<li><code>std.stdio.File</code>を使う</li>
<li><code>std.file.write</code>や<code>std.file.append</code>を使う</li>
</ol>
<!---->

<p>1.の方法は、C言語での<code>stdio.h</code>の<code>FILE*</code>を使うような方法です。 2.はデータを一度に書き出すのに便利です。</p>
<!---->

<h3 id="std.stdio.fileを使う"><a href="#std.stdio.fileを使う"><code>std.stdio.File</code>を使う</a></h3>
<p>C言語の入門書ではファイル操作に<code>FILE*</code>を使用しますが、D言語でも普通は<code>std.stdio.File</code>構造体を使用します。 使用方法は簡単で、今まで使用してきた<code>std.stdio.write</code>などと同様のものをメンバとして持ちます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> f1 = File(<span class="st">&quot;foo.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);     <span class="co">// 書き込みモードで開く</span>
    f1.writeln(<span class="st">&quot;くぁｗせｄｒｆｔｇｙふじこｌｐ；&quot;</span>);

    {
        <span class="kw">auto</span> f2 = f1;                   <span class="co">// sameFileはf1と同じファイルを指す</span>
        f2.write(<span class="st">&quot;ふぉおばｒほげ&quot;</span>);
    }

    f1 = File(<span class="st">&quot;hoge.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);         <span class="co">// 違うファイルを開く</span>
                                        <span class="co">// foo.txtは自動的にで閉じられる。</span>

    <span class="co">// Fileは、同じファイルを参照しているすべてのFile構造体がなくなれば、自動的に閉じられる。</span>
    <span class="co">// 明示的にファイルを閉じたいのであれば、File.detach()を使う</span>
    f1.detach();                        <span class="co">// file.close()が呼ばれる</span>
}</code></pre>
<p>配列のデータをバイナリでそのままファイルに書き出したい場合には、<code>std.stdio.File.rawWrite</code>を使用します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> f = File(<span class="st">&quot;foo.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);
    <span class="dt">int</span>[] data = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];

    f.rawWrite(data);
}</code></pre>
<p>リトルエンディアンの環境では、ファイルには次のようなデータが出力されます。 もちろん、16進数表示しているだけで、実際にはビットの列でしかありません。</p>
<pre><code>01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00 </code></pre>
<h3 id="std.file.writeやstd.file.appendを使う"><a href="#std.file.writeやstd.file.appendを使う"><code>std.file.write</code>や<code>std.file.append</code>を使う</a></h3>
<p><code>std.file.write</code>や<code>std.file.append</code>は、配列をバイナリとしてそのまま出力するのに使用します。 つまり、<code>std.file.File.rawWrite</code>のように使用します。 この2つを使えば、いちいち<code>std.stdio.File</code>を作らなくてもファイルに出力できます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.file;

<span class="dt">void</span> main()
{
    <span class="dt">int</span>[] data = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];

    std.file.write(<span class="st">&quot;foo.dat&quot;</span>, data);        <span class="co">// foo.datが無ければ新しくファイルが作られる</span>
    std.file.append(<span class="st">&quot;bar.dat&quot;</span>, data);       <span class="co">// bar.datがない場合は、write同様に新しく作られる</span>

    std.file.write(<span class="st">&quot;foo.dat&quot;</span>, <span class="st">&quot;ふー&quot;</span>);        <span class="co">// foo.datを文字列で上書きする</span>
    std.file.append(<span class="st">&quot;bar.dat&quot;</span>, <span class="st">&quot;ばー&quot;</span>);       <span class="co">// bar.datに文字列を追加</span>
}</code></pre>
<h2 id="標準出力stdout"><a href="#標準出力stdout">標準出力<code>stdout</code></a></h2>
<p>標準出力とは、通常はコンソールなどの画面への出力のことです。 しかし、リダイレクトという機能によって、ファイルなどに出力することも可能になります。</p>
<p>標準出力に出力するためには、<code>std.stdio.write</code>などの関数を使いましょう。 また、<code>std.stdio</code>には<code>stdout</code>という<code>File</code>型のグローバル変数が定義されているので、<code>stdout</code>に対して操作しても標準出力に表示されます。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;Hello, World!&quot;</span>);   <span class="co">// 標準出力(コンソール)に出力される</span>

    stdout.rawWrite(<span class="st">&quot;foo bar\n&quot;</span>); <span class="co">// 同上</span>
}</code></pre>
<h2 id="ファイル入力"><a href="#ファイル入力">ファイル入力</a></h2>
<p>出力と違って、入力は様々なバリエーションがあります。 たとえば、「1行だけほしい」とか「<code>foreach</code>で回したい」とかです。 ファイル入力の手段としては、次の2つが適切でしょう。</p>
<ol type="1">
<li><code>std.stdio.File</code>を使う</li>
<li><code>std.file.read</code>や<code>std.file.readText</code>を使う</li>
</ol>
<!---->

<h3 id="std.stdio.fileを使う-1"><a href="#std.stdio.fileを使う-1"><code>std.stdio.File</code>を使う</a></h3>
<ul>
<li>1行取得</li>
</ul>
<p><code>File</code>から1行取得するには、<code>File.readln</code>を使用します。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> file = File(<span class="st">&quot;foo.txt&quot;</span>);

    <span class="dt">string</span> str = file.readln();
    writeln(str);
}</code></pre>
<ul>
<li><code>File.readf</code></li>
</ul>
<p>ファイル中に書いてある数値などを読み込みたい場合には、<code>readf</code>が便利です。 次のように使います。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.ascii,
       std.stdio;

<span class="dt">void</span> main()
{
    {
        <span class="kw">auto</span> file = File(<span class="st">&quot;foo.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);
        file.writeln(<span class="st">&quot;123x345&quot;</span>);           <span class="co">// foo.txtに&quot;123x345\n&quot;を書き込む</span>
        file.writeln(<span class="st">&quot;foo-bar&quot;</span>);
    }

    <span class="kw">auto</span> file = File(<span class="st">&quot;foo.txt&quot;</span>);
    <span class="dt">int</span> a = <span class="dt">void</span>, b = <span class="dt">void</span>;
    
    <span class="co">// foo.txtから、&quot;%sx%s&quot;というフォーマットで2つの整数を読み込む</span>
    <span class="co">// `&amp;a`というように、ポインタを渡す</span>
    file.readf(<span class="st">&quot;%sx%s&quot;</span>, &amp;a, &amp;b);

    writefln(<span class="st">&quot;%s : %s&quot;</span>, a, b);          <span class="co">// 123 : 345</span>

    <span class="co">// 改行文字分だけ進める</span>
    file.seek(std.ascii.newline.<span class="dt">length</span>, SEEK_CUR);

    <span class="dt">string</span> str1 = <span class="dt">void</span>, str2 = <span class="dt">void</span>;

    <span class="co">// &quot;%s-%s&quot;というフォーマットとなっているテキストを読む</span>
    file.readf(<span class="st">&quot;%s-%s&quot;</span> ~ newline, &amp;str1, &amp;str2);
    writefln(<span class="st">&quot;%s : %s&quot;</span>, str1, str2);
}</code></pre>
<ul>
<li><code>foreach</code>で行ごとに取得する</li>
</ul>
<p>ファイルの各行ごとに様々な処理を行いたいことはよく有ります。</p>
<p>たとえば、CSV(カンマで値が区切られた形式)として次のようなファイルがあったとしましょう。</p>
<pre><code>出席番号,点数
1,68
2,72
3,45
4,83
5,53
6,75
7,99
8,77
9,101
10,22</code></pre>
<p>このクラスの平均点や標準偏差, 各生徒に対する偏差値を求めたい場合には、<code>File.byLine</code>を使った次のようなプログラムを書くと良いでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.conv,
       std.range,
       std.stdio;

<span class="dt">void</span> main()
{
    <span class="kw">immutable</span> filename = <span class="st">&quot;input.csv&quot;</span>;

    <span class="kw">auto</span> file = File(filename);
    file.byLine.popFront();         <span class="co">// 1行捨てる</span>

    <span class="dt">int</span>[] points;

    <span class="co">// ファイルを各行取得する。</span>
    <span class="co">// KeepTerminator.noを指定すると、改行文字がlineの末尾に現れなくなる</span>
    <span class="co">// lineはstring型</span>
    <span class="kw">foreach</span>(line; file.byLine(KeepTerminator.no)){
        <span class="co">// 行をカンマ&quot;,&quot;で区切り、2つ目の要素を数値(int)に変換する</span>
        points ~= line.split(<span class="st">&quot;,&quot;</span>)[<span class="dv">1</span>].to!<span class="dt">int</span>();
    }

    <span class="co">// 平均</span>
    <span class="kw">immutable</span> mean = {
        <span class="dt">real</span> sum = <span class="dv">0</span>;
        <span class="kw">foreach</span>(e; points)
            sum += e;

        <span class="kw">return</span> sum / points.<span class="dt">length</span>;
    }();

    <span class="co">// 標準偏差</span>
    <span class="kw">immutable</span> devi = {
        <span class="dt">real</span> sum = <span class="dv">0</span>;
        <span class="kw">foreach</span>(e; points)
            sum += (e - mean) ^^ <span class="dv">2</span>;

        <span class="kw">return</span> (sum / points.<span class="dt">length</span>) ^^ <span class="fl">0.5</span>;
    }();

    <span class="co">// 全員の偏差値</span>
    <span class="dt">real</span>[] scor;
    <span class="kw">foreach</span>(e; points)
        scor ~= <span class="dv">10</span> * (e - mean) / devi + <span class="dv">50</span>;

    writefln(<span class="st">&quot;Mean: %s&quot;</span>, mean);
    writefln(<span class="st">&quot;Standard Deviation: %s&quot;</span>, devi);
    writefln(<span class="st">&quot;Standard Score: \n%(%s\n%)&quot;</span>, scor);
}</code></pre>
<pre><code>Mean: 69.5
Standard Deviation: 22.9532
Standard Score:
49.3465
51.0892
39.3261
55.8815
42.8115
52.3962
62.8522
53.2675
63.7236
29.3057</code></pre>
<p><code>File.byLine</code>はレンジを返します、と言ってもまだレンジについては説明してませんので、今の時点では「配列みたいなもの」が返ってくると解釈してください。</p>
<ul>
<li>nバイトごとに取得する</li>
</ul>
<p>筆者は、この記事を書いている時点では高専5年生で、今までに電気工学を5年間学び、さらにあと4年はオプトエレクトロニクス(光と半導体)について勉強するつもりです。 高専では4年生や5年生になれば卒業研究があるのですが、私は電離層ついて研究しています。 電離層は地上50kmから500km程度の大気の層のことをいいます。 なぜ電気工学科なのに大気の研究をしているか不思議ではありませんか？</p>
<p>電離層では多くの気体分子が太陽からの光によって電離した状態にあります。 つまり、電荷密度が存在するのですが、その電荷密度によって電波は屈折されてしまいます。 この現象によって電波を使った長距離通信が行えるのですが、時々電離層は非常に乱れた状態になってしまいます。 電離層が乱れた状態では、電波は上手く反射されず長距離通信に影響を及ぼしてしまいます。 実は、電離層の研究は進んでおらず、このような電離層の乱れがなぜ起こるのかもはっきりとはわかっていません。 また、大規模な地震の前触れとして電離層が乱れる現象を利用して、電離層を観測することによって地震を予測することも注目されています(私の個人的意見では無理だろうと思っていますが)。 私の卒業研究のテーマは、GPS(広義ではGNSS)から来る電波を用いて電離層の状態を把握することです。</p>
<p>つまり私の卒業研究は、GPS衛星が出す電波を地上のアンテナで取得し、そのデータを解析することです。 アンテナで取得した信号はフロントエンドに入り、約1.5GHzという高い周波数からヘテロダインによってたった6.5MHzまで落とされます。 6.5MHzの信号は、26Msps(1秒間に26×2^20個のデータを取得)というもの凄いサンプリング速度でAD変換され、コンピュータにUSBを通して保存されます。</p>
<p>コンピュータに保存されたデータは、1バイトが1回のサンプリングされたデータに相当し、プログラムでは1msごとに処理しているので、1度のファイル読み込みで26Msps×1byte×1ms=26kBのデータを取得することになります。</p>
<p><code>File.byChunk</code>を使えば、このような「一定量を連続して読み込む」動作が簡単に実現可能です。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;


<span class="dt">void</span> main(){
    <span class="kw">immutable</span> filename = <span class="st">&quot;data.dat&quot;</span>;
    <span class="kw">auto</span> file = File(filename);

    <span class="kw">foreach</span>(buf_; file.byChunk(<span class="dv">26</span> &lt;&lt; <span class="dv">20</span>)){
        <span class="co">// buf_はbyChunkによって使いまわされるので、</span>
        <span class="co">// もしbuf_を書き換えるか、</span>
        <span class="co">// ループを抜けてもbuf_を保存しておきたいのであれば、</span>
        <span class="co">// .dupでコピーをとっておく</span>
        <span class="kw">auto</span> buf = buf_.<span class="dt">dup</span>;

        <span class="co">// bufに対する処理</span>
    }
}</code></pre>
<h3 id="std.file.readやstd.file.readtextを使う"><a href="#std.file.readやstd.file.readtextを使う"><code>std.file.read</code>や<code>std.file.readText</code>を使う</a></h3>
<p><code>std.stdio.File</code>を使用するのに比べると、<code>std.file</code>のこの2つの関数は、ファイルの内容全部を取得するのに便利です。</p>
<p><code>std.file.read</code>はファイルの内容をバイナリとして、<code>std.file.readText</code>はファイルの内容を文字列として読み込む場合に適しています。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main(){
    <span class="kw">auto</span> bs = <span class="kw">cast</span>(<span class="dt">ubyte</span>[])read(<span class="st">&quot;data.dat&quot;</span>);        <span class="co">// data.datをまるごと読み込む</span>

    <span class="kw">auto</span> str = readText(<span class="st">&quot;foo.txt&quot;</span>);                 <span class="co">// テキストとして読み込む</span>
}</code></pre>
<h2 id="標準入力stdin"><a href="#標準入力stdin">標準入力<code>stdin</code></a></h2>
<p>標準入力とは、コンソールへのキーボードを使った入力です。 次のソースコードをコンパイルし実行してみるとその意味がわかるでしょう。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.conv,
       std.string,
       std.stdio;

<span class="dt">void</span> main()
{
    write(<span class="st">&quot;Please put a number and press the Enter Key. ---- &quot;</span>);
    
    <span class="kw">immutable</span> n = readln()      <span class="co">// 1行読み込んで</span>
                  .chomp()      <span class="co">// 末尾の改行を消して</span>
                  .to!<span class="dt">int</span>();    <span class="co">// intに変換</span>

    write(<span class="st">&quot;Please put a number and press the Enter Key. ---- &quot;</span>);

    <span class="kw">immutable</span> m = readln()      <span class="co">// 1行読み込んで</span>
                  .chomp()      <span class="co">// 末尾の改行を消して</span>
                  .to!<span class="dt">int</span>();    <span class="co">// intに変換</span>

    writeln(<span class="st">&quot;Sum of the numbers you entered is %s.&quot;</span>, n + m);
}</code></pre>
<h2 id="問題-3"><a href="#問題-3">問題</a></h2>
<p><a href="answer.md#main_io">解答</a></p>
<ul>
<li><p>問題1</p>
<p><code>readln</code>を使って3行取得して、各行の先頭2文字を削って表示するプログラムを作りなさい。</p></li>
<li><p>問題2</p>
<p>ファイル<code>from</code>の内容をそのままファイル<code>to</code>として書き出す関数<code>void copyTo(string from, string to)</code>を、次の2通りの方法で作りなさい。 一つ目は<code>std.file</code>の関数を使い、もう一つは<code>std.stdio.File</code>を活用しなさい。</p></li>
<li><p>問題3</p>
<p>コンソール(標準入力)に入力された文字をそのままファイルに出力するプログラムを作りたい。 コンソールへの入力の形式は以下のようになる。</p>
<pre><code>[書き出したいファイル名]
[書き出したい行数nの指定]
[ファイルに書き出す内容：1行目]
[ファイルに書き出す内容：2行目]
            ・
            ・
            ・
[ファイルに書き出す内容：n行目]</code></pre>
<p>つまり、以下の様な入力であれば、ファイル<code>&quot;foo.txt&quot;</code>に<code>foo bar</code>と<code>hogehoge</code>の2行だけ書きだされる。</p>
<pre><code>foo.txt
2
foo bar
hogehoge</code></pre></li>
</ul>
<h2 id="おわりに-9"><a href="#おわりに-9">おわりに</a></h2>
<p>今回の問題は簡単にしたつもりですがどうでしょうか？ 入出力については、dioというものが提案されていたりするので、将来大きな変更が入る可能性があります。</p>
<p>さて、次からはユーザー定義型シリーズとなります。 第一回目である次回は構造体について解説します。</p>
<h2 id="キーワード-11"><a href="#キーワード-11">キーワード</a></h2>
<ul>
<li><code>std.stdio</code>
<ul>
<li><code>File</code></li>
</ul></li>
<li><code>std.file</code>
<ul>
<li><code>write</code></li>
<li><code>append</code></li>
<li><code>read</code></li>
<li><code>readText</code></li>
</ul></li>
</ul>
<h1 id="構造体"><a href="#構造体">構造体</a></h1>
<h2 id="ユーザー定義型"><a href="#ユーザー定義型">ユーザー定義型</a></h2>
<p>今までは<code>int</code>だったり<code>long</code>、または<code>string</code>などの型を使用してプログラムを組んできましたが、この章と後のいくつかの章ではユーザー定義型について紹介していきます。 ユーザー定義型というのは、その名の通りユーザー(プログラマ)が任意に定義できる型です。 構造体などのユーザー定義型は、今までの言語定義の型(プリミティブ型)と全く同様に使用できます。</p>
<p>今回はその一つ目ということで、D言語では最もベーシックで、最も利用頻度が多いユーザー定義型である構造体<code>struct</code>と、それを用いた隠蔽について解説します。</p>
<h2 id="複数の型をまとめるということ"><a href="#複数の型をまとめるということ">複数の型をまとめるということ</a></h2>
<p>構造体とは、簡単にいえばデータの固まりを新たに型として定義できる機能です。</p>
<p>もしあなたがゲームを作りたいとしましょう。 さらに少しこじつけ気味ですが、そのゲームで画面に長方形の何かを描きたいとします。 長方形は長方形の位置<code>float x, y</code>と長方形の大きさ<code>float width, height</code>で表せます。 では、複数の長方形をプログラム上で表すにはどうしましょうか？</p>
<table class="sourceCode d numberLines compilableCheck inMain"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="dt">float</span>[] xs, ys, ws, hs;
<span class="co">// もしくは</span>
<span class="co">// float[4][] rects;</span></code></pre></td></tr></table>
<p>これで複数の長方形を表せそうです。</p>
<p>「長方形のリストを表すために4つの配列を操作することを強いられているんだ！」</p>
<p>そんなことはないので、こういう場合には構造体を使いましょう。</p>
<h2 id="構造体の基本"><a href="#構造体の基本">構造体の基本</a></h2>
<p>構造体とは、複数のデータを一つにまとめたものを表すユーザー定義型です。 たとえば、長方形を表す<code>Rectangle</code>型は次のように定義します。</p>
<table class="sourceCode d numberLines compilableCheck" srcNameAsString="def_rectangle"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> Rectangle
{
    <span class="dt">float</span> x, y;
    <span class="dt">float</span> width,
          height;
}</code></pre></td></tr></table>
<p><code>Rectangle</code>の内部に定義してある<code>x, y, width, height</code>をメンバ変数もしくはフィールドといいます。 構造体のメンバ変数へは次のようにメンバ変数名を用いてアクセス可能です。</p>
<table class="sourceCode d numberLines compilableCheck inMain" with="def_rectangle"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode d">Rectangle rect; <span class="co">// Rectangle型の変数rectを宣言</span>

rect.x = <span class="fl">5.5</span>;   <span class="co">// xに5.5を代入</span>

<span class="co">// x = 1, y = 3, width = 10.5, height = 2.3 な Rectangleを代入</span>
rect = Rectangle(<span class="dv">1</span>, <span class="dv">3</span>, <span class="fl">10.5</span>, <span class="fl">2.3</span>);

<span class="co">// メンバ変数を指定して初期化, 宣言時のみ有効</span>
Rectangle rect2 = {x : <span class="dv">1</span>, width : <span class="dv">3</span>, y : <span class="dv">4</span>, height : <span class="dv">2</span>};</code></pre></td></tr></table>
<p><code>Rectangle</code>型は、今までの<code>int</code>や<code>long</code>等のプリミティブ型と同様に使用できます。 もちろん、デフォルト初期化値<code>Rectangle.init</code>も有効です。 今回の<code>Rectangle</code>のデフォルト初期化値は、それぞれのメンバ変数のデフォルト初期化値になりますが、 次のように<code>Rectangle</code>を定義することでデフォルト初期化値を変更できます。</p>
<table class="sourceCode d numberLines compilableCheck"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> Rectangle
{
    <span class="dt">float</span> x;
    <span class="dt">float</span> y;
    <span class="dt">float</span> width = <span class="dv">0</span>;
    <span class="dt">float</span> height = <span class="dv">0</span>;
}</code></pre></td></tr></table>
<p>元の初期化値は<code>Rectangle(float.nan, float.nan, float.nan, float.nan)</code>ですが、2つ目の<code>Rectangle</code>の初期化値は<code>Rectangle(float.nan, float.nan, 0, 0)</code>となります。</p>
<p>最初に例として提示した<code>Rectangle</code>の配列は、当然ですが型は<code>Rectangle[]</code>となり、<code>int[]</code>などと同様に使用可能です。</p>
<table class="sourceCode d numberLines compilableCheck inMain" with="def_rectangle"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="sourceCode"><pre><code class="sourceCode d">Rectangle[] rects;

rects ~= Rectangle(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>);
rects ~= [Rectangle(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>),
          Rectangle(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="fl">4.4</span>)];

<span class="kw">foreach</span>(e; rects)
    writefln(<span class="st">&quot;面積 S = %s&quot;</span>, e.width * e.height);

<span class="kw">foreach</span>(i; <span class="dv">1</span> .. rects.<span class="dt">length</span>){
    rects[i-<span class="dv">1</span>].x += rects[i].x;
    rects[i-<span class="dv">1</span>].y += rects[i].y;
}

writeln(rects);</code></pre></td></tr></table>
<h2 id="構造化プログラミングとその発展"><a href="#構造化プログラミングとその発展">構造化プログラミングとその発展</a></h2>
<p>昔(1970~80)は(というより今でも)データ構造と手続き(関数)を一緒に考える構造化プログラミングスタイルが主流でした。 さらにその昔は混沌としたプログラミングスタイルでしたから、 データ構造と、それを扱う専用の関数を考えるというこのスタイルは素晴らしいといえます。 混沌とした世の中に構造化プログラミングを提唱したダイクストラは、手続きとデータの両方が抽象化されるべきであると彼の論文“Structured Programming”(1969)にて主張しています。 手続きとデータ構造の両方を抽象化する利点は、データ構造に変更を加えるような修正を行う場合や、複雑なデータ構造を上手く隠しながらプログラムを作る時に最も効力を発揮します。 データ構造が変わったとしても、それを扱う手続きをまとめた関数さえ修正すれば、プログラム全体の動作に影響を与えなくて済みますし、複雑なデータ構造であっても関数によって覆い隠されてしまえば、簡単に扱えるようになるのです。 これをデータのカプセル化(隠蔽)といい、現代のプログラミング技術では必須となっています。</p>
<p>ダイクストラが構造化プログラミングを提唱する数年前に、Simulaという言語が登場し、後に登場するオブジェクト指向言語はこのSimulaに影響を受けたというお話はまた別の機会に。</p>
<h2 id="メンバ関数"><a href="#メンバ関数">メンバ関数</a></h2>
<p>データ構造とそれを扱う専用の手続きを一緒に扱うことによって、素晴らしいプログラムが書けることは構造化プログラミングから学べることでした。 データ構造は、構造体によって構築できそうですが、その構造体を扱う専用の関数はどのように記述するのが最も適切でしょうか？</p>
<p>たとえば、長方形<code>Rectangle</code>を<code>(dx, dy)</code>だけ平行移動する関数<code>translate</code>は次のように書けます。</p>
<table class="sourceCode d numberLines compilableCheck" with="def_rectangle"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="dt">void</span> translate(<span class="kw">ref</span> Rectangle rect, <span class="dt">float</span> dx, <span class="dt">float</span> dy)
{
    rect.x += dx;
    rect.y += dy;
}


<span class="dt">void</span> foo()
{
    Rectangle rect = Rectangle(<span class="dv">600</span>, <span class="dv">400</span>, <span class="dv">1920</span>, <span class="dv">1080</span>);

    translate(rect, -<span class="dv">600</span> + <span class="dv">1920</span> / <span class="dv">2</span>, -<span class="dv">400</span> + <span class="dv">1080</span> / <span class="dv">2</span>);
}</code></pre></td></tr></table>
<p>しかし、この書き方だと<code>translate</code>関数が<code>Rectangle</code>型に所属していることが少し不透明です。</p>
<p><code>Rectangle</code>型にのみ所属する関数をメンバ関数といいます。 メンバ関数内では、フィールドに対してそのままの名前でアクセス可能です。 また、<code>this</code>という暗黙の引数を持っていますので、<code>this</code>経由でフィールドに触ることも可能です。</p>
<p><code>this</code>は<code>ref Rectangle</code>な引数だと考えることが出来ます。 <code>this</code>に対して<code>const</code>や<code>immutable</code>、さらには<code>inout</code>などを付加させたい場合はメンバ関数の属性にそれらを付加させます。</p>
<table class="sourceCode d numberLines compileCheck"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> Rectangle
{
    <span class="dt">float</span> x;
    <span class="dt">float</span> y;
    <span class="dt">float</span> width = <span class="dv">0</span>;
    <span class="dt">float</span> height = <span class="dv">0</span>;


    <span class="co">// void translateInPlace(ref Rectangle, float dx, float dy)</span>
    <span class="co">/**</span>
<span class="co">    (dx, dy)だけ平行移動する。</span>
<span class="co">    */</span>
    <span class="dt">void</span> translateInPlace(<span class="dt">float</span> dx, <span class="dt">float</span> dy)
    {
        x += dx;        <span class="co">// メンバ関数内では、フィールドを触れる</span>
        <span class="kw">this</span>.y += dy;   <span class="co">// 暗黙の引数this経由でも触れる</span>

        <span class="kw">assert</span>(&amp;width == &amp;(<span class="kw">this</span>.width));
        <span class="kw">assert</span>(&amp;height == &amp;(<span class="kw">this</span>.height));

        <span class="kw">pragma</span>(msg, <span class="dt">typeof</span>(<span class="kw">this</span>));  <span class="co">// Rectangle</span>
    }


    <span class="co">// Rectangle translate(const ref Rectangle, float dx, float dy)</span>
    <span class="co">// もちろんpure, nothrow @safeなどの属性も付加できる。</span>
    Rectangle translate(<span class="dt">float</span> dx, <span class="dt">float</span> dy) <span class="kw">const</span> <span class="kw">pure</span> <span class="kw">nothrow</span> @safe
    {
        <span class="kw">return</span> Rectangle(x + dx, y + dy, width, height);
    }


    <span class="co">/// 面積を返す</span>
    <span class="dt">float</span> area() <span class="kw">pure</span> <span class="kw">nothrow</span> @safe
    {
        <span class="kw">return</span> width * height;
    }


    <span class="co">// 引数が0個か1個の場合にのみプロパティとなれる。</span>
    <span class="co">// getterの例</span>
    <span class="co">/**</span>
<span class="co">    Rectangleの中心の座標を、配列float[2]で返します。</span>
<span class="co">    float[0]にはx座標が、float[1]にはy座標が格納されています。</span>
<span class="co">    */</span>
    <span class="dt">float</span>[<span class="dv">2</span>] center() @property <span class="kw">pure</span> <span class="kw">nothrow</span> @safe <span class="kw">const</span>
    {
        <span class="kw">return</span> [x + width/<span class="dv">2</span>, y + height/<span class="dv">2</span>];
    }


    <span class="co">// setterの例</span>
    <span class="co">/**</span>
<span class="co">    Rectangleの中心座標を設定します。</span>
<span class="co">    */</span>
    <span class="dt">void</span> center(<span class="dt">float</span>[<span class="dv">2</span>] f) <span class="kw">pure</span> <span class="kw">nothrow</span> @safe @property
    {
        x = f[<span class="dv">0</span>] - width/<span class="dv">2</span>;
        y = f[<span class="dv">1</span>] - height/<span class="dv">2</span>;
    }
}


<span class="dt">void</span> main()
{
    <span class="kw">import</span> std.stdio;
    Rectangle rect = Rectangle(<span class="dv">600</span>, <span class="dv">400</span>, <span class="dv">1920</span>, <span class="dv">1080</span>);

    <span class="co">// translateInPlaceメソッドの呼び出し</span>
    rect.translateInPlace(-<span class="dv">600</span> - <span class="dv">1920</span> / <span class="dv">2</span>, -<span class="dv">400</span> - <span class="dv">1080</span> / <span class="dv">2</span>);

    <span class="kw">const</span> cRect = rect;
    <span class="co">// ↓NG</span>
    <span class="co">// cRect.translateInPlace(-600 + 1920 / 2, -400 + 1080 / 2);</span>
    <span class="co">// ↑のように、constやimmutable, inoutの付いていないメソッドは</span>
    <span class="co">// mutableな型(Rectangle型)からのみしか呼び出せない。</span>
    <span class="co">// なぜなら、const(Rectangle)を引数に取る関数をRectangle型で呼び出すことは出来ないから。</span>

    <span class="co">// プロパティ(getter)の呼び出し方</span>
    <span class="kw">assert</span>(rect.center == [<span class="dv">0</span>, <span class="dv">0</span>]);

    <span class="co">// プロパティ(setter)の呼び出し方</span>
    rect.center = [<span class="dv">600</span>, <span class="dv">400</span>];
}</code></pre></td></tr></table>
<h3 id="ufcsとメンバ関数の使い分けと型クラス余談"><a href="#ufcsとメンバ関数の使い分けと型クラス余談">UFCSとメンバ関数の使い分けと型クラス(余談)</a></h3>
<p>確かに、UFCSを使えばメンバ関数でなくても<code>rect.translate(dx, dy)</code>のように呼び出せます。 しかし、たとえばモジュールを跨いだコードでは上手く動きません。</p>
<table class="sourceCode d numberLines" group="ufcs_typeclass_example" module="foo"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">module</span> foo;

<span class="kw">auto</span> <span class="kw">ref</span> callTranslate(T)(<span class="kw">auto</span> <span class="kw">ref</span> T t, <span class="dt">float</span> dx, <span class="dt">float</span> dy)
{
    <span class="kw">return</span> t.translate(dx, dy);
}</code></pre></td></tr></table>
<table class="sourceCode d numberLines checkUnCompilable" group="ufcs_typeclass_example" module="rectangle"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">module</span> rectangle;

<span class="kw">import</span> foo;

<span class="kw">struct</span> Rectangle
{
    <span class="dt">float</span> x;
    <span class="dt">float</span> y;
    <span class="dt">float</span> width = <span class="dv">0</span>;
    <span class="dt">float</span> height = <span class="dv">0</span>;
}

<span class="dt">void</span> translate(<span class="kw">ref</span> Rectangle rect, <span class="dt">float</span> dx, <span class="dt">float</span> dy)
{
    rect.x += dx;
    rect.y += dy;
}

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> rect = Rectangle(<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">1</span>);

    rect.callTranslate(<span class="fl">2.5</span>, <span class="fl">2.5</span>);
}</code></pre></td></tr></table>
<pre><code>foo.d(5): Error: no property &#39;translate&#39; for type &#39;Rectangle&#39;
rectangle.d(23): Error: template instance foo.callTranslate!(Rectangle) error instantiating</code></pre>
<p>関数型言語での型クラスのようなものや、C++のconceptをD言語で表したい場合にはUFCSが上手く働きます。 その最も身近な例は配列型<code>T[]</code>とRangeとの関係です。 動的配列<code>T[]</code>には<code>.front</code>や<code>.empty</code>、<code>.popFront()</code>は定義されていませんが、<code>std.array</code>をimportすることによってそれらが使えるようになります。 また、Rangeを受け取る関数テンプレートを書く場合には、<code>std.range</code>や<code>std.array</code>をimportすることが一般的ですから、例に示したモジュールの問題も発生しません。</p>
<h2 id="アクセス保護属性とフィールドの隠蔽"><a href="#アクセス保護属性とフィールドの隠蔽">アクセス保護属性とフィールドの隠蔽</a></h2>
<p>構造化プログラミングでは、データ構造が変わっても関数のシグネチャが変わっていなければ、プログラム全体は上手く動くとしました。 外部から構造体のデータ構造、つまりはメンバ変数にアクセスできてしまうとマズイわけです。</p>
<p>そこで登場するのが、前章で登場したアクセス保護属性です。 メンバのアクセス保護属性のデフォルト状態は<code>public</code>になっていますので、 外部からアクセスされたくないメンバには<code>private</code>を付加しておきましょう。</p>
<p>ちなみに、メンバ変数については特別な理由がない限り<code>private</code>にしておくとよいでしょう。</p>
<table class="sourceCode d numberLines checkCompilable"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> Rectangle
{
    <span class="co">/// いろいろな実装</span>

  <span class="kw">private</span>:
    <span class="dt">float</span> _x;
    <span class="dt">float</span> _y;
    <span class="dt">float</span> _w = <span class="dv">0</span>;
    <span class="dt">float</span> _h = <span class="dv">0</span>;


    <span class="co">// 外部からは使えないメソッド</span>
    <span class="dt">void</span> foo()
    {
        writeln(<span class="st">&quot;foo&quot;</span>);
    }
}</code></pre></td></tr></table>
<h3 id="データ構造へのアクセスとプロパティ"><a href="#データ構造へのアクセスとプロパティ">データ構造へのアクセスとプロパティ</a></h3>
<p>「メンバ変数については、特別な理由がない限り<code>private</code>にしておくとよい」と書きましたが、そうしてしまえば外部からメンバ変数へアクセスする手段がなくなってしまいます。 そこでプロパティ関数の登場です。 プロパティ関数を上手く使うことでデータ構造を隠蔽しつつ、外部に公開もできます。 一見矛盾したようなこの手法ですが、ちゃんとした理由があります。 まず、メンバ関数として外部に公開するので、データ構造に変更を加えても何とかできる可能性が高くなります。 また、メンバ変数へ代入される値を引数として取得できますから、不正な値が設定されないか監視できます。</p>
<table class="sourceCode d numberLines checkCompilable"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> Rectangle
{
  @property
  {
    <span class="dt">float</span> x() { <span class="kw">return</span> _x; }
    <span class="dt">void</span> x(<span class="dt">float</span> x){ _x = x; }

    <span class="dt">float</span> y() { <span class="kw">return</span> _y; }
    <span class="dt">void</span> y(<span class="dt">float</span> y){ _y = y; }

    <span class="dt">float</span> width() { <span class="kw">return</span> _w; }
    <span class="dt">void</span> width(<span class="dt">float</span> w)
    <span class="kw">in</span>{
        <span class="co">// 幅は、「大きさ」なので正の値</span>
        <span class="kw">assert</span>(w &gt;= <span class="dv">0</span>);
    }
    <span class="kw">body</span>{
        _w = w;
    }

    <span class="dt">float</span> height() { <span class="kw">return</span> _h; }
    <span class="dt">void</span> height(<span class="dt">float</span> h)
    <span class="kw">in</span>{
        <span class="co">// 高さは、「大きさ」なので正の値</span>
        <span class="kw">assert</span>(h &gt;= <span class="dv">0</span>);
    }
    <span class="kw">body</span>{
        _h = h;
    }
  }


  <span class="kw">private</span>:
    <span class="dt">float</span> _x;
    <span class="dt">float</span> _y;
    <span class="dt">float</span> _w = <span class="dv">0</span>;
    <span class="dt">float</span> _h = <span class="dv">0</span>;
}


<span class="dt">void</span> main()
{
    Rectangle rect;

    <span class="co">// プロパティ関数なので、</span>
    <span class="co">// メンバ変数みたいにアクセス可能</span>
    rect.x = <span class="dv">12</span>;
    <span class="kw">assert</span>(rect.x == <span class="dv">12</span>);

    rect.width = <span class="fl">3.14</span>;  <span class="co">// OK</span>
    rect.height = -<span class="dv">2</span>;   <span class="co">// Error</span>
    <span class="co">// heightプロパティ関数によって、</span>
    <span class="co">// 負の数を入れられないようにされている。</span>
}</code></pre></td></tr></table>
<h2 id="コンストラクタ"><a href="#コンストラクタ">コンストラクタ</a></h2>
<p>外部から触ってほしくないメンバに<code>private</code>をつけることで、それを隠蔽できましたね。 次にフィールドの初期化や、構造体の値の作成を考えてみましょう。 <a href="#構造体の基本">これまでの構造体の使い方</a>だと、構造体内のデータ構造が変わってしまうとコンパイルエラーになってしまいます。 つまり、構造化プログラミングの理念に反してしまいます。</p>
<p>そのために、コンストラクタ(constructor, ctor)という専用の関数が存在します。 コンストラクタはその型の値を作成するための関数で、<code>this(...){...}</code>のように宣言します。</p>
<table class="sourceCode d numberLines checkCompilable"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> Rectangle
{
    <span class="co">// コンストラクタの例</span>
    <span class="kw">this</span>(<span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> width, <span class="dt">float</span> height)
    {
        <span class="co">// メンバ関数のように、メンバにアクセス可能</span>
        _xywh = [x, y, width, height];

        <span class="co">// immutableなメンバ変数でも、コンストラクタでは初期化可能</span>
        _imm = <span class="dv">3</span>;
    }


    <span class="co">// コンストラクタは、複数定義可能</span>
    <span class="kw">this</span>(<span class="dt">float</span> width, <span class="dt">float</span> height)
    {
        <span class="co">// コンストラクタ内では、別のctorを1回だけ呼ぶことが出来る</span>
        <span class="kw">this</span>(<span class="dv">0</span>, <span class="dv">0</span>, width, height);
    }


  <span class="kw">private</span>:
    <span class="dt">float</span>[] _xywh;

    <span class="kw">immutable</span> <span class="dt">int</span> _imm;
}


<span class="dt">void</span> main()
{
    <span class="kw">auto</span> rect1 = Rectangle(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    writeln(rect1);      <span class="co">// Rectangle([1, 2, 3, 4]);</span>

    <span class="kw">auto</span> rect2 = Rectangle(<span class="dv">3</span>, <span class="dv">4</span>);
    writeln(rect2);      <span class="co">// Rectangle([0, 0, 4, 5]);</span>
}</code></pre></td></tr></table>
<h2 id="ビットごとのコピーとpostblit"><a href="#ビットごとのコピーとpostblit">ビットごとのコピーとPostblit</a></h2>
<p>ブリット(blit)とは、データをそのままコピーすることです。 Dの構造体はただのデータの集合体ですから、デフォルトでは代入などの操作はメモリのコピーとなります。</p>
<p>ある<code>S</code>型構造体の変数<code>v1</code>を使って、次のように<code>v2</code>を定義した場合にもデフォルトではメモリのコピーしか起こりません。</p>
<table class="sourceCode d numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode d">S v2 = v1;</code></pre></td></tr></table>
<p>しかし、<code>S</code>型構造体にPostblitが定義されていた場合、メモリのコピー後にv2のPostblitが呼ばれます。 Postblitは次のように定義します。</p>
<table class="sourceCode d numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> S
{
    <span class="co">// postblitコンストラクタの定義</span>
    <span class="kw">this</span>(<span class="kw">this</span>)
    {
        <span class="co">// ...</span>
    }

    <span class="co">/// fields</span>
}</code></pre></td></tr></table>
<p>Postblitが呼ばれるタイミングは、<code>S</code>型の値がコピーされた後です。 「値がコピーされた後」という表現はかなり曖昧ですが、つまりは「複製された直後」ということです。 いつコピーされる(値が複製される)かどうかはコンパイラの最適化(NRVO)等に影響されます。</p>
<table class="sourceCode d numberLines checkCompilable"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="kw">struct</span> S
{
    <span class="co">// postblitコンストラクタ</span>
    <span class="kw">this</span>(<span class="kw">this</span>)
    {
        writeln(<span class="st">&quot;call postblit, &quot;</span>, &amp;<span class="kw">this</span>);
    }
}

<span class="dt">void</span> foo(S){}

<span class="dt">void</span> refFoo(<span class="kw">ref</span> S){}

<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;定義&quot;</span>);
    S v1;   <span class="co">// 呼ばれない</span>

    writeln(<span class="st">&quot;コピーコンストラクタ&quot;</span>);
    S v2 = v1;  <span class="co">// call postblit</span>

    writeln(<span class="st">&quot;代入&quot;</span>);
    v2 = v1;    <span class="co">// call postblit</span>

    writeln(<span class="st">&quot;関数引数として渡す&quot;</span>);
    foo(v1);    <span class="co">// call postblit</span>

    writeln(<span class="st">&quot;参照引数として渡す&quot;</span>);
    refFoo(v1); <span class="co">// 呼ばれない</span>

    writeln(<span class="st">&quot;配列化(ctor)&quot;</span>);
    S[] ss = [v1];  <span class="co">// call postblit</span>

    writeln(<span class="st">&quot;配列化(代入)&quot;</span>);
    ss = [v1];      <span class="co">// call postblit</span>
}</code></pre></td></tr></table>
<p>Postblitの役目は、コピー後の値を調整することです。 これによって、たとえば参照カウントをインクリメントしたり、参照オブジェクトを値型のように運用することができます。 実際に<code>std.typecons.RefCounted</code>ではPostblitによって参照カウントをインクリメントしています。</p>
<p>C++などの他の言語ではコピーコンストラクタというものが存在しますが、Dの場合は同様の処理が単純コピーとPostblitによって実行されます。</p>
<h2 id="デストラクタ"><a href="#デストラクタ">デストラクタ</a></h2>
<p>デストラクタ(destructor, dtor)とは、極端なことをいえばコンストラクタの逆です。 つまり、構造体の値が破棄されるときに呼ばれる特殊なメンバ関数みたいなもの、ということです。 デストラクタの主な役割は、コンストラクタとかPostblitで確保したリソース(メモリとか)の解放です。</p>
<table class="sourceCode d numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="dt">void</span> main()
{
    {
        S s1;
    }   <span class="co">// このスコープを抜けると、s1は破棄される</span>
        <span class="co">// 破棄された値に対してdtorが実行される</span>

    <span class="co">// コイツは関数の終了と共に破棄され、dtorが走る</span>
    S s2;
}</code></pre></td></tr></table>
<p>Dにはガベージコレクタがありますが、たとえば先ほどの<code>UniqueArray</code>のGCを介さないバージョンとして<code>UniqueArrayNoGC</code>を考えてみましょう。 GCを使わないので、DのGCヒープからメモリを確保しません。 その代わりにC言語の<code>malloc</code>, <code>free</code>等を用いてCヒープにメモリを確保し、不要になれば適切に破棄します。 コンストラクタや、Postblitで確保されたメモリは、デストラクタによって破棄されるようにします。</p>
<p>このように、コンストラクタとデストラクタを上手く使ってリソースを管理する手法をRAIIといいます。</p>
<table class="sourceCode d numberLines checkCompilable"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">import</span> core.stdc.stdlib : malloc, free;     <span class="co">// Cライブラリを使う</span>
<span class="kw">import</span> core.exception : OutOfMemoryError;
<span class="kw">import</span> std.exception : enforceEx;


<span class="co">/**</span>
<span class="co">要素にint型を持つ配列。</span>
<span class="co">ただしDのガベージコレクタのヒープへは確保せず(@nogc)、</span>
<span class="co">Cヒープ領域のメモリを確保し、管理します。</span>
<span class="co">*/</span>
<span class="kw">struct</span> UniqueArrayNoGC
{
    <span class="co">/*</span>
<span class="co">    要素が未初期化であるような配列を返します。</span>
<span class="co">    ただしガベージコレクタではなく、Cヒープへの確保となります。</span>
<span class="co">    */</span>
    <span class="kw">private</span> <span class="kw">static</span>
    <span class="dt">int</span>[] _uninitializedArray(<span class="dt">size_t</span> n) <span class="kw">nothrow</span> <span class="co">/* @nogc */</span>
    {
        <span class="kw">if</span>(n){
            <span class="co">// Cヒープから確保</span>
            <span class="kw">auto</span> p = <span class="kw">cast</span>(<span class="dt">int</span>*)malloc(<span class="dt">int</span>.<span class="dt">sizeof</span> * n);
            enforceEx!OutOfMemoryError(p !<span class="kw">is</span> <span class="kw">null</span>);       <span class="co">// エラーを投げる</span>

            <span class="kw">return</span> p[<span class="dv">0</span> .. n];
        }<span class="kw">else</span>
            <span class="kw">return</span> <span class="kw">null</span>
    }


    <span class="co">/**</span>
<span class="co">    大きさnのint型を要素として持つ配列を作ります。</span>
<span class="co">    */</span>
    <span class="kw">this</span>(<span class="dt">size_t</span> n) <span class="kw">nothrow</span> @trusted <span class="co">/* @nogc */</span>
    {
        _v = _uninitializedArray(n);

        <span class="co">// 初期化</span>
        <span class="kw">foreach</span>(<span class="kw">ref</span> e; _v)
            e = <span class="dv">0</span>;
    }


    <span class="co">// 内部に持つ配列を常にユニークに保つ</span>
    <span class="kw">this</span>(<span class="kw">this</span>) <span class="kw">nothrow</span> @trusted <span class="co">/* @nogc */</span>
    {
        <span class="kw">auto</span> dst = _uninitializedArray(_v.<span class="dt">length</span>);
        dst[] = _v[];   <span class="co">// 要素のcopy</span>
        _v = dst;       <span class="co">// 入れ替え</span>
    }


    <span class="co">// 管理しているCヒープの配列を解放する</span>
    ~<span class="kw">this</span>() <span class="kw">nothrow</span> @trusted <span class="co">/* @nogc */</span>
    {
        <span class="kw">if</span>(_v !<span class="kw">is</span> <span class="kw">null</span>)
            free(_v.<span class="dt">ptr</span>);   <span class="co">// メモリ解放</span>

        _v = <span class="kw">null</span>;
    }


    <span class="co">/*</span>
<span class="co">    その他のメンバ関数の実装などなど</span>
<span class="co">    ……………</span>
<span class="co">    ………</span>
<span class="co">    …</span>
<span class="co">    */</span>


  <span class="kw">private</span>:
    <span class="dt">int</span>[] _v;
}


<span class="dt">void</span> main()
{
    <span class="kw">auto</span> v1 = UniqueArrayNoGC(<span class="dv">16</span>);
    <span class="kw">auto</span> v2 = UniqueArrayNoGC(<span class="dv">16</span>);
    <span class="kw">assert</span>(v1._v !<span class="kw">is</span> v2._v);    <span class="co">// ユニーク</span>

    <span class="kw">auto</span> v3 = v1;
    <span class="kw">assert</span>(v1._v !<span class="kw">is</span> v3._v);    <span class="co">// 常にユニーク</span>

    <span class="co">// 代入により、v2の値は破棄される</span>
    v2 = v3;    <span class="co">// (v2 dtor) -&gt; (blit v3 to v2) -&gt; (v2 postblit)</span>


    <span class="co">// v1, v2, v3はスコープの終了、つまりmain関数の終了とともに破棄されるので、</span>
    <span class="co">// そのタイミングでそれぞれdtorが走る</span>
}</code></pre></td></tr></table>
<h2 id="構造体の名前空間と静的メンバ"><a href="#構造体の名前空間と静的メンバ">構造体の名前空間と静的メンバ</a></h2>
<p>構造体の内部に定義可能なのは、コンストラクタ, Postblit, デストラクタだけではありません。 モジュールに書けるようなすべての宣言や定義を含めることが出来ます。 つまり、構造体の中に構造体を定義することも可能です。</p>
<p>構造体の内部に定義される関数や変数は、通常はその構造体の値に対して所属しています(つまりメンバ変数, メンバ関数となる)。 しかし、宣言に<code>static</code>をつけると、その関数や変数の所属先は「型」になります。 これを静的メンバ変数及び静的メンバ関数と呼びます。</p>
<p>静的メンバ関数内では、通常のメンバ関数で使用できていた<code>this</code>が使用できなくなります。 また、静的でないメンバを関数内で操作, 呼び出しできません。</p>
<table class="sourceCode d numberLines checkCompilable"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> S{
    <span class="kw">struct</span> SS{
    }

    <span class="dt">int</span> a;

    <span class="dt">int</span> foo(){
        <span class="co">// 静的メンバにも触れる</span>
        sfoo();     <span class="co">// OK</span>
        <span class="kw">return</span> sa;  <span class="co">// OK</span>
    }

  <span class="kw">static</span>:
    <span class="kw">struct</span> SSS{
    }

    <span class="dt">int</span> sa;

    <span class="dt">void</span> sfoo(){
        <span class="co">// 静的でないメンバを触れない</span>
        <span class="co">//foo();    // NG</span>
    }
}


<span class="dt">void</span> main()
{
    S s;        <span class="co">// OK</span>
    S.SS ss;    <span class="co">// OK</span>
    S.SSS sss;  <span class="co">// OK</span>

    s.a = <span class="dv">11</span>;
    S.sa = <span class="dv">12</span>;
    s.sa = <span class="dv">13</span>;  <span class="co">// OK</span>
    <span class="co">//S.a = 14; // NG</span>
    <span class="kw">assert</span>(S.sa == <span class="dv">13</span>); <span class="co">// staticフィールドはS型に対して一つだけ</span>
    <span class="kw">assert</span>(&amp;S.sa == &amp;s.sa); <span class="co">// 同上</span>

    s.foo();
    S.sfoo();
    s.sfoo();   <span class="co">// OK</span>
    <span class="co">//S.foo();  // NG</span>
}</code></pre></td></tr></table>
<h2 id="alias-this"><a href="#alias-this">alias this</a></h2>
<p><code>int</code>や<code>byte</code>などのの整数型には、暗黙の型変換という型変換がありました。 構造体などのユーザー定義型でこの暗黙変換のようなものを実現する機能が<code>alias this</code>です。</p>
<p>たとえば、<code>int</code>型のように振る舞うものの、非負の整数しか許さない整数型は次のように実装できます。</p>
<table class="sourceCode d numberLines checkCompilable"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="sourceCode"><pre><code class="sourceCode d"><span class="kw">struct</span> LimitedInt
{
    <span class="co">// getter</span>
    <span class="dt">int</span> value() @property
    <span class="kw">out</span>(r){
        <span class="kw">assert</span>(r &gt;= <span class="dv">0</span>);
    }
    <span class="kw">body</span>{
        <span class="kw">return</span> _v;
    }


    <span class="co">// setter</span>
    <span class="dt">void</span> value(<span class="dt">int</span> v) @property
    <span class="kw">in</span>{
        <span class="kw">assert</span>(v &gt;= <span class="dv">0</span>);
    }
    <span class="kw">body</span>{
        _v = v;
    }


    <span class="kw">alias</span> value <span class="kw">this</span>;

  <span class="kw">private</span>:
    <span class="dt">int</span> _v;
}


<span class="dt">void</span> main()
{
    LimitedInt a;
    a = <span class="dv">12</span>;
    <span class="kw">assert</span>(a == <span class="dv">12</span>);
    <span class="kw">assert</span>(a != -<span class="dv">12</span>);

    a = a + <span class="dv">3</span>;
    a = a - <span class="dv">3</span>;
    a = a - a;
    a = a * a;

    <span class="co">//a -= a; NG,</span>
    <span class="co">//getterのvalueがlvalueじゃないので.</span>

    a = -<span class="dv">12</span>;      <span class="co">// 実行時にError</span>
}</code></pre></td></tr></table>
<pre><code>core.exception.AssertError@foo(16): Assertion failure
----------------
0x004024DF
0x00402075
0x0040215F
0x004024A8
0x0040247B
0x00402394
0x00402187
0x74A6336A in BaseThreadInitThunk
0x77009F72 in RtlInitializeExceptionChain</code></pre>
<h2 id="問題-4"><a href="#問題-4">問題</a></h2>
<ul>
<li>問題募集中</li>
</ul>
<h2 id="参考文献"><a href="#参考文献">参考文献</a></h2>
<ol type="1">
<li><p><a href="http://www.tatapa.org/~takuo/structured_programming/structured_programming.html">意外と知られていない構造化プログラミング、あるいは構造化プログラミングはデータも手続きと一緒に抽象化する、あるいはストロヴストルップのオブジェクト指向プログラミング史観</a></p></li>
<li><p><a href="http://nekogata.hatenablog.com/entry/2014/01/17/125600">猫型プログラミング言語史観(1) 〜あるいはオブジェクト指向における設計指針のひとつ〜</a></p></li>
</ol>
<h2 id="キーワード-12"><a href="#キーワード-12">キーワード</a></h2>
<ul>
<li><code>struct</code>, 構造体</li>
<li>ユーザー定義型</li>
<li>構造化プログラミング</li>
<li>メンバ関数</li>
<li>アクセス保護属性</li>
<li>コンストラクタ</li>
<li>Postblit</li>
<li>デストラクタ</li>
<li>静的メンバ</li>
<li>alias this</li>
</ul>
</body>
</html>
